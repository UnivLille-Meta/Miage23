@inproceedings{Anqu20a,
	author = {Nicolas Anquetil and Anne Etien and Houekpetodji, Mahugnon Honor\'e and Benoit Verhaeghe St\'ephane Ducasse and Clotilde Toullec and Fatija Djareddir and J\`erome Sudich and Mustapha Derras},
	title = {Modular Moose:  A new generation of software reengineering platform},
	booktitle = {International Conference on Software and Systems Reuse, ICSR2020},
	year = {2020},
	annote = {internationalconference},
	keywords = {kzEvolution},
	month = dec
}

@inproceedings{Brag20a,
	author = {Santiago Bragagnolo and Nicolas Anquetil and St\'ephane Ducasse and
	 Seriai Abderrahmane and Mustapha Derras},
	title = {Analysing Microsoft Access Projects: Building a model in a Partially Observable Domain},
	booktitle = {International Conference on Software and Systems Reuse, ICSR2020},
	year = {2020},
	annote = {internationalconference},
	keywords = {kzEvolution},
	month = dec
}

@inproceedings{Brag20b,
	author = {Santiago Bragagnolo and Beno{\^\i}t Verhaeghe and Abderrahmane Seriai and Mustapha Derras and Anne Etien},
	title = {Challenges for Layout Validation: Lessons Learned},
	booktitle = {International Conference on the Quality of Information and Communications Technology, QUATIC'2020},
	keywords = {kzEvolution},
	annote = {internationalconference},
	year = {2020},
	month = sep
}

@article{Cost20b,
  author = {Steven Costiou and Micka\"{e}l Kerboeuf and Clotilde Toullec and Alain Plantec and St\'ephane Ducasse},
  title = {Object Miners: Acquire, Capture and Replay Objects to Track Elusive Bugs},
  journal = {Journal of Object Technology},
  annote = {internationaljournal},
  volume = {19},
  number = {1},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cost20b-JOT-ObjectMiners.pdf},
  annote = {internationaljournal},
  keywords = {kzTools},
  issn = {1660-1769},
  year = {2020},
  month = jul,
  pages = {1:1-32},
  doi = {10.5381/jot.2020.19.1.a1},
  url = {http://www.jot.fm/contents/issue_2020_01/article1.html}
}

@inproceedings{Larc15a,
author = {Guillaume Larcheveque and Usman Bhatti and Nicolas Anquetil and St\'ephane Ducasse},
title = {Telescope: A High-Level Model to Build Dynamic Visualizations},
hal-id = {hal-02864587},
booktitle={International Workshop on Smalltalk Technologies (IWST'15)},
pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Larc15a-Telescope-IWST.pdf},
keywords = {kzVisualization},
annote = {internationalworkshop},
hal-url = {https://hal.archives-ouvertes.fr/hal-02864587},
year = {2015}
}

@inproceedings{Abde07a,
  author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
  title = {Package References Distribution Fingerprint},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  year = {2007},
  annote = {internationalworkshop},
  keywords = {moose StefPub kzVisualization lse-pub}}

@inproceedings{Abde08b,
  author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
  title = {Package Reference Fingerprint: a Rich and Compact Visualization to Understand Package Relationships},
  booktitle = {Proceeding of the 12th European Conference on Software Maintenance and Reengineering (CSMR'08)},
  pages = {213--222},
  publisher = {IEEE Computer Society Press},
  year = {2008},
  misc = {Acceptance rate: 24/87 = 27\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde08b-CSMR2008-Fingerprint.pdf},
  abstract = {Object-oriented languages such as Java, Smalltalk, and C\+\+ structure their programs using packages, allowing classes to be organized into named abstractions. Maintainers of large applications need to understand how packages are structured and how they relate to each other, but this task is very complex because packages often have multiple clients and different roles (class container, code ownership...). Cohesion and coupling are still among the most used metrics, because they help identify candidate packages for restructuring; however, they do not help maintainers understand the structure and interrelationships between packages. In this paper, we present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable visualization centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system. We applied these views on three large case studies: JBoss, Azureus, and ArgoUML.},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-00200869},
  hal-id = {inria-00200869},
  keywords = {moose cook-pub lse-pub StefPub kzVisualization},
  location = {Athens, Greece},
  rate = {27\%}}

@inproceedings{Abde09b,
  author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui and Ilham Alloui},
  title = {Automatic Package Coupling and Cycle Minimization},
  booktitle = {Proceedings of the 16th International Working Conference on Reverse Engineering (WCRE'09)},
  pages = {103--112},
  publisher = {IEEE Computer Society Press},
  year = {2009},
  misc = {acceptance rate: 20/79 = 25\%},
  doi = {10.1109/WCRE.2009.13},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde09b-WCRE2009-AutomaticPackageCoupling.pdf},
  abstract = {Object-oriented (OO) software is usually organized into subsystems using the concepts of package or module. Such modular structure helps applications to evolve when facing new requirements. However, studies show that as soft- ware evolves to meet requirements and environment changes, modularization quality degrades. To help maintainers improve the quality of software modularization we have designed and implemented a heuristic search-based approach for automatically optimizing inter-package connectivity (i.e., dependencies). In this paper, we present our approach and its underlying techniques and algorithm. We show through a case study how it enables maintainers to optimize OO package structure of source code. Our optimization approach is based on Simulated Annealing technique.},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-00425417},
  hal-id = {inria-00425417},
  keywords = {moose remoose2 lse-pub cook StefPub kzRemodularisation},
  rate = {25\%}}

@phdthesis{Abde09c,
  author = {Hani Abdeen},
  title = {Visualizing, Assessing and Re-Modularizing Object-Oriented Architectural Elements},
  year = {2009},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2009-Abdeen.pdf},
  abstract = {To cope with the complexity of large object-oriented software systems, developers organize classes into subsystems using the concepts of module or package. Such modular structure helps software systems to evolve when facing new requirements. The organization of classes into packages and/or subsystems represents the software modularization. the software modularization usually follows interrelationships between classes. Ideally, packages should to be loosely coupled and cohesive to a certain extent. However, Studies show that as
		software evolves to meet requirements and environment changes, the software modularization gradually drifts
		and looses quality. As a consequence, the software modularization must be maintained. It is thus important to
		understand, to assess and to optimize the organization of packages and their relationships.
		Our claim is that the maintenance of large and complex software modularizations needs approaches that help in:
		(1) understanding package shapes and relationships; (2) assessing the quality of a modularization, as well as
		the quality of a single package within a given modularization; (3) optimizing the quality of an existing
		modularization.
		In this thesis, we concentrate on three research fields: software visualizations, metrics and algorithms. At
		first, we define two visualizations that help maintainers: (1) to understand packages structure, usage and
		relationships; (2) to spot patterns; and (3) to identify misplaced classes and structural anomalies. In
		addition to visualizations, we define a suite of metrics that help in assessing the package design quality
		(i.e., package cohesion and coupling). We also define metrics that assess the quality of a collection of
		inter-dependent packages from different view points, such as the degree of package coupling and cycles.
		Finally, we define a search-based algorithm that automatically reduces package coupling and cycles only by
		moving classes over existing packages. Our optimization approach takes explicitly into account the original
		class organization and package structure. It also allows maintainers to control the optimization process by
		specifying: (1) the maximal number of classes that may change their packages; (2) the classes that are
		candidate for moving and the classes that should not; (3) the packages that are candidate for restructuring
		and the packages that should not; and (4) the maximal number of classes that a given package can entail.
		The approaches presented in this thesis have been applied to real large object-oriented software systems. The
		results we obtained demonstrate the usefulness of our visualizations and metrics; and the effectiveness of our
		optimization algorithm.},
  annote = {PhD},
  hal-id = {tel-00498389},
  institution = {INRIA},
  keywords = {moose remoose2 lse-pub cook kzVisualization}}

@article{Abde10a,
  author = {Hani Abdeen and St\'ephane Ducasse and Damien Pollet and Ilham Alloui},
  title = {Package Fingerprint: a visual summary of package interfaces and relationships},
  journal = {Information and Software Technology Journal},
  volume = {52},
  pages = {1312-1330},
  year = {2010},
  impactfactor = {ISI impact factor (2010) 1.821},
  doi = {10.1016/j.infsof.2010.07.005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde10a-IST-Official-packageFingerprints.pdf},
  abstract = {Context: Object-oriented languages such as Java, Smalltalk, and C\+\+ structure their programs using packages. Maintainers of large systems need to understand how packages relate to each other, but this task is complex because packages often have multiple clients and play different roles (class container, code ownership. . . ). Several approaches have been proposed, among which the use of cohesion and coupling metrics. Such metrics help identify candidate packages for restructuring; however, they do not help maintainers actually understand the structure and interrelation- ships between packages.
Objectives: In this paper, we use pre-attentive processing as the basis for package visualization and see to what extent it could be used in package understanding.
Method: We present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable views centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system.
Results: We applied these views on four large systems: Squeak, JBoss, Azureus, and ArgoUML. We obtained several interesting results, among which, the identification of a set of recurring visual patterns that help maintainers: (a) more easily identify the role of and the way a package is used within the system (e.g., the package under analysis provides a set of layered services), and, (b) detect either problematic situations (e.g., a single package that groups together a large number of basic services) or opportunities for better package restructuring (e.g., removing cyclic dependencies among packages). The visualization generally scaled well and the detection of different patterns was always possible.
Conclusion: The proposed visualizations and patterns proved to be useful in understanding and maintaining the different systems we addressed. To generalize to other contexts and systems, a real user study is required.},
  annote = {internationaljournal},
  hal-id = {inria-00531496},
  hal-url = {http://hal.inria.fr/inria-00531496},
  keywords = {moose remoose2 lse-pub StePub cook kzVisualisation}}

@inproceedings{Abde11a,
  author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui},
  title = {Modularization Metrics: Assessing Package Organization in Legacy Large Object-Oriented Software},
  booktitle = {Proceedings of the 18th IEEE International Working Conference on Reverse Engineering (WCRE'11)},
  publisher = {IEEE Computer Society Press},
  year = {2011},
  misc = {Short paper, acceptance rate: 50/104 = 48\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde11a-WCRE-ModularizationMetrics-INRIA.pdf},
  abstract = {There exist many large object-oriented software systems consisting of several thousands of classes that are organized into several hundreds of packages. In such software systems, classes cannot be considered as units for software modularization. In such context, packages are not simply classes containers, but they also play the role of modules: a package should focus to provide well identified services to the rest of the software system. Therefore, understanding and assessing package organization is primordial for software maintenance tasks. Although there exist a lot of works proposing metrics for the quality of a single class and/or the quality of inter-class relationships, there exist few works dealing with some aspects for the quality of package organization and relationship. We believe that additional investigations are required for assessing package modularity aspects. The goal of this paper is to provide a complementary set of metrics that assess some modularity principles for packages in large legacy object-oriented software: Information-Hiding, Changeability and Reusability principles. Our metrics are defined with respect to object-oriented dependencies that are caused by inheritance and method call. We validate our metrics theoretically through a careful study of the mathematical properties of each metric.},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-00614778/},
  hal-id = {inria-00614778},
  keywords = {moose cutter lse-pub raweb2011 kzMetric StefPub kzRemodularisation},
  rate = {acceptance rate (full + short papers): 50/104 = 48\%},
  hal-pdf = {http://hal.inria.fr/docs/00/61/45/83/PDF/ModularizationMetrics-INRIA.pdf}}

@techreport{Abde11i,
  author = {Abdeen, Hani and Ducasse, St\'ephane and Sahraoui, Houari A.},
  title = {Modularization Metrics: Assessing Package Organization in Legacy Large Object-Oriented Software},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Abde11a-TechReport-ModularizationMetrics-INRIA.pdf},
  abstract = {There exist many large object-oriented software systems consisting of several thousands of classes that are organized into several hundreds of packages. In such software systems, classes cannot be considered as units for software modularization. In such context, packages are not simply classes containers, but they also play the role of modules: a package should focus to provide well identified services to the rest of the software system. Therefore, understanding and assessing package organization is primordial for software maintenance tasks. Although there exist a lot of works proposing metrics for the quality of a single class and/or the quality of inter-class relationships, there exist few works dealing with some aspects for the quality of package organization and relationship. We believe that additional investigations are required for assessing package modularity aspects. The goal of this paper is to provide a complementary set of metrics that assess some modularity principles for packages in large legacy object-oriented software: Information-Hiding, Changeability and Reusability principles. Our metrics are defined with respect to object-oriented inter-package and intra-package dependencies. The dependencies that are caused by different types of inter-class dependencies, such as inheritance and method call. We validate our metrics theoretically through a careful study of the mathematical properties of each metric.},
  annote = {technicalreport},
  hal-id = {inria-00614583},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {Software Metrics Software Modularization Coupling Cohesion Packages Modularity kzMetric kzRemodularisation},
  hal-url = {http://hal.inria.fr/inria-00614583},
  hal-pdf = {http://hal.inria.fr/inria-00614583/PDF/ModularizationMetrics-INRIA.pdf}}

@inproceedings{Abde13a,
  author = {Hani Abdeen and Houari Sahraoui and Osama Shata and Nicolas Anquetil and St\'ephane Ducasse},
  title = {Towards Automatically Improving Package Structure While Respecting Original Design Decisions},
  booktitle = {International Working Conference on Reverse Engineering (WCRE'13)},
  publisher = {IEEE Computer Society Press},
  year = {2013},
  misc = {Acceptance rate: 38/97 = 39\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde13a-ImprovingPackageStructure-WCRE13.pdf},
  abstract = {Recent studies have largely investigated the detection of class design anomalies. They proposed a large set of metrics that help in detecting those anomalies and in predicting the quality of class design. While those studies and the proposed metrics are valuable, they do not address the particularities of Java interfaces. Interfaces define the contracts that spell out how software modules and logic units interact with each other. This paper proposes a list of design anomalies related to Java interfaces. We identify and describe those anomalies via real examples, taken from well-known Java applications. Then we define three metrics help in automatically estimate the interface design quality, regarding the proposed design anomalies. We evaluate our metrics on three large Java applications. The results show that our metrics are realistic and help in qualifying the interface design, and in identifying candidate refactoringRecently, there has been an important progress in applying search-based optimization techniques to the problem of software re-modularization. Yet, a major part of the existing body of work addresses the problem of modularizing software systems from scratch, regardless of the existing packages structure. This paper presents a novel multi-objective optimization approach for improving existing packages structure. The optimization ap- proach aims at increasing the cohesion and reducing the coupling and cyclic connectivity of packages, by modifying as less as pos- sible the existing packages organization. Moreover, maintainers can specify several constraints to guide the optimization process with regard to extra design factors. To this contribution, we use the Non-Dominated Sorting Genetic Algorithm (NSGA-II). We evaluate the optimization approach through an experiment covering four real-world software systems. The results promise the effectiveness of our optimization approach for improving existing packages structure by doing very small modifications.},
  annote = {internationalconference},
  hal-id = {hal-00862063},
  hal-url = {http://hal.inria.fr/inria-00862063},
  keywords = {moose cutter lse-pub kzMetric StefPub kzInterface},
  tagnicolasa = {architecture}}

@article{Abde14a,
  author = {Hani Abdeen and St\'ephane Ducasse and Damien Pollet and Ilham Alloui and Jean-R\'emy Falleri},
  title = {The Package Blueprint: Visually analyzing and quantifying packages dependencies},
  journal = {Science of Computer Programming},
  year = {2014},
  impactfactor = {5-Year ISI impact factor (2010) 4.865},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Abde14a-Official-PackageBlueprint-SCP.pdf},
  annote = {internationaljournal},
  hal-id = {00957695},
  hal-url = {http://hal.inria.fr/inria-00957695},
  keywords = {lse-pub StefPub kzVisualization},
  month = feb}

@inproceedings{Ali17a,
  author = {Alidra, Abdelghani and Saker, Moussa and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {Identifying class name inconsistency in hierarchy: a first simple heuristic},
  booktitle = {International Workshop on Smalltalk Technologies (IWST'17)},
  year = {2017},
  doi = {10.1145/3139903.3139920},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Alid17a-IdentifyingClassNames-IWST17.pdf},
  annote = {internationalworkshop},
  hal-url = {https://hal.archives-ouvertes.fr/hal-01663603},
  hal-id = {hal-01663603},
  keywords = {kzVisualization kzEvolution lse-pub},
  tagnicolasa = {other analysis}}

@article{Alle13a,
  author = {Esteban Allende and Oscar Callau and Johan Fabry and Eric Tanter and Marcus Denker},
  title = {Gradual Typing for Smalltalk},
  journal = {Science of Computer Programming},
  year = {2013},
  doi = {10.1016/j.scico.2013.06.006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Alle13aGradualTyping.pdf},
  abstract = {Being able to combine static and dynamic typing within the same language has clear benefits in order to support the evolution of prototypes or scripts into mature robust programs. While being an emblematic dynamic object-oriented language, Smalltalk is lagging behind in this regard. We report on the design, implementation and application of Gradualtalk, a gradually-typed Smalltalk meant to enable incremental typing of existing programs. The main design goal of the type system is to support the features of the Smalltalk language, like metaclasses and blocks, live programming, and to accomodate the programming idioms used in practice. We studied a number of existing projects in order to determine the features to include in the type system. As a result, Gradualtalk is a practical approach to gradual types in Smalltalk, with a novel blend of type system features that accomodate most programming idioms.},
  annote = {internationaljournal},
  hal-id = {hal-00862815},
  hal-url = {https://hal.archives-ouvertes.fr/hal-00862815},
  keywords = {type systems, gradual typing, smalltalk, lse-pub}}

@inproceedings{Alli12a,
  author = {Simon Allier and Nicolas Anquetil and Andre Hora and St\'ephane Ducasse},
  title = {A Framework to Compare Alert Ranking Algorithms},
  booktitle = {Proceedings of the 19th International Working Conference on Reverse Engineering (WCRE'12)},
  year = {2012},
  misc = {Acceptance rate: 43/138 = 31\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Alli12a-wcre2012-ComparisonOfAlertsRankingAlgorithms.pdf},
  annote = {internationalconference},
  hal-id = {hal-00747817},
  hal-url = {https://hal.archives-ouvertes.fr/hal-00747817},
  keywords = {lse-pub StefPub kzChecking},
  tagnicolasa = {analysis}}

@inproceedings{Anq19a,
  author = {Nicolas Anquetil and Anne Etien and Gaelle Andreo and St\'ephane Ducasse},
  title = {{Decomposing God Classes at Siemens}},
  booktitle = {2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02395836},
  abstract = {A group of developers at Siemens Digital Industry Division approached our team to help them restructure a large legacy system. Several problems were identified, including the presence of God classes (big classes with thousands of lines of code and hundred of methods). They had tried different approaches considering the dependencies between the classes, but none were satisfactory. Through interaction during the last three years with a lead software architect of the project, we designed a software visualization tool and an accompanying process that allows her to propose a decomposition of a God Class in a matter of one or two hours even without prior knowledge of the class (although actually implementing the decomposition in the source code could take a week of work). In this paper, we present the process that was formalized to decompose God Classes and the tool that was designed. We give details on the system itself and some of the classes that were decomposed. The presented process and visualisations have been successfully used for the last three years on a real industrial system at Siemens.},
  address = {Cleveland, OH, USA},
  month = oct,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Industrial case},
  hal-id = {hal-02395836},
  tagnicolasa = {architecture},
  annote = {topconference internationalconference},
  rate = {50\%}}

@inproceedings{Anqu00a,
  author = {Anquetil, Nicolas},
  title = {Concepts + Relations = 'Abstract Constructs'},
  booktitle = {WCRE'00: Proceedings of the Seventh Working Conference on Reverse Engineering (WCRE'00)},
  publisher = {IEEE Computer Society},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu00a-WCRE-Concepts+Relations.pdf},
  address = {Los Alamitos, CA, USA},
  annote = {internationalconference},
  note = {Due to an error of the editor, the paper does not appear in the proceedings},
  tagnicolasa = {analysis}}

@inproceedings{Anqu00b,
  author = {Anquetil, Nicolas},
  title = {A Comparison of Graphs of Concept for Reverse Engineering},
  booktitle = {Proceedings of the 8th International Workshop on Program Comprehension},
  pages = {231--},
  publisher = {IEEE Computer Society},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu00b-ICSM-GraphsConcepts.pdf},
  abstract = {To group related things together (for example to form subsystems); researchers in Reverse Engineering are looking for algorithms that create meaningful groups. One such algorithm, Concept Analysis, received a lot of interest recently. It creates a lattice of concepts, which have some advantages over the more traditional tree of clusters from clustering algorithms.We will argue that the main interest of Concept Analysis lies in the concepts themselves and can be disconnected from the particular structure (the lattice of concepts) in which the concepts are usually arranged. We will compare Concept Analysis to various other algorithms trying to select the most important concepts contained in a set of entities.Our main conclusion is that although it have advantages, the lattice of concepts suffer from a major drawback that other constructs do not have: it returns much more information (concepts) than what it was given in input (a set of entities describing some software system).},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  isbn = {0-7695-0656-9},
  keywords = {Reverse Engineering, Concept Analysis, Clustering},
  series = {IWPC '00},
  tagnicolasa = {architecture}}

@inproceedings{Anqu01a,
  author = {Anquetil, Nicolas},
  title = {Characterizing the Informal Knowledge Contained in Systems},
  booktitle = {WCRE '01: Proceedings of the Eighth Working Conference on Reverse Engineering (WCRE'01)},
  pages = {166--175},
  publisher = {IEEE Computer Society},
  year = {2001},
  misc = {acceptance rate: 27/104 = 26\%},
  doi = {10.1109/WCRE.2001.957821},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu01a-WCRE-InformalKnowledge.pdf},
  abstract = {Program comprehension of legacy systems is a highly knowledge-intensive task. One of the goals of reverse engineering is to propose automated help to relate application domain concepts to all their implementation instances. It is generally accepted that to do so would require analyzing such documentation as identifiers or comments. However, before attempting to perform this difficult analysis, it would be useful to know precisely what information the documentation contains and if it is worth trying. In this paper, we present the results of a study of the knowledge contained in two sources of documentation for the Mosaic system. This knowledge is categorized into various domains, and the relative proportions of these domains are discussed. Among other things, the results highlight the high frequency with which application domain concepts are used, which could provide the means to identify them.},
  acceptnum = {27},
  accepttotal = {104},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  isbn = {0-7695-1303-4},
  tagnicolasa = {knowledge}}

@incollection{Anqu02a,
  author = {Lethbridge, Timothy C. and Anquetil, Nicolas},
  title = {Approaches to clustering for program comprehension and remodularization},
  booktitle = {Advances in software engineering: Comprehension, Evaluation, and Evolution},
  pages = {137--157},
  publisher = {Springer-Verlag New York, Inc.},
  year = {2002},
  url = {http://portal.acm.org/citation.cfm?id=505630.505637},
  address = {New York, NY, USA},
  annote = {articlebook},
  editor = {Hakan Erdogmus, Oryal Tanir},
  isbn = {0-387-95109-1},
  tagnicolasa = {architecture}}

@article{Anqu03a,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  title = {Comparative study of clustering algorithms and abstract representations for software remodularization},
  journal = {IEE Proceedings - Software},
  volume = {150},
  pages = {185-201},
  year = {2003},
  doi = {10.1049/ip-sen:20030581},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu03a-IEESoft-ComparativeStudy.pdf},
  abstract = {As valuable software systems become older, reverse engineering becomes increasingly important to companies that have to maintain the code. Clustering is a key activity in reverse engineering that is used to discover improved designs of systems or to extract significant concepts from code. Clustering is an old, highly sophisticated, activity which offers many methods to meet different needs. The various methods have been well documented in the past; however, conclusions from general clustering literature may not apply entirely to the reverse engineering domain. In the paper, the authors study three decisions that need to be made when clustering: the choice of (i) abstract descriptions of the entities to be clustered, (ii) metrics to compute coupling between the entities, and (iii) clustering algorithms. For each decision, our objective is to understand which choices are best when performing software remodularisation. The experiments were conducted on three public domain systems (gcc, Linux and Mosaic) and a real world legacy system (2 million LOC). Among other things, the authors confirm the importance of a proper description scheme for the entities being clustered, list a few effective coupling metrics and characterise the quality of different clustering algorithms. They also propose description schemes not directly based on the source code, and advocate better formal evaluation methods for the clustering results.},
  annote = {internationaljournal},
  number = {3},
  tagnicolasa = {architecture}}

@inproceedings{Anqu03b,
  author = {Nicolas Anquetil and K{\'a}thia Mar\c{c}al de Oliveira and M{\'a}rcio Greyck Batista Dias and Marcelo Ramal and Ricardo de Moura Meneses},
  title = {Knowledge for Software Maintenance},
  booktitle = {Proceedings of the Fifteenth International Conference on Software Engineering \& Knowledge Engineering (SEKE'2003)},
  pages = {61--68},
  year = {2003},
  misc = {acceptance rate: 71/159 = 45\%},
  abstract = {Knowledge management is emerging as a promising area to support software engineering activities. The general idea is to use knowledge gained in previous projects to help future ones. We believe this approach is even more relevant when considering software maintenance where maintainers often have to modify a system that they did not develop, that has no documentation, and that nobody knows intimately. Contrasting with this lack of information on the system, maintainers need a lot of knowledge: about the application domain, the organization software maintenance procedures, the system itself, the language used, past development methods, etc. Although one can readily agree with the information needs listed above, there is no clear, exhaustive definition of which knowledge would be useful to perform software maintenance. In this paper we describe our research to identify these needs. This research is part of a long term project that aims at building a knowledge management system for software maintenance.},
  acceptnum = {71},
  accepttotal = {159},
  annote = {internationalconference},
  tagnicolasa = {knowledge}}

@incollection{Anqu06a,
  author = {Nicolas Anquetil and K\'athia M. de Oliveira and M\'arcio G. B. Dias},
  title = {Software Maintenance Ontology},
  chapter = {5},
  booktitle = {Ontologies for Software Engineering and Software Technology},
  pages = {153--173},
  publisher = {Springer-Verlag New York, Inc.},
  year = {2006},
  doi = {10.1007/3-540-34518-3\_5},
  annote = {articlebook},
  editor = {Coral Calero, Francisco Ruiz, Mario Piattini},
  isbn = {978-3-540-34517-6},
  tagnicolasa = {knowledge}}

@inproceedings{Anqu06c,
  author = {Alexandre H. Torres and Nicolas Anquetil and K\'athia M. de Oliveira},
  title = {Pro-active dissemination of knowledge with learning histories},
  booktitle = {Proceedings of the Eighth International Workshop on Learning Software Organizations},
  pages = {19--27},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu06c-LSO-ProactiveKnowldge.pdf},
  abstract = {Because they routinely work with intangible goods, software organizations need to be aware of the importance of knowledge. Different knowledge management approaches exist in the literature to help them manage this fundamental asset. However, the current approaches suffer from different problems, like dealing only with explicit knowledge (e.g. in the form of best practices), or focusing on "on demand" knowledge access. In this paper we present a richer, pro-active, knowledge management approach suitable for small or medium organizations. We report on an experiment we conducted with our model.},
  tagnicolasa = {knowledge}}

@article{Anqu07a,
  author = {Anquetil, Nicolas and de Oliveira, K\'{a}thia M. and de Sousa, Kleiber D. and Batista Dias, M\'{a}rcio G.},
  title = {Software maintenance seen as a knowledge management issue},
  journal = {Information Software Technology},
  volume = {49},
  pages = {515--529},
  publisher = {Butterworth-Heinemann},
  year = {2007},
  impactfactor = {Impact Factor (2008) 1.200},
  doi = {10.1016/j.infsof.2006.07.007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu07a-IST-MaintenanceKnowledge.pdf},
  abstract = {Creating and maintaining software systems is a knowledge intensive task. One needs to have a good understanding of the application domain, the problem to solve and all its requirements, the software process used, technical details of the programming language(s), the system's architecture and how the different parts fit together, how the system interacts with its environment, etc. All this knowledge is difficult and costly to gather. It is also difficult to store and usually lives only in the mind of the software engineers who worked on a particular project. If this is a problem for development of new software, it is even more for maintenance, when one must rediscover lost information of an abstract nature from legacy source code among a swarm of unrelated details. In this paper, we submit that this lack of knowledge is one of the prominent problems in software maintenance. To try to solve this problem, we adapted a knowledge extraction technique to the knowledge needs specific to software maintenance. We explain how we explicit the knowledge discovered on a legacy software during maintenance so that it may be recorded for future use. Some applications on industry maintenance projects are reported.},
  address = {Newton, MA, USA},
  annote = {internationaljournal},
  issn = {0950-5849},
  number = {5},
  tagnicolasa = {knowledge}}

@inproceedings{Anqu08a,
  author = {N. {Anquetil} and B. {Grammel} and I. {Galvao Lourenco da Silva} and J.A.R. {Noppen} and S. {Shakil Khan} and H. {Arboleda} and A. {Rashid} and A. {Garcia}},
  title = {Traceability for Model Driven, Software Product Line Engineering},
  booktitle = {ECMDA Traceability Workshop Proceedings},
  pages = {77--86},
  publisher = {SINTEF ICT},
  year = {2008},
  url = {http://doc.utwente.nl/64994/},
  abstract = {Traceability is an important challenge for software organizations. This is true for traditional software development and even more so in new approaches that introduce more variety of artefacts such as Model Driven development or Software Product Lines. In this paper we look at some aspect of the interaction of Traceability, Model Driven development and Software Product Line.},
  address = {Norway},
  annote = {internationalworkshop},
  month = {jun},
  tagnicolasa = {other traceability SPL}}

@article{Anqu08b,
  author = {Anquetil, Nicolas and Noppen, Joost and Galv{\~a}o, Ism{\^e}nia},
  title = {La tra{\c{c}}abilit{\'e} dans les lignes de produits logiciels},
  journal = {L'Objet},
  volume = {14},
  pages = {47--57},
  publisher = {Lavoisier},
  year = {2008},
  annote = {nationaljournal},
  number = {3},
  tagnicolasa = {other traceability SPL}}

@article{Anqu08c,
  author = {Anquetil, Nicolas and Arboleda, Hugo and DE ALEXANDRIA FERNANDES, Fabricio and Nunez, Angel and Royer, Jean-Claude},
  title = {Lignes de produits logiciels et usines logicielles},
  journal = {L'Objet},
  volume = {14},
  pages = {15--31},
  publisher = {Lavoisier},
  year = {2008},
  annote = {nationaljournal},
  number = {3},
  tagnicolasa = {other traceability SPL}}

@inproceedings{Anqu09a,
  author = {Anquetil, Nicolas and Lethbridge, Timothy C},
  title = {Ten years later, experiments with clustering as a software remodularization method},
  booktitle = {Reverse Engineering, 2009. WCRE'09. 16th Working Conference on},
  pages = {7--7},
  year = {2009},
  annote = {invited},
  organization = {IEEE},
  tagnicolasa = {architecture}}

@inproceedings{Anqu09b,
  author = {Anquetil, Nicolas and Royer, J-C and Andre, Pascal and Ardourel, Gilles and Hnetynka, Petr and Poch, Tomas and Petrascu, Dragos and Petrascu, Vladiela},
  title = {Javacompext: Extracting architectural elements from java source code},
  booktitle = {Reverse Engineering, 2009. WCRE'09. 16th Working Conference on},
  pages = {317--318},
  year = {2009},
  annote = {internationalconference},
  hal-id = {hal-00457219},
  organization = {IEEE},
  tagnicolasa = {architecture}}

@article{Anqu10a,
  author = {Anquetil, Nicolas and Kulesza, Uir\'{a} and Mitschke, Ralf and Moreira, Ana and Royer, Jean-Claude and Rummler, Andreas and Sousa, Andr\'{e}},
  title = {A model-driven traceability framework for software product lines},
  journal = {Journal of Software and Systems Modeling (SOSYM)},
  volume = {9},
  pages = {427--451},
  publisher = {Springer-Verlag New York, Inc.},
  year = {2010},
  impactfactor = {Impact Factor (2011) 1.061},
  doi = {10.1007/s10270-009-0120-9},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu10a-SOSYM-TraceabilitySPL.pdf},
  abstract = {Software product line (SPL) engineering is a recent approach to software development where a set of software products are derived for a well defined target application domain, from a common set of core assets using analogous means of production (for instance, through Model Driven Engineering). Therefore, such family of products are built from reuse, instead of developed individually from scratch. SPL promise to lower the costs of development, increase the quality of software, give clients more flexibility and reduce time to market. These benefits come with a set of new problems and turn some older problems possibly more complex. One of these problems is traceability management. In the European AMPLE project we are creating a common traceability framework across the various activities of the SPL development. We identified four orthogonal traceability dimensions in SPL development, one of which is an extension of what is often considered as "traceability of variability". This constitutes one of the two contributions of this paper. The second contribution is the specification of a metamodel for a repository of traceability links in the context of SPL and the implementation of a respective traceability framework. This framework enables fundamental traceability management operations, such as trace import and export, modification, query and visualization. The power of our framework is highlighted with an example scenario.},
  address = {Secaucus, NJ, USA},
  annote = {internationaljournal},
  hal-id = {hal-00668175},
  hal-url = {https://hal.archives-ouvertes.fr/hal-00668175},
  issn = {1619-1366},
  number = {4},
  tagnicolasa = {other traceability SPL}}

@inproceedings{Anqu11a,
  author = {Nicolas Anquetil and Jannik Laval},
  title = {Legacy Software Restructuring: Analyzing a Concrete Case},
  booktitle = {Proceedings of the 15th European Conference on Software Maintenance and Reengineering (CSMR'11)},
  pages = {279--286},
  year = {2011},
  misc = {acceptance rate: 29/101 = 29\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu11a-CSMR2011-Coupling.pdf},
  abstract = {Software re-modularization is an old preoccupation of reverse engineering research. The advantages of a well structured or modularized system are well known. Yet after so much time and efforts, the field seems unable to come up with solutions that make a clear difference in practice. Recently, some researchers started to question whether some basic assumptions of the field were not overrated. The main one consists in evaluating the high-cohesion/low-coupling dogma with metrics of unknown relevance. In this paper, we study a real structuring case (on the Eclipse platform) to try to better understand if (some) existing metrics would have helped the software engineers in the task. Results show that the cohesion and coupling metrics used in the experiment did not behave as expected and would probably not have helped the maintainers reach there goal.
We also measured another possible restructuring which is to decrease the number of cyclic dependencies between modules.
Again, the results did not meet expectations.},
  acceptnum = {29},
  accepttotal = {101},
  address = {Oldenburg, Germany},
  annote = {internationalconference},
  hal-id = {hal-00745773},
  hal-url = {https://hal.archives-ouvertes.fr/hal-00745773},
  keywords = {moose lse-pub cutter raweb2011 pharo kzRemodularisation kzEvolution},
  tagnicolasa = {architecture metric}}

@incollection{Anqu11b,
  author = {Nicolas Anquetil and Uir\'a Kulesza and Ricardo Mateus and Ralf Mitschke and Ana Moreira and Jean-Claude Royer and Andreas Rummler},
  title = {Managing information flow in the {SPL} development processes},
  chapter = {8},
  booktitle = {Aspect-Oriented, Model-Driven Software Product Lines -- The AMPLE way},
  pages = {222--262},
  publisher = {Cambridge University Press},
  year = {2011},
  doi = {10.1017/CBO9781139003629.008},
  annote = {articlebook},
  editor = {Awais Rashid and Jean-Claude Royer and Andreas Rummler},
  isbn = {978-0-521-76722-4},
  keywords = {ample lse-pub raweb2011},
  tagnicolasa = {other SPL traceability}}

@incollection{Anqu11c,
  author = {Phil Greenwood and Vander Alves and John Hutchinson and Christa Schwanninger and Nicolas Anquetil},
  title = {Empirical research in software product line engineering},
  chapter = {14},
  booktitle = {Aspect-Oriented, Model-Driven Software Product Lines -- The AMPLE way},
  pages = {411--443},
  publisher = {Cambridge University Press},
  year = {2011},
  doi = {10.1017/CBO9781139003629.014},
  annote = {articlebook},
  editor = {Awais Rashid and Jean-Claude Royer and Andreas Rummler},
  isbn = {978-0-521-76722-4},
  keywords = {ample lse-pub raweb2011},
  tagnicolasa = {other SPL}}

@techreport{Anqu12x,
  author = {Nicolas Anquetil and Damien Cassou and Marcus Denker and St\'ephane Ducasse and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2012 Activity Report},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Anqu12x-RAWEB-RMOD-2012-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-00777904},
  hal-url = {https://hal.archives-ouvertes.fr/hal-00777904},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@techreport{Anqu13a,
  author = {Nicolas Anquetil and Andr\'e Hora},
  title = {Assessing the Quality of Architectural Design Quality Metrics},
  year = {2013},
  url = {https://hal.inria.fr/hal-01664311},
  hal-url = {https://hal.inria.fr/hal-01664311},
  institution = {Inria Lille Nord Europe},
  hal-id = {hal-01664311},
  tagnicolasa = {architecture metric}}

@article{Anqu14a,
  author = {Nicolas Anquetil and St\'ephane Ducasse and Muhammad U. Bhatti},
  title = {Dedicated Software Analysis Tools},
  journal = {ERCIM News},
  volume = {99},
  pages = {22--23},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Anqu14a-Ercim-EN99-web.pdf},
  annote = {vulgarisation},
  keywords = {moose lse-pub raweb2014 StePub kzIDE kzTools},
  month = oct,
  tagnicolasa = {other analysis},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Anqu14a-Ercim-EN99-web.pdf}}

@techreport{Anqu14b,
  author = {Nicolas Anquetil},
  title = {HDR - Supporting Software Evolution in the Organizations},
  year = {2014},
  institution = {Universit{\'e} des Sciences et Technologie de Lille - Lille I},
  hal-id = {tel-01086785},
  tagnicolasa = {other},
  month = {may},
  annote = {habilitation}}

@techreport{Anqu14c,
  author = {Nicolas Anquetil and Yuriy Tymchuk and Anne Etien and Gustavo Santos and St\'ephane Ducasse},
  title = {A Generic Platform for Name Resolution in Source Code Analysis},
  year = {2014},
  url = {https://hal.inria.fr/hal-01664258},
  hal-url = {https://hal.inria.fr/hal-01664258},
  institution = {Inria Lille Nord Europe},
  hal-id = {hal-01664258},
  tagnicolasa = {other model}}

@techreport{Anqu17a,
  author = {Nicolas Anquetil and Marcus Denker and St\'ephane Ducasse and Anne Etien and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2016 Activity Report},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Anqu17a-RAWEB-RMOD-2016-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-01444225},
  hal-url = {https://hal.inria.fr/hal-01444225},
  inriareport = {2016},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@inproceedings{Anqu17b,
  author = {Nicolas Anquetil and Muhammad Bhatti and St\'ephane Ducasse and Andr\'e Hora and Jannik Laval},
  title = {The Case for Non-Cohesive Packages},
  booktitle = {SQAMIA 2017 - 6th workshop on Software Quality Analysis, Monitoring, Improvement, and Applications},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01585703},
  abstract = {While the lack of cohesiveness of modules in procedural languages is a good way to identify modules with potential quality problems, we doubt that it is an adequate measure for packages in object-oriented systems. Indeed, mapping procedural metrics to object-oriented systems should take into account the building principles of object-oriented programming: inheritance and late binding. Inheritance offers the possibility to create packages by just extending classes with the necessary increment of behavior. Late binding coupled to the " Hollywood Principle " are a key to build frameworks and let the users branch their extensions in the framework. Therefore, a package extending a framework does not have to be cohesive, since it inherits the framework logic, which is encapsulated in framework packages. In such a case, the correct modularization of an extender application may imply low cohesion for some of the packages. In this paper we confirm these conjectures on various real systems (JHotdraw, Eclipse, JEdit, JFace) using or extending OO frameworks. We carry out a dependency analysis of packages to measure their relation with their framework. The results show that framework dependencies form a considerable portion of the overall package dependencies. This means that non-cohesive packages should not be considered systematically as packages of low quality.},
  annote = {internationalworkshop},
  hal-id = {hal-01585703},
  tagnicolasa = {architecture},
  url-conference = {http://ceur-ws.org/Vol-1938/paper-anq.pdf},
  hal-url = {https://hal.inria.fr/hal-01585703},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu17b-Sqamia-Metrics.pdf},
  month = {sep},
  keywords = {lse-pub kzMetric kzEvolution},
  address = {Belgrade, Serbia}}

@inproceedings{Anqu97a,
  author = {Anquetil, Nicolas and Lethbridge, Timothy C.},
  title = {File clustering using naming conventions for legacy systems},
  booktitle = {Proceedings of the 1997 conference of the Centre for Advanced Studies on Collaborative research},
  pages = {184--195},
  publisher = {IBM Press},
  year = {1997},
  url = {http://portal.acm.org/citation.cfm?id=782010.782012},
  abstract = {Decomposing complex software systems into conceptually independent subsystems represents a significant software engineering activity that receives considerable research attention. Most of the research in this domain deals with the source code; trying to cluster together files which are conceptually related. In this paper we propose using a more informal source of information: file names. We present an experiment which shows that file naming convention is the best file clustering criteria for the software system we are studying.Based on the experiment results, we also sketch a method to build a conceptual browser on a software system.},
  annote = {internationalconference},
  keywords = {clustering},
  location = {Toronto, Ontario, Canada},
  month = nov,
  series = {CASCON'97},
  tagnicolasa = {architecture}}

@inproceedings{Anqu98a,
  author = {Nicolas Anquetil and Timothy C. Lethbridge},
  title = {Assessing the relevance of identifier names in a legacy software system},
  booktitle = {Proceedings of the 1998 conference of the Centre for Advanced Studies on Collaborative research},
  pages = {213--222},
  publisher = {IBM Press},
  year = {1998},
  url = {http://portal.acm.org/citation.cfm?id=783160.783164},
  abstract = {Reverse engineering is a difficult task even for humans. When trying to provide tools to assist in this task, one should try to take advantage of all possible sources of information.Informal sources, like naming conventions, are more abstract than the code, thus helping to bridge the gap between code and design. On the other hand, there is no certainty that they actually represent the current state of the system.Some researchers have used these informal sources of information, relying on an assumption that if types (or variables, or functions) have the same name then they represent the same thing.However none of these researchers have actually tried to establish to what extent this assumption is valid. This paper provides a framework to study this issue. We will define what it means to have a "reliable naming convention", how this can be tested and under what conditions. We present examples from the particular legacy software system we are studying as well as from the literature.},
  annote = {internationalconference},
  location = {Toronto, Ontario, Canada},
  series = {CASCON'98},
  tagnicolasa = {knowledge}}

@inproceedings{Anqu98b,
  author = {Nicolas Anquetil and Timothy C. Lethbridge},
  title = {Extracting Concepts from File Names: a New File Clustering Criterion},
  booktitle = {Proceedings of the 20th international conference on Software engineering},
  pages = {84--93},
  publisher = {IEEE Computer Society},
  year = {1998},
  url = {http://portal.acm.org/citation.cfm?id=302163.302172},
  abstract = {Decomposing complex software systems into conceptually independent subsystems is a significant software engineering activity which received considerable research attention. Most of the research in this domain considers the body of the source code; trying to cluster together files which are conceptually related. This paper discusses techniques for extracting concepts (we call them ``abbreviations'') from a more informal source of information: file names. The task is difficult because nothing indicates where to split the file names into substrings. In general, finding abbreviations would require domain knowledge to identify the concepts that are referred to in a name and intuition to recognize such concepts in abbreviated forms. We show by experiment that the techniques we propose allow about 90\% of the abbreviations to be found automatically.},
  address = {Washington, DC, USA},
  annote = {internationalconference},
  isbn = {0-8186-8368-6},
  location = {Kyoto, Japan},
  series = {ICSE'98},
  tagnicolasa = {architecture}}

@article{Anqu98c,
  author = {Anquetil, Nicolas and Vaucher, Jean},
  title = {Expressing opposition in the object model, first step towards negation},
  journal = {SIGPLAN Notices},
  volume = {33},
  pages = {48--55},
  publisher = {ACM},
  year = {1998},
  doi = {10.1145/609742.609749},
  abstract = {Although seemingly simple and intuitive, the object model still contains ambiguous notions. For example, inheritance has been proved to convey two different meanings depending on whether it is behavior or implementation that is inherited. Another conceptually simple notion, multiple inheritance, has not yet been clearly formalized. In this paper, we start by looking at relationships between sibling classes (two immediate subclasses of a common parent). Siblings can be combined through multiple inheritance, or on the contrary, they can be mutually exclusive. We call the relation between incompatible siblings "opposition", and show how it could help in formalizing object models. We then consider widening the explicit use of negation in object models. We argue that negative assertions could be used to validate the creation of new classes to ensure they are compatible with the intended uses of existing classes. Negation leads us to consider the implicit assumption behind object models, we propose to shift from the closed world assumption to the open world assumption.},
  address = {New York, NY, USA},
  aeres = {ASCL},
  annote = {internationaljournal},
  issn = {0362-1340},
  issue = {1},
  keywords = {multiple inheritance, negation, object model, reflection, theoretical foundations},
  tagnicolasa = {other model},
  month = {jan}}

@inproceedings{Anqu99a,
  author = {Nicolas Anquetil and Timothy Lethbridge},
  title = {Experiments with {Clustering} as a {Software} {Remodularization} {Method}},
  booktitle = {Proceedings of Working Conference on Reverse Engineering (WCRE'99)},
  pages = {235--255},
  year = {1999},
  doi = {10.1109/WCRE.1999.806964},
  abstract = {As valuable software systems get old, reverse engineering becomes more and more important to the companies that have to maintain the code. Clustering is a key activity in reverse engineering to discover a better design of the systems or to extract significant concepts from the code. Clustering is an old activity, highly sophisticated, offering many methods to answer different needs. Although these methods have been well documented in the past, these discussions may not apply entirely to the reverse engineering domain. We study some clustering algorithms and other parameters to establish whether and why they could be used for software remodularization. We study three aspects of the clustering activity: abstract descriptions chosen for the entities to cluster; metrics computing coupling between the entities; and clustering algorithms. The experiments were conducted on three public domain systems (gcc, Linux and Mosaic) and a real world legacy system (2 million LOC). Among other things, we confirm the importance of a proper description scheme of the entities being clustered, we list a few good coupling metrics to use and characterize the quality of different clustering algorithms. We also propose novel description schemes not directly based on the source code and we advocate better formal evaluation methods for the clustering results},
  annote = {internationalconference},
  isbn = {0-7695-0303-9},
  keywords = {clustering},
  tagnicolasa = {architecture}}

@article{Anqu99b,
  author = {Nicolas Anquetil and Timothy C. Lethbridge},
  title = {Recovering Software Architecture from the Names of Source Files},
  journal = {Journal of Software Maintenance: Research and Practice},
  volume = {11},
  pages = {201--21},
  year = {1999},
  misc = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/(SICI)1096-908X(199905/06)11:3<201::AID-SMR192>3.0.CO;2-1},
  abstract = {We discuss how to extract a useful set of subsystems from a set of existing source-code file names. This problem is challenging because many legacy systems use thousands of files names, including some that are very short and cryptic. At the same time the problem is important because software maintainers often find it difficult to understand such systems. We propose a general algorithm to cluster files based on their names, and a set of alternative methods for implementing the algorithm. One of the key tasks is picking candidate words to try to identify in file names. We do this by (a) iteratively decomposing file names, (b) finding common substrings, and (c) choosing words in routine names, in an English dictionary or in source-code comments. In addition, we investigate generating abbreviations from the candidate words in order to find matches in file names, as well as how to split file names into components given no word markers. To compare and evaluate our five approaches, we present two experiments. The first compares the "concepts" found in each file name by each method with the results of manually decomposing file names. The second experiment compares automatically generated subsystems with subsystem examples proposed by experts. We conclude that two methods are most effective: extracting concepts using common substrings and extracting those concepts that relate to the names of routines in the files.},
  annote = {internationaljournal},
  tagnicolasa = {architecture}}

@article{Aran14a,
  author = {Aranega, Vincent and Mottu, Jean-Marie and Etien, Anne and Degueule, Thomas and Baudry, Benoit and Dekeyser, Jean-Luc},
  title = {Towards an automation of the mutation analysis dedicated to model transformation},
  journal = {Software Testing, Verification and Reliability},
  year = {2014},
  url = {http://dx.doi.org/10.1002/stvr.1532},
  doi = {10.1002/stvr.1532},
  issn = {1099-1689},
  hal-id = {hal-00988164},
  annote = {internationaljournal},
  keywords = {MDE, model transformation, mutation analysis, traceability, mutation operator}}

@booklet{Ardi95b,
  author = {Laurent Arditi and St\'ephane Ducasse},
  title = {Une premi\`ere approche fonctionnelle et r\'ecursive de la programmation},
  year = {1995},
  annote = {lectures},
  keywords = {stefPub kzTeaching},
  note = {support de cours de Deug SM-PE et Mass, 120 pages}}

@book{Ardi96a,
  author = {Laurent Arditi and St\'ephane Ducasse},
  title = {La programmation: une approche fonctionelle et r\'ecursive avec Scheme},
  pages = {238},
  publisher = {Eyrolles},
  year = {1996},
  address = {Paris},
  annote = {book},
  isbn = {2-212-08915-5},
  keywords = {stefPub scglib kzBook kzTeaching},
  month = apr,
  note = {Pr\'eface de G\'erard Huet}}

@inproceedings{Ardi97a,
  author = {Laurent Arditi and St\'ephane Ducasse},
  title = {Scheme: un langage applicatif pour l'enseignement de l'informatique en milieu aride},
  booktitle = {Actes des Journ\'ees Fran\c{c}aises des Langages Applicatifs (JFLA '97)},
  pages = {209--228},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Ardi97a-JFLA07-SchemeTeaching.pdf},
  abstract = {Dans cet article, nous pr\'esentons une exp\'erience d'enseignement de l'informatique en milieu aride: volume horaire faible, faible coefficient, \'etudiants peu motiv\'es. Dans ce contexte d\'efavorable, nous avons choisi de privil\`egier un concept, la r\'ecursivit\'e dans le cadre de la programmation fonctionnelle, plut\^ot qu'un langage.	Ce choix nous a conduit \`a consid\`erer le langage Scheme pour sa simplicit\'e. Nous d\'ecrivons ici notre cours, les probl\`emes que nous avons rencontr\'es et les solutions que nous avons choisies.},
  annote = {nationalconference},
  hal-id = {inria-00533051},
  keywords = {stefPub kzTeaching}}

@inproceedings{Arev03c,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {{X-Ray} Views: Understanding the Internals of Classes},
  booktitle = {Proceedings of 18th Conference on Automated Software Engineering (ASE'03)},
  pages = {267--270},
  publisher = {IEEE Computer Society},
  year = {2003},
  doi = {10.1109/ASE.2003.1240318},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03c-ASE03-XRayViews.pdf},
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views -- a technique based on Concept Analysis --	which reveal the internal relationships between groups of methods and attributes of a class. XRay views are com- posed out of elementary collaborations between attributes and methods, and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it on the Smalltalk class UIBuilder.},
  annote = {internationalconference},
  hal-id = {inria-00533054},
  keywords = {recast03 scg-pub stefPub moose arevalo jb04 kzRemodularisation},
  month = oct,
  note = {Short paper},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03cASE03XRayViews.pdf}}

@inproceedings{Arev03d,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Understanding Classes using {X-Ray} Views},
  booktitle = {Proceedings of 2nd International Workshop on MASPEGHI 2003 (ASE'03)},
  pages = {9--18},
  publisher = {CRIM --- University of Montreal (Canada)},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03d-MASPEGHI03-XRayViews.pdf},
  abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views --a technique based on Concept Analysis-- which reveal the internal relationships between groups of methods and attributes of a class. XRay views are composed out of elementary collaborations between attributes and methods and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it to three Smalltalk classes: OrderedCollection, Scanner, and UIBuilder.},
  annote = {internationalworkshop},
  keywords = {snf04 scg-pub skip-doi tefPub arevalo jb04 moose kzRemodularisation},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev03dMASPEGHI03XRayViews.pdf}}

@inproceedings{Arev05b,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Discovering Unanticipated Dependency Schemas in Class Hierarchies},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
  pages = {62--71},
  publisher = {IEEE Computer Society},
  year = {2005},
  impactfactor = {hors},
  misc = {acceptance rate: 33/81 = 41\%},
  doi = {10.1109/CSMR.2005.24},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev05b-CSMR05-ClassHierarchies.pdf},
  abstract = {Object-oriented applications are difficult to extend and maintain, due to the presence of implicit dependencies in the inheritance hierarchy. Although these dependencies of- ten correspond to well-known schemas, such as hook and template methods, new unanticipated dependency schemas occur in practice, and can consequently be hard to recognize and detect. To tackle this problem, we have applied Concept Analysis to automatically detect recurring dependency schemas in class hierarchies used in object-oriented applications. In this paper we describe our mapping of OO dependencies to the formal framework of Concept Analysis, we apply our approach to a non-trivial case study, and we report on the kinds of dependencies that are uncovered with this technique. As a result, we show how the discovered dependency schemas correspond not only to good design practices, but also to "bad smells" in design.},
  acceptnum = {33},
  accepttotal = {81},
  annote = {internationalconference},
  hal-id = {inria-00533057},
  keywords = {scg-pub arevalo jb05 recast05 StefPub moose kzRemodularisation},
  location = {Manchester, United Kingdom},
  month = mar,
  rate = {41\%},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev05bCSMR05ClassHierarchies.pdf}}

@inproceedings{Arev05c,
  author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Lessons Learned in Applying Formal Concept Analysis},
  booktitle = {Proceedings of 3rd International Conference on Formal Concept Analysis (ICFCA'05)},
  volume = {3403},
  pages = {95--112},
  publisher = {Springer Verlag},
  year = {2005},
  impactfactor = {hors},
  doi = {10.1007/b105806},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev05c-ICFCA05-LessonsLearned.pdf},
  abstract = {A key difficulty in the maintenance and evolution of complex software systems is to recognize and understand the implicit dependencies that define contracts that must be respected by changes to the software. Formal Concept Analysis is a well-established technique for identifying groups of elements with common sets of properties. We have successfully applied FCA to complex software systems in order to automatically discover a variety of different kinds of implicit, recurring sets of dependencies amongst design artifacts. In this paper we describe our approach, outline three case studies, and draw various lessons from our experiences. In particular, we discuss how our approach is applied iteratively in order to draw the maximum benefit offered by FCA.},
  annote = {internationalconference},
  hal-id = {inria-00533445},
  hal-url = {http://hal.inria.fr/inria-00533445},
  keywords = {scg-pub jb05 recast05 arevalo StefPub kzRemodularisation},
  location = {Lens, France},
  month = feb,
  series = {LNAI (Lecture Notes in Artificial Intelligence)}}

@article{Arev10a,
  author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Silvia Gordillo and Oscar Nierstrasz},
  title = {Generating a catalog of unanticipated schemas in class hierarchies using Formal Concept Analysis},
  journal = {Journal of Information and Software Technology},
  volume = {52},
  pages = {1167-1187},
  year = {2010},
  impactfactor = {ISI impact factor (2010) 1.821},
  doi = {10.1016/j.infsof.2010.05.010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev10a-IST-generatingCatalog.pdf},
  annote = {internationaljournal},
  hal-id = {inria-00531498},
  hal-url = {http://hal.inria.fr/inria-00531498},
  inriareport = {2010},
  issn = {0950-5849},
  keywords = {moose lse-pub cook StefPub treport2010 kzRemodularisation},
  month = dec,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arev10a-IST-Official-generatingCatalog.pdf}}

@inproceedings{Arlo16a,
  author = {Thibault Arloing and Yann Dubois and Damien Cassou and St\'ephane Ducasse},
  title = {Pillar: A Versatile and Extensible Lightweight Markup Language},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  doi = {10.1145/2991041.2991066},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arlo16a-IWST16-Pillar.pdf},
  address = {Prague, Czech Republic},
  hal-id = {hal-01353882},
  hal-url = {http://hal.inria.fr/hal-01353882},
  keywords = {moose lse-pub kzOther},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Arna10a,
  author = {Jean-Baptiste Arnaud and Marcus Denker and St\'ephane Ducasse and Damien Pollet and Alexandre Bergel and Mathieu Suen},
  title = {Read-Only Execution for Dynamic Languages},
  booktitle = {Proceedings of the 48th International Conference Objects, Models, Components, Patterns (TOOLS'10)},
  year = {2010},
  misc = {25\%},
  doi = {10.1007/978-3-642-13953-6\_7},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arna10a-Tools2010-ReadOnlyExecutionForDynamicLanguages.pdf},
  abstract = {Supporting read-only and side effect free execution has been the focus of a large body of work in the area of statically typed programming languages. Read-onlyness in dynamically typed languages is difficult to achieve because of the absence of a type checking phase and the support of an open-world assumption in which code can be constantly added and modified. To address this issue, we propose Dynamic Read-Only references (DRO) that provide a view on an object where this object and its object graph are protected from modification. The read- only view dynamically propagates to aggregated objects, without changing the object graph itself; it acts as a read-only view of complex data structures, without making them read-only globally. We implement dynamic read-only references by using smart object proxies that lazily propagate the read-only view, following the object graph and driven by control flow and applied them to realize side-effect free assertions.},
  address = {Malaga, Spain},
  annote = {internationalconference},
  hal-url = {http://hal.archives-ouvertes.fr/inria-00498377/fr/},
  hal-id = {inria-00498377},
  inriareport = {2010},
  keywords = {tools10 lse-pub marcusdenker pharo kzLanguageDesign StefPub},
  month = jun,
  rate = {25\%}}

@phdthesis{Arna13a,
  author = {Jean-Baptiste Arnaud},
  title = {Towards First Class References as a Security Infrastructure in Dynamically-Typed Languages},
  year = {2013},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2013-Arnaud.pdf},
  abstract = {Dynamically-typed object-oriented programming languages do not provide type information until runtime. Two of their main advantages are that they allow fast prototyping and integrating changes at runtime. The ability of dynamically-typed languages to support program changes at runtime and the lack of type information doom the classic security approaches to failure. Controlling references to single objects and to graphs of objects is essential to build secure systems. Existing approaches are commonly based on static type system and cannot be applied to dynamically-typed languages.This thesis argue that: In the context of dynamically-typed languages, reifying references, controlling behavior, and isolating state via such references, is a practical way to control references. This thesis makes five contributions: - We propose dynamic read-only objects (DRO) as one kind of adaptation of behavioral change at reference-level. - We generalize the DRO model to enable more generic behavioral changes. We extend the Pharo programming environment and language with Handles, that are first-class references with the ability to change the behavior of referenced objects. - We define Metahandle to offer flexibility and adaptability to controlled references. - We propose SHandle, an extension of the Handle model to isolate side effects at the level of references. - And finally, we formalize the Handles and SHandle models to represent and explain their semantics. As validation of our thesis we have implemented three approaches	relevant to securing system using our model. In addition, as proof of concept we extended the Pharo virtual machine to support Handles, Metahandles and SHandles.},
  hal-id = {tel-00808419},
  inriareport = {2013},
  institution = {INRIA},
  keywords = {security, dynamically-typed languages, reflection, language design, first class reference, object-oriented programming},
  type_rapport = {PhD}}

@article{Arna14a,
  author = {Jean-Baptiste Arnaud and St\'ephane Ducasse and Marcus Denker and Camille Teruel},
  title = {Handles: Behavior-Propagating First Class References For Dynamically-Typed Languages},
  journal = {Journal of Science of Computer Programming},
  volume = {98},
  pages = {318-338},
  year = {2015},
  impactfactor = {(Core A), 5-year impact factor (2012) 0.903},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Arna14a-SCICO-Handles.pdf},
  abstract = {Controlling object graphs and giving specific semantics to references (such as read-only, owner- ship, scoped sharing) has been the focus of a large body of research in the context of static type systems. Controlling references to single objects and to graphs of objects is essential to build more secure systems, but is notoriously hard to achieve in absence of static type systems. In this article we embrace this challenge by proposing a solution to the following question: What is an underlying mechanism that can support the definition of properties (such as revocable, read-only, lent) at the reference level in the absence of a static type system? We present handles: first-class references that propagate behavioral change dynamically to the object subgraph during program execution. In this article we describe handles and show how handles support the implementa- tion of read-only references and revocable references. Handles have been fully implemented by modifying an existing virtual machine and we report their costs.},
  annote = {internationaljournal},
  hal-url = {http://hal.inria.fr/hal-01060537},
  hal-id = {hal-01060537},
  issue = {3},
  keywords = {stefPub lse-pub raweb2014 pharo pharo-pub kzLanguageDesign}}


@inproceedings{Auth12a,
  author = {Authosserre-Cavarero, Annie and Bertrand, Frederic and Blay-Fornarino, Mireille and Collet, Philippe and Dubois, Hubert and Ducasse, St\'ephane and Dupuy-Chessa, Sophie and Faron-Zucker, Catherine and Faucher, Cyril and Lafaye, Jean-Yves and Lahire, Philippe and Le Goaer, Olivier and Montagnat, Johan and Pinna-Dery, Anne-Marie},
  title = {Interop\'erabilit\'e des syst\`emes d'information : approches dirig\'ees par les mod\`eles},
  booktitle = {INFORSID},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Auth12a-interop-si-2012.pdf},
  abstract = {Information systems are more and more often based on aggregation of other systems that must be maintained and evolved in an agile way and with no entropy creation. This is not without interoperability problems! Among others, the aim of Model-Driven Engineering (MDE) is to provide solutions for interoperability issues between systems. This paper summarizes thoughts that have come up from the specific action Interoperability of information systems and model-driven engineering: What challenges? What solutions? supported by inforsid. We propose a summary of approaches that are based on MDE and knowledge engineering and that tackle interoperability issues in the industry. Open questions and limitations that raised during the meetings are also reported.},
  annote = {nationalconference},
  hal-id = {hal-00707536},
  hal-url = {http://hal.inria.fr/hal-00707536},
  keywords = {moose lse-pub kzEvolution}}

@article{Auth13a,
  author = {Authosserre-Cavarero, Annie and Bertrand, Frederic and Blay-Fornarino, Mireille and Collet, Philippe and Dubois, Hubert and Ducasse, St\'ephane and Dupuy-Chessa, Sophie and Faron-Zucker, Catherine and Faucher, Cyril and Lafaye, Jean-Yves and Lahire, Philippe and Le Goaer, Olivier and Montagnat, Johan and Pinna-Dery, Anne-Marie},
  title = {Ing\'enierie dirig\'ee par les mod\`eles : quels supports \`a l'interop\'erabilit\'e des syst\`emes},
  journal = {Revue Ing\'enierie des Syst\`emes d'Information},
  volume = {18},
  pages = {9-40},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Auth13a-interop-si-JournalVersion.pdf},
  abstract = {Information systems are more and more often based on aggregation of other systems that must be maintained and evolved in an agile way and without uncontrolled entropy. This is not without interoperability problems! Among others, the aim of Model-Driven Engineering (MDE) is to provide solutions for interoperability issues between systems. This paper summarizes thoughts that have come up from the specific action Interoperability of information systems and model-driven engineering: What challenges? What solutions? supported by inforsid. We propose a summary of approaches that are based on MDE and knowledge engineering and that tackle interoperability issues in the industry. Open questions and limitations that raised during the meetings are also reported.},
  annote = {nationaljournal},
  hal-id = {hal-00813675},
  hal-url = {http://hal.inria.fr/hal-00813675},
  keywords = {moose lse-pub kzReengineerig}}

@misc{Auve11a,
  author = {Olivier Auverlot and St\'ephane Ducasse},
  title = {Construire un service Rest avec Pharo et Seaside-Rest},
  journal = {Linux Magazine},
  volume = 1,
  year = {2011},
  annote = {vulgarisation},
  hal-id = {hal-00746254},
  hal-url = {http://hal.inria.fr/hal-00746254},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzWeb kzTeaching},
  month = sep,
  number = 141}

@misc{Auve16a,
  author = {Olivier Auverlot and St\'ephane Ducasse},
  title = {Un Chat en Pharo},
  journal = {GNU Linux Magazine},
  year = {2016},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub pharo kzWeb kzTeaching},
  month = jan,
  hal-url = {http://hal.inria.fr/hal-01353594},
  hal-id = {hal-01353594},
  number = 189}

@misc{Auve16b,
  author = {Olivier Auverlot},
  title = {Pharo : g\'en\'erer des documents PDF avec Artefact},
  journal = {GNU Linux Magazine},
  year = {2016},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub pharo kzTeaching},
  month = feb,
  hal-url = {http://hal.inria.fr/hal-01353596},
  hal-id = {hal-01353596},
  number = 190}

@book{Auve19a,
  author = {Olivier Auverlot and St\'ephane Ducasse and Luc Fabresse},
  title = {TinyBlog: Develop your First Web App with Pharo},
  pages = {110},
  publisher = {Square Bracket Associates},
  year = {2019},
  hal-url = {http://hal.inria.fr/hal-02297688},
  hal-id = {hal-02297688},
  keywords = {moose StefPub}}

@book{Auve19b,
  author = {Olivier Auverlot and St\'ephane Ducasse and Luc Fabresse},
  title = {TinyBlog: Cr\'eer votre Premi\`ere Application Web avec Pharo},
  pages = {142},
  publisher = {Square Bracket Associates},
  year = {2019},
  hal-id = {hal-02297691},
  hal-url = {http://hal.inria.fr/hal-02297691},
  keywords = {moose StefPub}}

@techreport{Balm09a,
  author = {Fran\c{c}oise Balmas and Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Karine Mordal-Manet and Hani Abdeen and Fabrice Bellingard},
  title = {Software metric for Java and C++ practices (Squale Deliverable 1.1)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Balm09a-Squale-deliverable11-Metrics.pdf},
  abstract = {The objective of this workpackage is to define a catalog of software metrics. In particular we analyze the metrics used in the Squale Model and tool. In addition it offers a coherent set of software metrics for object-oriented languages on top of which Squale practices will be based. There is a plethora of software metrics [LK94, FP96, HS96, HK00, LM06] and a large amount of research articles. Still there is a lack for a serious and practically-oriented evaluation of metrics. Often metrics lacks the property that the software reengineer or quality expert can easily understand the situation summarized by the metrics. In particular since the exact notion of coupling and cohesion is complex, a particular focus on such point is important.},
  annote = {technicalReport},
  hal-id = {inria-00533617},
  hal-url = {http://hal.inria.fr/hal-00533617},
  institution = {INRIA Lille Nord Europe},
  keywords = {squale-pub lse-pub deliverable11 kzMetric kzEvolution}}

@techreport{Balm09c,
  author = {Fran\c{c}oise Balmas and Fabrice Bellingard and Simon Denier and St\'ephane Ducasse and Jannik Laval and Karine Mordal-Manet},
  title = {Practices in the Squale Quality Model (Squale Deliverable 1.3)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Balm09c-Squale-deliverable13-Practices.pdf},
  abstract = {This document presents the Squale Software Quality Model as defined by Qualixo. It first reviews existing quality models and presents the Squale model with its particularity, namely a practice layer. Then it reviews in details an instance of this Squale Model with its Factors, Criteria and Practices, giving precise definitions and description1. Finally, it discusses possible future enhancements of this model like new practices or its agreement with the program life-cycle and the change of needs during this life cycle.},
  hal-id = {inria-00533654},
  hal-url = {http://hal.inria.fr/hal-00533654},
  institution = {INRIA},
  keywords = {squale-pub lse-pub deliverable13 kzMetric kzEvolution}}

@inproceedings{Bera13a,
  author = {Cl\'ement B\'era and Marcus Denker},
  title = {Towards a flexible Pharo Compiler},
  booktitle = {International Workshop on Smalltalk Technologies 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera13a-OpalIWST.pdf},
  abstract = {The Pharo Smalltalk-inspired language and environment started its development with a codebase that can be traced back to the original
	Smalltalk-80 release from 1983. Over the last years, Pharo has been used as the basis of many research projects. Often these experiments needed
	changes related to the compiler infrastructure. However, they did not use the existing compiler and instead implemented their own experimental solutions.
	This shows that despite being an impressive achievement considering its age of over 35 years, the compiler infrastructure needs to be improved.
	We identify three problems: (i) The architecture is not reusable, (ii) compiler	can not be parametrized and (iii) the mapping between source code
	and bytecode is overly complex.
	Solving these problems will not only help researchers to develop new language features, but also the enhanced power of the infrastructure
	allows many tools and frameworks to be built that are important even for day-to-day development, such as debuggers and code transformation tools.
		In this paper we discuss the three problems, show how these are solved with a new Compiler model. We present an implementation, Opal, and show how
	Opal is used as the bases for many important tools for the everyday development of Pharo 3.},
  annote = {internationalworkshop},
  hal-id = {hal-00862411},
  hal-url = {http://hal.inria.fr/hal-00862411},
  keywords = {pharo marcusdenker lse-pub}}

@incollection{Bera13b,
  author = {Cl\'ement Bera and St\'ephane Ducasse},
  title = {Handling Exceptions},
  booktitle = {Deep Into Pharo},
  pages = 38,
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  annote = {articlebook},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming kzLanguageDesign kzPharo},
  month = sep}

@incollection{Bera13c,
  author = {St\'ephane Ducasse and Cl\'ement Bera},
  title = {Blocks: a Detailed Analysis},
  booktitle = {Deep Into Pharo},
  pages = 25,
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  isbn = {978-3-9523341-6-4},
  annote = {articlebook},
  keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming	kzLanguageDesign kzPharo},
  month = sep}

@inproceedings{Bera14a,
  author = {B{\'e}ra, Cl{\'e}ment and Miranda, Eliot},
  title = {A bytecode set for adaptive optimizations},
  booktitle = {International Workshop on Smalltalk Technologies (IWST 14)},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera14a-IWST-BytecodeSet.pdf},
  annote = {internationalworkshop},
  keywords = {lse-pub},
  month = aug,
  hal-url = {http://hal.inria.fr/hal-01088801},
  hal-id = {hal-01088801}}

@article{Bera16a,
  author = {Cl\'ement B\'era and Eliot Miranda and Marcus Denker and St\'ephane Ducasse},
  title = {Practical Validation of Bytecode to Bytecode JIT Compiler Dynamic Deoptimization},
  journal = {Journal of Object Technology},
  volume = {15},
  pages = {1:1-26},
  year = {2016},
  doi = {10.5381/jot.2016.15.2.a1.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera16aPracticalValidation-JOT.pdf},
  hal-id = {hal-01299371},
  hal-url = {http://hal.inria.fr/hal-01299371},
  annote = {internationaljournal},
  abstract = {Speculative inlining in just-in-time compilers enables many performance optimizations. However, it also introduces significant complexity. The compiler optimizations themselves, as well as the deoptimization mechanism are complex and error prone. To stabilize our bytecode to bytecode just-in-time compiler, we designed a new approach to validate the correctness of dynamic deoptimization. The approach consists of the symbolic execution of an optimized and an unop-timized bytecode compiled method side by side, deoptimizing the abstract stack at each deoptimization point (where dynamic deoptimization is possible) and comparing the deoptimized and unoptimized abstract stack to detect bugs. The implementation of our approach generated tests for several hundred thousands of methods, which are now available to be run automatically after each commit.},
  keywords = {stefpub lse-pub marcusdenker kzLanguageDesign kzVM},
  number = {2}}

@inproceedings{Bera16b,
  author = {B\'era, Cl\'ement},
  title = {A low Overhead Per Object Write Barrier for the Cog VM},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  doi = {10.1145/2991041.2991063},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera16b-IWST16-WriteBarrier.pdf},
  address = {Prague, Czech Republic},
  hal-url = {http://hal.inria.fr/hal-01356338},
  hal-id = {hal-01356338},
  keywords = {lse-pub},
  month = aug,
  annote = {internationalworkshop}}

@phdthesis{Bera17a,
  author = {Cl\'ement Bera},
  title = {Sista: a Metacircular Architecture for Runtime Optimisation Persistence},
  year = {2017},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2017-Bera.pdf},
  abstract = {Most high-level programming languages run on top of a virtual machine (VM) to abstract away from the underlying hardware. To reach high-performance, the VM typically relies on an optimising just-in-time compiler (JIT), which speculates on the program behavior based on its first runs to generate at runtime efficient machine code and speed-up the program execution. As multiple runs are required to speculate correctly on the program behavior, such a VM requires a certain amount of time at start-up to reach peak performance. The optimising JIT itself is usually compiled ahead-of-time to executable code as part of the VM.
The dissertation proposes Sista, an architecture for an optimising JIT, in which the optimised state of the VM can be persisted across multiple VM start-ups and the optimising JIT is running in the same runtime than the program executed. To do so, the optimising JIT is split in two parts. One part is high-level: it performs optimisations specific to the programming language run by the VM and is written in a metacircular style. Staying away from low-level details, this part can be read, edited and debugged while the program is running using the standard tool set of the programming language executed by the VM. The second part is low-level: it performs machine specific optimisations and is compiled ahead-of-time to executable code as part of the VM. The two parts of the JIT use a well-defined intermediate representation to share the code to optimise. This representation is machine-independent and can be persisted across multiple VM start-ups, allowing the VM to reach peak performance very quickly.
To validate the architecture, the dissertation includes the description of an implementation on top of Pharo Smalltalk and its VM. The implementation is able to run a large set of benchmarks, from large application benchmarks provided by industrial users to micro-benchmarks used to measure the performance of specific code patterns. The optimising JIT is implemented according to the architecture proposed and shows significant speed-up (up to 5x) over the current production VM. In addition, large benchmarks show that peak performance can be reached almost immediately after VM start-up if the VM can reuse the optimised state persisted from another run.},
  annote = {PhD},
  hal-id = {tel-01634137},
  inria = {RMOD},
  institution = {INRIA},
  keywords = {virtual machine compiler memory management jit lse-pub},
  hal-url = {http://hal.inria.fr/tel-01634137}}

@inproceedings{Bera17b,
  author = {B{\'e}ra, Cl{\'e}ment and Miranda, Eliot and Felgentreff, Tim and Denker, Marcus and Ducasse, St\'ephane},
  title = {Sista: Saving Optimized Code in Snapshots for Fast Start-Up},
  booktitle = {Proceedings of the 14th International Conference on Managed Languages and Runtimes},
  pages = {1 - 11},
  publisher = {ACM},
  year = {2017},
  doi = {10.1145/3132190.3132201},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera17b-ManLang-SistaArchitecture.pdf},
  annote = {internationconference},
  hal-url = {https://hal.inria.fr/hal-01596321},
  address = {Prague, Czech Republic},
  month = sep,
  keywords = {kzVM kzPharo ; Just-in-time compilation ; Runtime compiler ; Object-oriented language ; lse-pub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bera17b-ManLang-SistaArchitecture.pdf},
  hal-id = {hal-01596321}}

@inproceedings{Berg03a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
  title = {Classboxes: A Minimal Module Model Supporting Local Rebinding},
  booktitle = {Proceedings of Joint Modular Languages Conference (JMLC'03)},
  volume = {2789},
  pages = {122--131},
  publisher = {Springer-Verlag},
  year = {2003},
  doi = {10.1007/b12023},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03a-JMLC03-Classboxes.pdf},
  abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
  annote = {internationalconference},
  hal-id = {inria-00533446},
  isbn = {978-3-540-40796-6},
  keywords = {module classbox kzClassBox},
  note = {Best Paper Award},
  hal-url = {https://hal.inria.fr/hal-00533446},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03aClassboxes.pdf},
  series = {LNCS}}

@inproceedings{Berg03b,
  author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
  title = {The {Classbox} Module System},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03b-Workshop-Classboxes.pdf},
  abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
  annote = {internationalworkshop},
  keywords = {stefPub alexPub module classbox kzClassBox},
  month = jul,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg03bClassboxes.pdf}}

@techreport{Berg04a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Classboxes: Controlling Visibility of Class Extensions},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Berg04a-IAM-04-003.pdf},
  abstract = {A class extension is a method that is defined in a module, but whose class is defined elsewhere. Class extensions offer a convenient way to incrementally modify existing classes when subclassing is inappropriate. Unfortunately existing approaches suffer from various limitations. Either class extensions have a global impact, with possibly negative effects for unexpected clients, or they have a purely local impact, with negative results for collaborating clients. Furthermore, conflicting class extensions are either disallowed, or resolved by linearization, with consequent negative effects.	To solve these problems we present classboxes, a module system for object-oriented languages that provides for method addition and replacement.	Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model we have implemented it in the Squeak Smalltalk environment, and performed benchmarks.},
  address = {Universit\"at Bern, Switzerland},
  annote = {report notrefereed technicalReport},
  institution = {Institut f\"ur Informatik},
  keywords = {stefPub alexPub kzClassBox},
  month = jun,
  number = {IAM-04-003},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg04aIAM-04-003.pdf}}

@inproceedings{Berg04c,
  author = {Alexandre Bergel and Christophe Dony and St\'ephane Ducasse},
  title = {Prototalk: an Environment for Teaching, Understanding, Designing and Prototyping Object-Oriented Languages},
  booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
  pages = {107--130},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg04c-ISC04-prototalk.pdf},
  abstract = {With prototype-based languages, concretization and abstraction are unified into a single concept a prototype. Prototype-based languages are based on a simple set of principles: object-centered representation, dynamic reshape of objects, cloning and possibly message delegation. However, they all differ in the interpretation and combination of these principles. Therefore there is a need to compare and understand. In this paper we present Prototalk, a research and teaching vehicle to understand, implement and compare prototype-based languages. Prototalk is a framework that offers a predefined set of language data structures and mechanisms that can be composed and extended to generate various prototype-based language interpreters. It presents a classification of languages based on different mechanisms in an operational manner.},
  annote = {internationalconference},
  hal-id = {inria-00533452},
  hal-url = {https://hal.inria.fr/hal-00533452},
  keywords = {stefPub alexPub kzPrototype},
  month = sep,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg04cprototalk.pdf}}

@article{Berg05a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Classboxes: Controlling Visibility of Class Extensions},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {31},
  pages = {107--126},
  publisher = {Elsevier},
  year = {2005},
  impactfactor = {Impact factor (2010) 0.541},
  doi = {10.1016/j.cl.2004.11.002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05a-CompLangESUG04-classboxesJournal.pdf},
  abstract = {A class extension is a method that is defined in a module, but whose class is
defined elsewhere. Class extensions offer a convenient way to incrementally modify existing
classes when subclassing is inappropriate. Unfortunately existing approaches suffer from
various limitations. Either class extensions have a global impact, with possibly negative
effects for unexpected clients, or they have a purely local impact, with negative results
for collaborating clients. Furthermore, conflicting class extensions are either disallowed,
or resolved by linearization, with consequent negative effects. To solve these problems we
present classboxes, a module system for object-oriented languages that provides for method
addition and replacement. Moreover, the changes made by a classbox are only visible to that
classbox (or classboxes that import it), a feature we call local rebinding. To validate the
model we have implemented it in the Squeak Smalltalk environment, and performed
benchmarks.},
  annote = {internationaljournal},
  hal-id = {inria-00533458},
  hal-url = {https://hal.inria.fr/hal-00533458},
  keywords = {classbox stefPub kzClassbox},
  month = dec,
  number = {3-4},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05aclassboxesJournal.pdf}}

@inproceedings{Berg05b,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Classbox/{J}: Controlling the Scope of Change in {Java}},
  booktitle = {Proceedings of 20th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'05)},
  pages = {177--189},
  publisher = {ACM Press},
  year = {2005},
  misc = {acceptance rate: 25/142 = 17\%},
  doi = {10.1145/1094811.1094826},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05b-OOSPLA05-classboxJ.pdf},
  abstract = {Unanticipated changes to complex software systems can introduce anomalies such as duplicated code, suboptimal inheritance relationships and a proliferation of run-time downcasts. Refactoring to eliminate these anomalies may not be an option, at least in certain stages of software evolution.	Classboxes are modules that restrict the visibility of changes to selected clients only, thereby offering more freedom in the way unanticipated changes may be implemented, and thus reducing the need for convoluted design anomalies. In this paper we demonstrate how classboxes can be implemented in statically-typed languages like {Java}. We also present an extended case study of Swing, a {Java} GUI package built on top of AWT, and we document the ensuing anomalies that Swing introduces. We show how Classbox/J, a prototype implementation of classboxes for {Java}, is used to provide a cleaner implementation of Swing using local refinement rather than subclassing.},
  acceptnum = {25},
  accepttotal = {142},
  address = {New York, NY, USA},
  annote = {internationalconference topconference},
  hal-id = {inria-00533461},
  hal-url = {https://hal.inria.fr/hal-00533461},
  keywords = {StefPub alexPub kzClassbox},
  rate = {17\%},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05bclassboxjOOPSLA.pdf}}

@article{Berg05c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Analyzing Module Diversity},
  journal = {Journal of Universal Computer Science},
  volume = {11},
  pages = {1613--1644},
  year = {2005},
  impactfactor = {SCI impact factor 0.337},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05cModuleDiversity.pdf},
  abstract = {Each object-oriented programming language proposes various grouping
mechanisms to bundle interacting classes (i.e., packages, modules, selector namespaces,
etc). To understand such diversity and to compare the different approaches, a common
foundation is needed. As far as we are aware of, no major attempt that would go in that
direction has been realized. In this paper we present a simple module calculus together
with a set of operators for modeling the composition semantics of different grouping
mechanisms. Using this module calculus we are able to express the semantics of {Java}
packages, C# namespaces, Ruby modules, selector namespaces, gbeta classes, classboxes,
MZScheme units, and MixJuice modules. This calculus supports the identification of system
families sharing similar characteristics. In addition it provides a uniform way to
represent and analyze fine-grained module semantics.},
  annote = {internationaljournal},
  keywords = {classbox stefPub alexPub kzClassbox kzModule},
  month = nov,
  number = {10}}

@inproceedings{Berg05d,
  author = {Alexandre Bergel and St\'ephane Ducasse},
  title = {Supporting Unanticipated Changes with {Traits} and {Classboxes}},
  booktitle = {{Net}.{ObjectDays} (NODE'05)},
  pages = {61--75},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05dTraitsClassbox.pdf},
  abstract = {On the one hand, traits are a powerful way of structuring classes. Traits
support the reuse of method collections over several classes. However, traits cannot be
used when specifying unanticipated changes to an application. On the other hand, classboxes
are a new module system that supports the local redefinition of classes: a collection of
classes can be locally extended with variables and/or methods and the existing clients do
not get impacted by changes. However, an extension applied to a class by a classbox cannot
be reused for other classes. This paper describes how combining Traits and Classboxes
supports the safe introduction of crosscutting collaborations: safe because the existing
clients of the classes do not get impacted, crosscutting because collaborations between
several classes can be put in place in a unanticipated manner. In the resulting system, a
collaboration is represented by a classbox and a role by a trait.},
  address = {Erfurt, Germany},
  annote = {nationalconference},
  keywords = {alexPub stefPub kzClassBox kzTrait},
  month = sep}

@article{Berg05e,
  author = {Alexandre Bergel and St\'ephane Ducasse},
  title = {Scoped and Dynamic Aspects with {Classboxes}},
  journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet (Num\'ero sp\'ecial : Programmation par aspects)},
  volume = {11},
  pages = {53--68},
  publisher = {Hermes, Paris},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg05eDynamicClassboxes.pdf},
  abstract = {Atomically introducing changes to a group of classes is a challenging task.
In addition, certain applications require that changes be applied dynamically without
shutting down and restarting the application. In this paper we present an extension of
classboxes to make them dynamic. A classbox is a kind of module that supports class
extension and instance variable addition. Class extensions and definitions defined in a
classbox represent an aspect. In addition, with classboxes, aspects are dynamically applied
to, removed from hot- in a system. Such aspects may crosscut a large number of classes
which are extended by adding or redefining existing methods and adding new instance
variables. Finally the aspects are scoped i.e., they are local to the classboxes that
define them.},
  annote = {nationaljournal},
  keywords = {classboxes stefPub alexPub kzClassbox kzAspect},
  month = nov,
  number = {3}}

@inproceedings{Berg06b,
  author = {Alexandre Bergel and Marcus Denker},
  title = {Prototyping Languages, Related Constructs and Tools with {Squeak}},
  booktitle = {Proceedings of the ECOOP'06 Workshop on Revival of Dynamic Languages},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bergel06b-RDL06-Prototyping.pdf},
  abstract = {Prototyping new programming languages is often assimilated as a task
requiring heavy expertise in parsing and compilation. This paper argues that choosing as a
host platform a language having advanced reflective capabilities helps in reducing the
effort and time spent on developing new language related constructs and tools. The Squeak
Smalltalk implementation provides very expressive reflective facilities. In this paper we
focus on having methods as first class entities, enabling methods manipulation as plain
standard objects and reification of method execution. Powerful language related tools and
efficient new programming constructs can be quickly implemented. ByteSurgeon, a bytecode
manipulation library, and FacetS, an aspect mechanism, serve as illustrations.},
  annote = {internationalworkshop},
  keywords = {alexpub fromscgbib marcusdenker},
  medium = {4},
  month = jul}

@inproceedings{Berg07a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Stateful Traits},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC'06)},
  volume = {4406},
  pages = {66--90},
  publisher = {Springer},
  year = {2007},
  doi = {10.1007/978-3-540-71836-9\_3},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg07a-InternationalSmalltalkConference07-StatefulTraits.pdf},
  abstract = {Traits offer a fine-grained mechanism to compose classes from reusable
components while avoiding problems of fragility brought by multiple inheritance and mixins.
Traits as originally proposed are \emph{stateless}, that is, they contain only methods, but
no instance variables. State can only be accessed within traits by accessors, which become
\emph{required methods} of the trait. Although this approach works reasonably well in
practice, it means that many traits, viewed as software components, are artificially
\emph{incomplete}, and classes that use such traits may contain significant amounts of
boilerplate glue code. Although these limitations are largely mitigated by proper tool
support, we seek a cleaner solution that supports \emph{stateful traits}. The key
difficulty is how to handle conflicts that arise when composed traits contribute instance
variables whose names clash. We present a solution that is faithful to the guiding
principle of stateless traits: \emph{the client retains control of the composition}.
Stateful traits consist of a minimal extension to stateless traits in which instance
variables are purely local to the scope of a trait, unless they are explicitly made
accessible by the composing client of a trait. Naming conflicts are avoided, and variables
of disjoint traits can be explicitly merged by clients. We discuss and compare two
implementation strategies, and briefly present a case study in which stateful traits have
been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
  annote = {internationalconference},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {StefPub traits kzTrait},
  medium = {2},
  month = aug,
  series = {LNCS}}

@inproceedings{Berg07c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
  title = {Meta-Driven Browsers},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC'06)},
  volume = {4406},
  pages = {134--156},
  publisher = {Springer},
  year = {2007},
  doi = {10.1007/978-3-540-71836-9\_3},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg07cOmnibrowser.pdf},
  abstract = {Smalltalk is not only an object-oriented programming language; it is also known for its extensive integrated development environment supporting interactive and dynamic programming. While the default tools are adequate for browsing the code and developing applications, it is often cumbersome to extend the environment to support new language constructs or to build additional tools supporting new ways of navigating and presenting source code. In this paper, we present the OmniBrowser, a browser framework that supports the definition of browsers based on an explicit metamodel. With OmniBrowser a domain model is described in a graph and the navigation in this graph is specified in its associated metagraph. We present how new browsers are built from predefined parts and how new tools are easily described. The browser framework is implemented in the Squeak Smalltalk environment. This paper shows several concrete instantiations of the framework: a remake of the ubiquitous Smalltalk System Browser, and a coverage browser.},
  annote = {internationalconference},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {stefPub kzIDE},
  medium = {2},
  month = aug,
  series = {LNCS}}

@article{Berg08a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Lukas Renggli},
  title = {Seaside -- Advanced Composition and Control Flow for Dynamic Web Applications},
  journal = {ERCIM News},
  volume = 72,
  year = {2008},
  abstract = {Page-centric Web application frameworks fail to offer adequate solutions to
model composition and control flow. Seaside allows Web applications to be developed in the
same way as desktop applications. Control flow is modelled as a continuous piece of code,
and components may be composed, configured and nested as one would expect from traditional
user interface frameworks.},
  annote = {vulgarisation},
  keywords = {alexPub stefPub kzWeb},
  month = jan}

@inproceedings{Berg08b,
  author = {Alexandre Bergel and Wolfgang De Meuter and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Dynamic Languages and Applications, Report on the Workshop {Dyla}'07 at {ECOOP} 2007},
  booktitle = {Object-Oriented Technology. ECOOP'07 Workshop Reader},
  volume = {4906},
  pages = {7--12},
  publisher = {Springer-Verlag},
  year = {2008},
  doi = {10.1007/978-3-540-78195-0},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Berg08b-Dyla07Report.pdf},
  abstract = {Following last two years' workshop on dynamic languages at the ECOOP
conference, the Dyla 2007 workshop was a successful and popular event. As its name implies,
the workshop's focus was on dynamic languages and their applications. Topics and
discussions at the workshop included macro expansion mechanisms, extension of the method
lookup algorithm, language interpretation, reflexivity and languages for mobile ad hoc
networks. The main goal of this workshop was to bring together different dynamic language
communities and favouring cross communities interaction. Dyla 2007 was organised as a full
day meeting, partly devoted to presentation of submitted position papers and partly devoted
to tool demonstration. All accepted papers can be downloaded from the workshop's web site.
In this report, we provide an overview of the presentations and a summary of discussions.},
  annote = {workshopproceedings},
  isbn = {978-3-540-78194-3},
  keywords = {stefPub scg-pub kzEditor},
  medium = {2},
  series = {LNCS}}

@inproceedings{Berg08c,
  author = {Alexandre Bergel and St\'ephane Ducasse and Jannik Laval and Romain Peirs},
  title = {Enhanced Dependency Structure Matrix for Moose},
  booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg08c-Famoosr2008-DSM.pdf},
  annote = {internationalworkshop},
  hal-id = {inria-00498484},
  keywords = {moose kzCycle}}

@article{Berg08d,
  author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
  title = {Creating Sophisticated Development Tools with {OmniBrowser}},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {34},
  pages = {109--129},
  publisher = {Elsevier},
  year = {2008},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2007.05.005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg08d-JComputerLanguage-OmniBrowser.pdf},
  abstract = {Smalltalk is not only an object-oriented programming language; it is also
known for its extensive integrated development environment supporting interactive and
dynamic programming. While the default tools are adequate for browsing the code and
developing applications, it is often cumbersome to extend the environment to support new
language constructs or to build additional tools supporting new ways of navigating and
presenting source code. In this paper, we present the OmniBrowser, a browser framework that
supports the definition of browsers based on an explicit metamodel. With OmniBrowser a
domain model is described in a graph and the navigation in this graph is specified in its
associated metagraph. We present how new browsers are built from predefined parts and how
new tools are easily described. The browser framework is implemented in the Squeak
Smalltalk environment. This paper shows several concrete instantiations of the framework: a
remake of the ubiquitous Smalltalk System Browser, a coverage browser, the Duo Browser and
the Dynamic Protocols browser.},
  annote = {internationaljournal},
  keywords = {StefPub kzIDE},
  number = {2-3}}

@article{Berg08e,
  author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Stateful Traits and their Formalization},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {34},
  pages = {83--108},
  publisher = {Elsevier},
  year = {2008},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2007.05.003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg08e-JournalComputerLanguages-StatefulTraitsFormalization.pdf},
  abstract = {Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially \emph{incomplete}, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
  annote = {internationaljournal},
  issn = {1477-8424},
  keywords = {StefPub kzTrait},
  medium = {2},
  hal-id = {hal-02109190},
  number = {2-3}}

@inproceedings{Berg09a,
  author = {Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues and Fran\c{c}oise Balmas and Karine Mordal-Manet},
  title = {SQUALE -- Software QUALity Enhancement},
  booktitle = {Proceedings of the 13th European Conference on Software Maintenance and Reengineering (CSMR'09), European Projects Track},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg09c-CSMR2009-Squale.pdf},
  annote = {internationalconference},
  hal-id = {hal-00746252},
  institution = {INRIA},
  keywords = {squale-pub lse-pub kzMetric},
  month = {mar},
  note = {Presentation}}

@inproceedings{Berg09b,
  author = {Alexandre Bergel},
  title = {Contr\^oler la visibilit\'e des aspects avec Aspectboxes},
  booktitle = {Proceedings of LMO 2009},
  year = {2009},
  abstract = {La composition et l'int\'eraction des aspects est un domaine de recherche tr\`es actif. Bien que plusieurs solutions existent, telles que l'agencement
des aspects et des advices, les approches propos\'ees par des langages \`a aspects
supposent qu'une connaissance g\'en\'erale des aspects soit n\'ecessaire pour pouvoir
les composer, et m\^eme ceci ne permet pas d'\'eviter les interactions implicites r\'esultant d'une composition.
Cet article pr\'esente les aspectboxes, un m\'ecanisme de visibilit\'e pour aspects.
L'unit\'e \'el\'ementaire de visibilit\'e est un aspectbox. Un aspectbox encapsule des
d\'efinitions d'aspects. Un aspectbox peut \^etre utilis\'e par d'autres aspectboxes
pour aider la construction incr\'ementale de logiciel \`a base d'aspects. Une classe
peut utiliser un aspectbox dans le but de b\'en\'eficier des aspects d\'efinis.},
  annote = {nationalconference},
  hal-id = {hal-00746256},
  institution = {INRIA},
  keywords = {lse-pub}}

@book{Berg13a,
  author = {Bergel, Alexandre and Cassou, Damien and Ducasse, St\'ephane and Laval, Jannik},
  title = {{Deep Into Pharo}},
  pages = {420},
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/Berg13a-PBE2-ESUG-2013-09-06.pdf},
  abstract = {Pharo is a dynamic object-oriented programming language. Pharo's model and syntax are uniform, simple and expressive. These properties, when added to a powerful and flexible programming environment, regularly attract new developers. The community around Pharo has been steadily increasing over the years. This community is actively creating exciting and innovative software artifacts helping the development of advanced software systems. Pharo heightens the software building experience to its best. It offers open and object-oriented programming environments and libraries. The book covers a large spectrum of topics ranging from central language aspects to innovative frameworks and libraries. This book contains unique material often presented in a tutorial form with many hand-on exercises. Everybody will learn something reading this book: programmers familiar with Pharo will enjoy the highlights made of some particularly beautiful aspects of Pharo as well as discovering new and powerful frameworks. Practitioners making their debut with Pharo will take on a wonderful journey in the realm of objects.	Deep into Pharo presents both internal aspects of Pharo and libraries that prove to be important for academic, business and development perspectives.},
  annote = {book},
  hal-id = {hal-00858725},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming pharo StefPub kzBook}}

@techreport{Berg13b,
  author = {Alexandre Bergel and St\'ephane Ducasse and Marcus Denker and Johan Fabry},
  title = {PLOMO Associate Team Final Report},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Berg13b-PLOMOTechReport.pdf},
  annote = {technicalreport},
  hal-id = {hal-00871114},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {stefPub marcusdenker lse-pub plomo}}

@inproceedings{Berg14a,
  author = {Alexandre Bergel and Sergio Maass and St\'ephane Ducasse and Tudor Girba},
  title = {A Domain-Specific Language For Visualizing Software Dependencies as a Graph},
  booktitle = {Vissoft'14, NIER Track},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Berg14a-Vissoft-DomainSpecific.pdf},
  abstract = {Graphs are commonly used to visually represent software dependencies. However, adequately visualizing software dependencies as a graph is a non-trivial problem due to the pluridimentional nature of software. We have designed a domain-specific language for visualizing software dependencies as graphs that is both expressive and concise. GRAPH, the implementation of our DSL, features a seamless mapping between visual dimensions to software metrics, composition of graph layouts, graph partition, and hierarchical bundle edges.},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/hal-01369705},
  hal-id = {hal-01369705},
  keywords = {stefPub kzVisualization}}

@techreport{Berg16a,
  author = {Alexandre Bergel and St\'ephane Ducasse and Marcus Denker and Johan Fabry},
  title = {PLOMO2 Associate Team Final Report},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Berg16a-PLOMO2TechReport.pdf},
  annote = {technicalreport},
  hal-id = {hal-01389983},
  inria = {RMOD},
  institution = {INRIA},
  keywords = {stefPub marcusdenker lse-pub plomo}}

@inproceedings{Bert03a,
  author = {Roland Bertuli and St\'ephane Ducasse and Michele Lanza},
  title = {Run-Time Information Visualization for Understanding Object-Oriented Systems},
  booktitle = {Proceedings of 4th International Workshop on Object-Oriented Reengineering (WOOR'03)},
  pages = {10--19},
  publisher = {University of Antwerp},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bert03aEcoop-Workshop.pdf},
  abstract = {Understanding object-oriented legacy systems is a complex task exacerbated by the presence of late binding and polymorphism. Moreover, the metaphor of message sending and the anthropomorphism promoted by object-oriented languages makes it difficult to statically identify the precise role the objects play at run-time. We propose a lightweight visualization approach enriched with run-time information which allows us to identify precise aspects of the objects lifetime such as the role played in the creation of other objects and the communication architecture they support. Our approach not only supports the run-time understanding of an application but also allows one to evaluate test understanding and test coverage.},
  annote = {internationalworkshop},
  keywords = {stefPub moose kzVisualization kzDynamicInformation},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bert03aEcoopWorkshop.pdf}}

@inproceedings{Bezi03a,
  author = {B\'ezivin, Jean and Farcet, Nicolas and J\'ez\'equel, Jean-Marc and Langlois, Beno\^\it and Pollet, Damien},
  title = {Reflective Model Driven Engineering},
  booktitle = {UML~2003 --- The Unified Modeling Language --- Modeling Languages and Applications},
  volume = {2863},
  pages = {175--189},
  publisher = {Springer Verlag},
  year = {2003},
  pdf = {http://www.irisa.fr/triskell/publis/2003/Bezivin03.pdf},
  annote = {internationalconference},
  editor = {Stevens, Perdita and Whittle, Jon and Booch, Grady},
  isbn = {3-540-20243-9},
  month = oct,
  series = {LNCS}}

@inproceedings{Bhat07a,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse},
  title = {Surgical Information to Detect Design Problems with MOOSE},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  year = {2007},
  annote = {internationalworkshop},
  keywords = {moose kzRemodularisation},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat07aFamoosRWorkshop.pdf},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat07aFamoosRWorkshop.pdf}}

@inproceedings{Bhat08a,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Awais Rashid},
  title = {Aspect Mining in Procedural Object-Oriented Code},
  booktitle = {International Conference on Program Comprehension (ICPC'08)},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat08a-ICPC2008-AspectMining.pdf},
  annote = {internationalconference shortpaper},
  keywords = {moose kzAspect kzModule kzRemodularisation}}

@inproceedings{Bhat08b,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Marianne Huchard},
  title = {Reconsidering Classes in Procedural Object-Oriented Code},
  booktitle = {Proceedings of the 15th International Working Conference on Reverse Engineering (WCRE'08)},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat08b-WCRE2008-ObjectIdentification.pdf},
  annote = {internationalconference},
  keywords = {moose StefPub kzRemodularisation}}

@techreport{Bhat08c,
  author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Awais Rashid},
  title = {Aspect Mining in Procedural Object-Oriented Code},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Bhat08c-TechReport-AspectMining.pdf},
  annote = {techreport},
  institution = {INRIA Lille Nord Europe},
  keywords = {kzRemodularisation}}

@phdthesis{Bhat08d,
  author = {Muhammad Usman Bhatti},
  title = {Object Identification and Aspect Mining in Procedural Object-Oriented Code},
  year = {2008},
  school = {UNIVERSITE PARIS I -- PANTHEON -- SORBONNE},
  abstract = {In this dissertation, we present Procedural Object-Oriented Code (POC). POC is the aftermath of the software development activity that involves state of the art object-oriented languages, without employing object-oriented analysis and design. Huge classes, absence of abstractions for domain entities, and shallow inheritance hierarchies are hallmark design defects of procedural object-oriented code. POC also consists of scattered code appearing not only due to the absence of aspects, but it also manifests scattered code appearing due to the non-abstracted domain entities i.e., domain entities that do not have their proper object-oriented classes. The non-abstracted domain logic hinders mining useful crosscutting concerns related to aspects in POC. Confronted with the absence of object-oriented design and the difficulty of mining aspects in POC, we studied it from two perspectives.
	First, we improve aspect mining techniques by classifying various crosscutting concerns identified in POC with a two-pronged approach: Firstly, the approach identifies and groups crosscutting concerns present in a software system: aspects as well as non-abstracted domain logic. Crosscutting concerns pertaining to non- abstracted domain entities are identified and extracted through their usage of application domain entity data. Secondly, a new metric called spread-out is introduced to quantify the divulgence of diverse crosscutting concerns.
	Second, we studied the problem of object identification in procedural object- oriented code. We present a semi-automatic, tool-assisted approach for restructuring POC into an improved object-oriented design. The approach identifies principal classes in POC. These principal classes are then used to extract object-oriented abstractions using Formal Concept Analysis lattices. This is achieved by providing three different concept lattices, namely fundamental, association, and interactions views.
	We developed tools to validate the approaches presented in the thesis. The approaches are validated on a recently developed industrial application. The application is used to run blood plasma analysis automatons. The results of our approach are promising.},
  hal = {tel-00498436}}

@inproceedings{Bhat12a,
  author = {Muhammad U.Bhatti and Nicolas Anquetil and Marianne Huchard and St\'ephane Ducasse},
  title = {A Catalog of Patterns for Concept Lattice Interpretation in Software Reengineering},
  booktitle = {Proceedings of the 24th International Conference on Software Engineering \& Knowledge Engineering (SEKE 2012)},
  pages = {118--24},
  year = {2012},
  misc = {acceptance rate: 59/219 = 27\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bhat12c-SEKE2012-FCA-patterns.pdf},
  abstract = {Formal Concept Analysis (FCA) provides an important approach in software reengineering for software understanding,	design anomalies detection and correction.
However, FCA-based approaches	have two problems: (i) they produce lattices that must be interpreted by the user according to his/her understanding of the technique and different elements of the graph; and, (ii) the lattice can rapidly become so big that one is overwhelmed by the mass of information and possibilities.
In this paper, we present	a catalog of important patterns in concept lattices, which can allow automating the task of lattice interpretation. The approach helps the reengineer to concentrate on the task of reengineering rather than understanding a complex lattice.
We provide interpretation of these patterns in a generalized manner and illustrate them on various contexts constructed from program information of different open-source systems. We also present a tool that allows automated extraction of the patterns from concept lattices.},
  acceptnum = {59},
  accepttotal = {219},
  annote = {internationalconference},
  hal-id = {hal-00700046},
  isbn = {978-1-891706-31-8},
  keywords = {lse-pub stefPub kzRemodularisation},
  tagnicolasa = {architecture FCA}}

@article{Bhat12b,
  author = {Muhammad U. Bhatti and Nicolas Anquetil and St\'ephane Ducasse},
  title = {An Environment for dedicated Software Analysis tools},
  journal = {ERCIM News},
  volume = {88},
  pages = {12--13},
  year = {2012},
  pdf = {http://ercim-news.ercim.eu/images/stories/EN88/EN88-web.pdf},
  abstract = {Moose is an open-source platform for the assessment of software and data analysis. Moose provides several engines to build tools, analyses and visualizations. One of Moose's strengths is the possibility to rapidly build domain-specific analysis tools.},
  annote = {vulgarisation},
  hal-id = {hal-00759511},
  keywords = {moose lse-pub raweb2012 kzIDE kzMoose},
  month = jan,
  tagnicolasa = {other analysis}}

@techreport{Blac02a,
  author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
  title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Blac02a-TraitsHierarchy.pdf},
  abstract = {Traits are a programming language technology modeled after mixins but
avoiding their problems. In this paper we refactor the Smalltalk collections hierarchy
using traits. We observed that the original hierarchy contained much duplication of code;
traits let us remove all of it. Traits also make possible much more general reuse of
collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
size of the collection hierarchy by approximately 12 per cent, with no measurable impact on
execution efficiency. More importantly, understandability and reusability of the code was
significantly improved, and the path was paved for a more intensive refactoring.},
  address = {Universit\"at Bern, Switzerland},
  annote = {techreport notrefereed},
  institution = {Institut f\"ur Informatik},
  keywords = {kzTrait},
  month = nov,
  note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
  number = {IAM-02-007},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blac02aTraitsHierarchy.pdf}}

@inproceedings{Blac03a,
  author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
  title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
  booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
  volume = {38},
  pages = {47--64},
  year = {2003},
  misc = {acceptance rate: 26/142 = 18\%},
  doi = {10.1145/949305.949311},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blac03a-OOSPLA03-TraitsHierarchy.pdf},
  abstract = {Traits are a programming language technology that promote the reuse of
methods between unrelated classes. This paper reports on a refactoring of the Smalltalk
collections classes using traits. The original collection classes contained much
duplication of code; traits let us remove all of it. We also found places where the
protocols of the collections lacked uniformity; traits allowed us to correct these
non-uniformities without code duplication. Traits also make it possible to reuse fragments
of collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
number of methods in the collection classes by approximately 10 per cent. More importantly,
understandability maintainability and reusability of the code were significantly improved.},
  acceptnum = {26},
  accepttotal = {142},
  annote = {internationalconference topconference},
  keywords = {kzTrait},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blac03aTraitsHierarchy.pdf}}

@book{Blac07a,
  author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
  title = {Squeak by Example},
  publisher = {Square Bracket Associates},
  year = {2007},
  url = {https://github.com/SquareBracketAssociates/SqueakByExample-english},
  abstract = {Squeak by Example, intended for both students and developers, will guide you gently through the Squeak language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  annote = {book},
  isbn = {978-3-9523341-0-2},
  keywords = {skipdoimarcusdenker}}

@book{Blac09a,
  author = {Andrew P. Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
  title = {Pharo by Example},
  pages = {333},
  publisher = {Square Bracket Associates},
  year = {2009},
  url = {http://books.pharo.org},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/Blac09a-PBE1-2013-07-29.pdf},
  abstract = {Pharo by Example, intended for both students and developers, will guide you gently through the Pharo open-source Smalltalk language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  address = {Kehrsatz, Switzerland},
  annote = {book},
  hal-id = {hal-00849020},
  isbn = {978-3-9523341-4-0},
  keywords = {skipdoi pharo-pub marcusdenker kzPharo}}

@inproceedings{Blon15a,
  author = {Blondeau, Vincent and Anquetil, Nicolas and Ducasse, St\'ephane and Cresson, Sylvain and Croisy, Pascal},
  title = {Software metrics to predict the health of a project?},
  booktitle = {{International Workshop on Smalltalk Technologies IWST'15}},
  year = {2015},
  doi = {10.1145/2811237.2811294},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon15a-IWST-PredictingProjectHealth.pdf},
  hal-url = {https://hal.inria.fr/hal-01185079},
  hal-id = {hal-01185079},
  tagnicolasa = {metric},
  annote = {internationalworkshop},
  address = {Brescia, Italy},
  month = jul,
  keywords = {lse-pub ;	moose-pub ; pharo-pub ; Project health ; Closed-source ; Data-mining ; Interviews, kzMetric}}

@inproceedings{Blon15b,
  author = {Blondeau, Vincent and Cresson, Sylvain and Croisy, Pascal and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {{Predicting the Health of a Project? An Assessment in a Major IT Company}},
  booktitle = {{8th Seminar on Advanced Techniques \& Tools for Software Evolution (SATToSE'15)}},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon15b-SATToSE-PredictingProjectHealth.pdf},
  hal-url = {https://hal.inria.fr/hal-01205468},
  hal-id = {hal-01205468},
  tagnicolasa = {metric},
  address = {Mons, Belgium},
  annote = {internationalworkshop},
  month = jul,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Project health ; Closed-source ; Data-mining ; Interviews, kzMetric}}

@inproceedings{Blon15c,
  author = {Blondeau, Vincent and Cresson, Sylvain and Croisy, Pascal and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {{Dynamic and Static Approaches Comparison for Test Suite Reduction in Industry}},
  booktitle = {{BENEVOL'15: 14th BElgian-NEtherlands software eVOLution seminar}},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon15c-BENEVOL-TestSuiteReductionComparison.pdf},
  hal-url = {https://hal.inria.fr/hal-01317498},
  hal-id = {hal-01317498},
  tagnicolasa = {other test},
  address = {Lille, France},
  annote = {internationalworkshop},
  month = dec,
  keywords = {lse-pub ;	moose-pub ; pharo-pub ; static; dynamic; test; test selection, kzChecking}}

@article{Blon16a,
  author = {Vincent Blondeau and Anne Etien and Nicolas Anquetil and Sylvain Cresson	and Pascal Croisy and St\'ephane Ducasse},
  title = {Test Case Selection in Industry: An Analysis of Issues Related to Static Approaches},
  journal = {Software Quality Journal},
  pages = {1--35},
  publisher = {Springer Verlag},
  year = {2016},
  doi = {10.1007/s11219-016-9328-4},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon16a-SoftwareQualityJournal-TestCaseSelectionInIndustry.pdf},
  abstract = {Automatic testing constitutes an important part of everyday development practice. Worldline, a major IT company, is creating more and more tests to ensure the good behavior of its applications and gains in efficiency and quality. But running all these tests may take hours. This is especially true for large systems involving, for example, the deployment of a web server or communication with a database. For this reason, tests are not launched as often as they should be and are mostly run at night. The company wishes to improve its development and testing process by giving to developers rapid feedback after a change. An interesting solution is to reduce the number of tests to run by identifying only those exercising the piece of code changed. Two main approaches are proposed in the literature: static and dynamic. The static approach creates a model of the source code and explores it to find links between changed methods and tests. The dynamic approach records invocations of methods during the execution of test scenarios. Before deploying a test case selection solution, Worldline created a partnership with us to investigate the situation in its projects and to evaluate these approaches on three industrial, closed source, cases to understand the strengths and weaknesses of each solution. We propose a classification of problems that may arise when trying to identify the tests that cover a method. We give concrete examples of these problems and list some possible solutions. We also evaluate other issues such as the impact on the results of the frequency of modification of methods or considering groups of methods instead of single ones. We found that solutions must be combined to obtain better results, and problems have different impacts on projects. Considering commits instead of individual methods tends to worsen the results, perhaps due to their large size.},
  annote = {internationaljournal},
  inria = {RMOD},
  issn = {1573-1367},
  hal-url = {https://hal.inria.fr/hal-01344842},
  tagnicolasa = {other test},
  hal-id = {hal-01344842},
  keywords = {lse-pub ; moose-pub ; pharo-pub kzChecking}}

@inproceedings{Blon16b,
  author = {Vincent Blondeau and Nicolas Anquetil and St\'ephane Ducasse and Sylvain Cresson and Pascal Croisy},
  title = {Test Selection with Moose In Industry: Impact of Granularity},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  url = {https://hal.inria.fr/hal-01352468},
  address = {Prague, Czech Republic},
  month = sep,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Industrial case ; Static ; Test selection ; Moose ; Dynamic, kzChecking},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon16b-IWST-TestSelectionWithMoose.pdf},
  hal-id = {hal-01352468},
  tagnicolasa = {other test},
  annote = {internationalworkshop}}

@inproceedings{Blon17a,
  author = {Vincent Blondeau and Anne Etien and Nicolas Anquetil and Sylvain Cresson and Pascal Croisy and St\'ephane Ducasse},
  title = {{What are the Testing Habits of Developers? A Case Study in a Large IT Company}},
  booktitle = {Proceedings of the 21st IEEE International Conference on Software Maintenance and Evolution (ICSME'17)},
  year = {2017},
  hal-url = {https://hal.inria.fr/hal-01571655},
  abstract = {Tests are considered important to ensure the good behavior of applications and improve their quality. But development in companies also involves tight schedules, old habits, less-trained developers, or practical difficulties such as creating a test database. As a result, good testing practices are not always used as often as one might wish. With a major IT company, we are engaged in a project to understand developers testing behavior, and whether it can be improved. Some ideas are to promote testing by reducing test session length, or by running automatically tests behind the scene and send warnings to developers about the failing ones. Reports on developers testing habits in the literature focus on highly distributed open-source projects, or involve students programmers. As such they might not apply to our industrial, closed source, context. In this paper, we take inspiration from experiments of two papers of the literature to enhance our comprehension of the industrial environment. We report the results of a field study on how often the developers use tests in their daily practice, whether they make use of tests selection and why they do. Results are reinforced by interviews with developers involved in the study. The main findings are that test practice is in better shape than we expected; developers select tests " ruthlessly " (instead of launching an entire test suite); although they are not accurate in their selection, and; contrary to expectation, test selection is not influenced by the size of the test suite nor the duration of the tests.},
  address = {Shanghai, China},
  month = aug,
  keywords = {lse-pub ; moose-pub ; pharo-pub ; Industrial case ; Test selection, kzChecking},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Blon17a-ICSME-FinalVersion.pdf},
  hal-id = {hal-01571655},
  tagnicolasa = {other test},
  annote = {topconference internationalconference},
  rate = {27.8\%}}

@phdthesis{Blon17b,
  author = {Vincent Blondeau},
  title = {Test Selection Practices in a Large IT Company},
  year = {2017},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2017-Blondeau.pdf},
  abstract = {Nowadays, Worldline, a major IT company, develops application that are dealing with an increasing amount of critical data with a source code is more and more complex. To the stay in the race against its competitors, Worldline has to increase the quality of its projects. One transversal team of the company has for main mission to enhance project quality. By joining this team, we performed an audit of several projects of the company to identify how to avoid project failure. Relying on project metadata analysis, interviews, survey, and literature study, this audit drew no final conclusion. However, it highlighted a need to enhance testing usage. To test every piece of code is compulsory to avoid project failure. In industry and more specifically in Worldline, automation of tests has begun to ensure the proper behavior of their applications. But, ensuring the execution of all tests after a change can be a costly operation requiring several hours. However, in a daily development process, developers can not run all the tests after a change to check the impact of their modifications. Feedback on the changed code is delayed and developer have to spent time to discover the potential bugs. A late feedback can potentially lead to the failure of a project.
 	The solution generally proposed in literature consists in reducing the number of tests to run by selecting only the ones related to the last changes made by the developer. The approach selects a suitable and small set of tests to detect potential regression in the application behavior.
 	Test selection approaches have their own advantages and drawbacks. These approaches need to be studied in the context of Worldline and consequently adapted to suit developers habits. Before integrating such an adapted test selection approach, a study of the testing behavior of the developers have been done to get their current test selection usage. This study will monitor all the tests launched by the developers during their everyday development tasks. Based on the study of the Worldline environment, we developed a tool for the developers aiming to perform test selection. It is adapted to the developers habits and is directly usable by them. The goal is also to study the impact of this tool on their behavior. We hope that the test selection approach that is packaged in a tool adapted to the Worldline developers will bring a change in their development process.},
  annote = {PhD},
  hal-id = {tel-01661467},
  inria = {RMOD},
  institution = {INRIA},
  keywords = {Software Maintenance, Testing, Automated Test Selection, Industrial, lse-pub},
  hal-url = {http://hal.inria.fr/tel-01661467}}

@inproceedings{Bono14a,
  author = {Bono, Viviana and Mensa, Enrico and Naddeo, Marco},
  title = {Trait-oriented Programming in Java 8},
  booktitle = {PPPJ'14: International Conference on Principles and Practices of Programming on the Java Platform: virtual machines, languages, and tools},
  year = {2014},
  location = {Cracow, Poland},
  annote = {internationalconference},
  hal-id = {hal-01026531}}

@inproceedings{Bour10a,
  author = {Tristan Bourgois and Jannik Laval and St\'ephane Ducasse and Damien Pollet},
  title = {BLOC: a Trait-Based Collections Library - a Preliminary Experience Report},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'10)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Bour10a-IWST10-bloc.pdf},
  abstract = {A trait is a programming construct which provides code reusability. Traits are groups of methods that can be reused orthogonally from inheritance. Traits offer a solution to the problems of multiple inheritance by providing a behavior-centric modularity. Since traits offer an alternative to traditional inheritance-based code reuse, a couple of questions arise. For example, what is a good granularity for a Trait enabling reuse as well as plug ease? How much reuse can we expect on large existing inheritance-based hierarchies?
In this paper we take as case study the Smalltalk Collection hierarchy and we start rewriting it from scratch using traits from the beginning. We show how such library can be built using traits and we report such a preliminary experience. Since the Collection library is large, we focused and built the main classes of the library with Traits and report problems we encountered and how we solved them. Results of this experience are positive and show that we can build new collections based on the traits used to define the new library kernel.},
  address = {Barcelona, Spain},
  annote = {internationalworkshop},
  hal-id = {inria-00511902},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub pharo kzTrait}}

@incollection{Bour13a,
  author = {Noury Bouraqadi and Luc Fabresse},
  title = {Sockets},
  booktitle = {Deep Into Pharo},
  pages = 21,
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@inproceedings{Brag18a,
  author = {Santiago Bragagnolo and Henrique Rocha and Marcus Denker and  St\'ephane Ducasse},
  title = {SmartInspect: solidity smart contract inspector},
  booktitle = {2018 International Workshop on Blockchain Oriented Software Engineering (IWBOSE)},
  pages = {9-18},
  year = {2018},
  doi = {10.1109/IWBOSE.2018.8327566},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Braga18a-IWBOSE-SmartInspect.pdf},
  annote = {internationalworkshop},
  abstract = {Solidity is a language used for smart contracts on the Ethereum blockchain. Smart contracts are embedded procedures stored with the data they act upon. Debugging smart contracts is a really difficult task since once deployed, the code cannot be reexecuted and inspecting a simple attribute is not easily possible because data is encoded. In this paper, we address the lack of inspectability of a deployed contract by analyzing contract state using decompilation techniques driven by the contract structure definition. Our solution, SmartInspect, also uses a mirror-based architecture to represent locally object responsible for the interpretation of the contract state. SmartInspect allows contract developers to better visualize and understand the contract stored state without needing to redeploy, nor develop any ad-hoc code.},
  keywords = {Contracts;Debugging;Indexes;Inspection;Tools;Blockchain;Inspecting;Smart Contracts;Solidity; lse-pub kzBlockchain},
  hal-id = {inria-01831075},
  month = {mar},
  note = {Electronic ISBN: 978-1-5386-5986-1}}

@inproceedings{Brag18b,
  author = {Santiago Bragagnolo and Henrique Rocha and Marcus Denker and  St\'ephane Ducasse},
  title = {Ethereum Query Language},
  booktitle = {1st International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB)},
  pages = {1-8},
  year = {2018},
  doi = {10.1145/3194113.3194114},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Braga18b-WETSEB-Query.pdf},
  annote = {internationalworkshop},
  abstract = {Blockchains store a massive amount of heterogeneous data which
will only grow in time. When searching for data on the Ethereum
platform, one is required to either access the records (blocks) directly
by using a unique identifier, or sequentially search several
records to find the desired information. Therefore, we propose
the Ethereum Query Language (EQL), a query language that allows
users to retrieve information from the blockchain by writing
SQL-like queries. The queries provide a rich syntax to specify data
elements to search information scattered through several records.
We claim that EQL makes it easier to search, acquire, format, and
present information from the blockchain.},
  hal-id = {inria-01831084},
  keywords = {Ethereum;Blockchain;Query Language;SQL; lse-pub kzBlockchain},
  month = {may}}

@inproceedings{Brag19,
  author = {Santiago Bragagnolo and Matte Marra and Guillermo Polito and Elisa Gonzalez Boix},
  title = {Towards Scalable Blockchain Analysis},
  booktitle = {2019 IEEE/ACM 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB)},
  pages = {1-7},
  year = {2019},
  doi = {10.1109/WETSEB.2019.00007},
  annote = {internationalworkshop},
  abstract = {Analysing the blockchain is becoming more and more relevant for detecting attacks and frauds on cryptocurrency exchanges and smart contract activations. However, this is a challenging task due to the continuous growth of the blockchain. For example, in early 2017 Ethereum was estimated to contain approximately 300GB of data [1], a number that keeps growing day after day. In order to analyse such ever-growing amount of data, this paper argues that blockchain analysis should be treated as a novel type of application for Big Data platforms. In this paper we explore the application of parallelization techniques from the Big Data domain, in particular Map/Reduce, to extract and analyse information from the blockchain. We show that our approach significantly improves the index generation by 7.77 times, with a setup of 20 worker nodes, 1 Ethereum node and 1 Database node. We also share our findings of our massively parallel setup for querying Ethereum in terms of architecture and the bottlenecks. This should help researchers setup similar infrastructures for analysing the blockchain in the future.}}

@booklet{Bran17d,
  author = {John Brant and Jason Lecerf and Thierry Goubier and St\'ephane Ducasse and Black, Andrew P.},
  title = {Smacc: a Compiler-Compiler},
  pages = {44},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org/booklet-Smacc/},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo Technology Collection},
  keywords = {skipdoi kzPharo kzTools lse-pub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-10-21-Smacc-Compiler.pdf},
  hal-id = {hal-01612820}}

@book{Brif01a,
  author = {Xavier Briffault and St\'ephane Ducasse},
  title = {Squeak},
  publisher = {Eyrolles, Paris},
  year = {2001},
  annote = {book},
  keywords = {smalltalk squeak kzSmalltalk},
  month = nov}

@techreport{Brun09a,
  author = {Camillo Bruni and Toon Verwaest and Marcus Denker},
  title = {{PyGirl}: Generating Whole-System {VM}s from high-level models using {PyPy}},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Brun09a-TechReport-PyGirl.pdf},
  abstract = {Virtual machines emulating hardware devices are generally implemented in low-level languages and using a low-level style for performance reasons. This trend results in largely difficult to understand, difficult to extend and unmaintainable systems. As new general techniques for virtual machines arise, it gets harder to incorporate or test these techniques because of early design and optimization decisions. In this paper we show how such decisions can be postponed to later phases by separating virtual machine implementation issues from the high-level machine-specific model. We construct compact models of whole-system VMs in a high-level language, which exclude all low-level implementation details. We use the pluggable translation toolchain PyPy to translate those models to executables. During the translation process, the toolchain reintroduces the VM implementation and optimization details for specific target platforms.	As a case study we implement an executable model of a hardware gaming device. We show that our approach to VM building increases understandability, maintainability and extendability while preserving performance.},
  annote = {report notrefereed},
  institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
  keywords = {scg09 scg-pub jb09 snf09 skip-doi tverwaes marcusdenker fromscgbib},
  number = {IAM-09-002},
  type = {Technical Report}}

@inproceedings{Brun13a,
  author = {Camillo Bruni and Luc Fabresse and St\'ephane Ducasse and Igor Stasenko},
  title = {Language-side Foreign Function Interfaces with NativeBoost},
  booktitle = {International Workshop on Smalltalk Technologies 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Brun13a-NativeBoostIWST.pdf},
  abstract = {Foreign-Function-Interfaces (FGirb1FIs) are a prerequisite for close system integration of a high-level language. With FFIs the high-level environment interacts with low-level functions allowing for a unique combination of features. This duality has a strong impact on the implementation of the FFI: it has to be flexible and fast at the same time.
	We propose NativeBoost a language-side approach to FFIs that only requires minimal changes to the VM. NativeBoost directly creates specific native code at language-side and thus combines the flexibility of a language-side library with the performance of a native plugin.},
  annote = {internationalworkshop},
  hal-id = {hal-00840781},
  keywords = {pharo stefPub kzVM kzInfrastructure lse-pub}}

@incollection{Brun13b,
  author = {Camillo Bruni},
  title = {Zero Configuration Scripts and Command-Line Handlers},
  booktitle = {Deep Into Pharo},
  pages = 8,
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@inproceedings{Brun14a,
  author = {Camillo Bruni and Luc Fabresse and St\'ephane Ducasse and Igor Stasenko},
  title = {Benzo: Reflective Glue for Low-level Programming},
  booktitle = {International Workshop on Smalltalk Technologies 2014},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Brun14a-IWST-Benzo.pdf},
  abstract = {The goal of high-level low-level programming is to bring the abstraction capabilities of high-level languages to the system programming domain, such as virtual machines (VMs) and language runtimes. However, existing solutions are bound to compilation time and expose limited possibilities to be changed at runtime and from language-side. They do not fit well with fully reflective languages and environments.
We propose Benzo1, a lightweight framework for high- level low-level programming that allows developers to gen- erate and execute at runtime low-level code (assembly). It promotes the implementation, and dynamic modification, of system components with high-level language tools outper- forming existing dynamic solutions.
Since Benzo is a general framework we choose three ap- plications that cover an important range of the spectrum of system programming for validating the infrastructure: a For- eign Function Interface (FFI), primitives instrumentation and a just-in-time bytecode compiler (JIT). With Benzo we show that these typical VM-level components are feasible as reflective language-side implementations. Due to its unique combination of high-level reflection and low-level program- ming, Benzo shows better performance for these three ap- plications than the comparable high-level implementations.},
  annote = {internationalworkshop},
  hal-url = {http://hal.inria.fr/hal-01060551},
  hal-id = {hal-01060551},
  keywords = {pharo stefPub kzInfrastructure kzVM lse-pub}}

@phdthesis{Brun14b,
  author = {Camillo Bruni},
  title = {Towards Self-aware Virtual Machines},
  year = {2014},
  school = {University Lille 1 - Sciences et Technologies - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2014-Bruni.pdf},
  hal-id = {tel-01097323v1},
  abstract = {High-level languages implement reflection which allows a language runtime to inspect and alter its own execution and state. These high-level languages typically run on top of virtual machines (vms) which have been built to create an abstraction layer over hardware. Due to the isolating nature of the vm, reflection is generally limited to the language-side. Several research vms overcome this separation and provide a unified model where there is no more a clear distinction between language-side and vm-side. In such a language runtime it is possible to reflectively modify vm components from language-side as they reside on the same abstraction layer. In this dissertation we follow the same global direction towards a unified language-runtime or self-aware vm. However, instead of looking for a holistic solution we focus on a minimal approach. Instead of using a custom tailored language runtime we use dynamic native code activation from language-side on top of an existing vm. We first present Benzo our framework for dynamic native code activation. Benzo provides a generic but low-level interface to the vm internals. Based on this framework we then evaluate several applications that typically require direct vm support. We show first how Benzo is used to build an efficient ffi interface, allowing for a more structured access to vm internal functions. To evaluate the limitations of Benzo we target two more applications: dynamic primitives and a language-side jit compiler. Both of them require a tight interaction with the underlying vm.},
  month = {may},
  keywords = {lse-pub}}

@inproceedings{Casa09a,
  author = {Gwena{\"e}l Casaccio and Damien Pollet and Marcus Denker and St\'ephane Ducasse},
  title = {Object Spaces for Safe Image Surgery},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'09)},
  pages = {77-81},
  publisher = {ACM digital library},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Casa09a-IWST09-ObjectSpaces.pdf},
  abstract = {Long-lived systems rely on reflective self-modification to evolve. Unfortunately, since such a system is at both ends of a causal loop, this means modifications that impact the reflective layer itself can be overly difficult to apply. This paper introduces ObjectSpaces, a reification of the familiar Smalltalk image as a first-class entity. By confining the system inside an ObjectSpace, we isolate the evolution tools from it, while still giving them reflective access to the confined system.	We describe the ObjectSpaces idea, the interface to communicate, inspect, and debug objects contained inside and ObjectSpace, based on a prototype implementation in GNU Smalltalk.},
  address = {New York, USA},
  keywords = {marcusdenker lse-pub kzModule}}

@inproceedings{Casa11a,
  author = {Gwenael Casaccio and St\'ephane Ducasse and Luc Fabresse and Jean-Baptiste Arnaud and van Ryseghem, Benjamin},
  title = {Bootstrapping a Smalltalk},
  booktitle = {Proceedings of Smalltalks 2011 International Workshop},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Casa11a-Smalltalks-BootstrappingASmalltalk.pdf},
  abstract = {Smalltalk is a reflective system. It means that it is defined in itself in a causally connected way. Traditionally, Smalltalk systems evolved by modifying and cloning what is called an image (a chunk of memory containing all the objects at a given point in time). During the evolution of the system, objects representing it are modified. However, such an image modification and cloning poses several problems: (1) There is no operational machine-executable algorithm that allows one to build a system from scratch. A system object may be modified but it may be difficult to reproduce its exact state before the changes. Therefore it is difficult to get a reproducible process. (2) As a consequence, certain classes may not have been initialized since years. (3) Finally, since the system acts as a living system, it is not simple to evolve the kernel for introducing new abstractions without performing some kind of brain surgery on oneself. There is a need to have a step by step process to build Smalltalk kernels from scratch. In this paper, after an analysis of past and current practices to mutate or generate kernels, we describe a kernel bootstrap process step-by-step. First the illusion of the existence of a kernel is created via stubs objects. Second the classes and meta-classes hierarchy are generated. Code is compiled and finally information needed by the virtual machine and execution are generated and installed.},
  address = {Bernal, Buenos Aires, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00636785},
  keywords = {pharo-pub lse-pub raweb2011 kzReflection}}

@inproceedings{Cass07a,
  author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
  title = {Redesigning with Traits: the {Nile} Stream trait-based Library},
  booktitle = {ICDL'07: Proceedings of the 15th International Conference on Dynamic Languages},
  pages = {50--75},
  publisher = {ACM Digital Library},
  year = {2007},
  doi = {10.1145/1352678.1352682},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass07a-TraitsStreamRedesign-ICDL.pdf},
  abstract = {Recently, traits have been proposed as a single inheritance backward compatible solution in which the composing entity has the control over the trait composition. Traits are fine-grained units used to
 compose classes, while avoiding many of the problems
 of multiple inheritance and mixin-based approaches.
 To evaluate the expressiveness of traits, some
 hierarchies were refactored, showing code reuse.
 However, such large refactorings, while valuable,
 may not be facing all the problems, since the
 hierarchies were previously expressed within single
 inheritance and following certain patterns. We
 wanted to evaluate how traits enable reuse, and what
 problems could be encountered when building a
 library using traits from scratch, taking into
 account that traits are units of reuse. This paper
 presents our work on designing a new stream library
 named Nile. We present the reuse that we attained
 using traits, and the problems we encountered.},
  address = {Lugano, Switzerland},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {nile cook kzTrait},
  month = aug,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass07aTraitsStreamRedesign-ICDL.pdf}}

@mastersthesis{Cass07b,
  author = {Damien Cassou},
  title = {Remodularisation \`a base de traits},
  year = {2007},
  school = {University of Bordeaux},
  pdf = {http://rmod-files.lille.inria.fr/Team/Masters/Cass07b.pdf},
  abstract = {R\'ecemment, les traits ont propos\'e un solution
 compatible avec l'h\'eritage simple dans lequel
 l'entit\'e qui compose a le contr\^ole sur la
 composition. Les traits sont des \'el\'ements \`a
 granularit\'e fine qui permettent la composition de
 classes, mais qui \'evite la plupart des probl\`emes
 pos\'es par l'h\'eritage multiple et les approches
 bas\'ees sur les mixins. Pour \'evaluer
 l'efficacit\'e des traits, des biblioth\`eques ont
 \'et\'e refactoris\'ees, montrant une
 r\'eutilisation importante du code. Cependant, bien
 que ces travaux soient int\'eressants, ils ne
 permettent pas de rencontrer tous les probl\`emes
 d'utilisation des traits ; ceci parce que les
 biblioth\`eques d'origines \'etaient r\'ealis\'ees
 et pens\'ees avec les contraintes de l'h\'eritage
 simple. Nous souhaitons \'evaluer l'expressivit\'e
 des traits lors de la r\'ealisation d'un projet
 complet, en se servant des traits comme unit\'e de
 r\'eutilisation de comportement. Ce document
 pr\'esente le design d'une nouvelle biblioth\`eque
 de streams appel\'ee Nile. Nous pr\'esentons les
 traits que nous avons d\'efinis et leur
 r\'eutilisabilit\'e ainsi que les probl\`emes
 auxquels nous avons fait face.},
  annote = {master},
  keywords = {nile cook},
  month = aug,
  pdf-second = {http://scg.unibe.ch/archive/external/Cass07b.pdf}}

@article{Cass09a,
  author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
  title = {Traits at Work: the design of a new trait-based stream library},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {35},
  pages = {2--20},
  publisher = {Elsevier},
  year = {2009},
  impactfactor = {Impact factor (2010) 0.619},
  doi = {10.1016/j.cl.2008.05.004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass08a-ComputerLanguages-NileNewKernel.pdf},
  abstract = {Recent years saw the development of a composition
 mechanism called Traits. Traits are pure units of
 behavior that can be composed to form classes or
 other traits. The trait composition mechanism is an
 alternative to multiple or mixin inheritance in
 which the composer has full control over the trait
 composition. To evaluate the expressiveness of
 traits, some hierarchies were refactored, showing
 code reuse. However, such large refactorings, while
 valuable, may not exhibit all possible composition
 problems, since the hierarchies were previously
 expressed using single inheritance and following
 certain patterns. This paper presents our work on
 designing and implementing a new trait-based stream
 library named Nile. It evaluates how far traits
 enable reuse, what problems can be encountered when
 building a library using traits from scratch and
 compares the traits solution to alternative
 composition mechanisms. Nile's core allows the
 definition of compact collection and file streaming
 libraries as well as the implementation of a
 backward-compatible new stream library. Nile method
 size shows a reduction of 40\% compared to the Squeak
 equivalent. The possibility to reuse the same set of
 traits to implement two distinct libraries is a
 concrete illustration of trait reuse capability.},
  annote = {internationaljournal},
  hal-id = {inria-00216108},
  keywords = {kzTrait},
  number = {1},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cass08a-NileNewKernel-ComputerLanguages.pdf}}

@techreport{Cass13a,
  author = {Cassou, Damien and Ducasse, St\'ephane and Petton, Nicolas},
  title = {{SafeJS}: Hermetic Sandboxing for JavaScript},
  pages = {7},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Cass13a-Resilience-SafeJS.pdf},
  abstract = {Isolating programs is an important mechanism to
 support more secure applications. Isolating program
 in dynamic languages such as JavaScript is even more
 challenging since reflective operations can
 circumvent simple mechanisms that could protect
 program parts. In this article we present SafeJS, an
 approach and implementation that offers isolation
 based on separate sandboxes and control of
 information exchanged between them. In SafeJS,
 sandboxes based on web workers do not share any
 data. Data exchanged between sandboxes is solely
 based on strings. Using different policies, this
 infrastructure supports the isolation of the
 different scripts that usually populate web pages. A
 foreign component cannot modify the main DOM tree in
 unexpected manner. Our SafeJS implementation is
 currently being used in an industrial setting in the
 context of the Resilience FUI 12 project.},
  affiliation = {RMoD - Inria Lille-Nord Europe , Laboratoire d'Informatique Fondamentale de Lille - LIFL},
  annote = {techreport},
  hal-id = {hal-00862099},
  institution = {Inria},
  keywords = {sandboxing javascript web worker DOM isolation lse-pub stefPub kzLanguageDesign},
  language = {Anglais},
  month = sep}

@book{Cass15a,
  author = {Damien Cassou and St\'ephane Ducasse and Luc Fabresse and Johan Fabry and Van Caekenberghe, Sven},
  title = {Enterprise Pharo: a Web Perspective},
  pages = {278},
  publisher = {Square Bracket Associates},
  year = {2015},
  url = {http://books.pharo.org},
  annote = {book},
  hal-id = {hal-01223026}}

@inproceedings{Cast12a,
  author = {Castro, Sergio and Gonz\'{a}lez, Sebasti\'{a}n and Mens, Kim and Denker, Marcus},
  title = {DynamicSchema: a lightweight persistency framework for context-oriented data management},
  booktitle = {Proceedings of the International Workshop on Context-Oriented Programming},
  pages = {5:1--5:6},
  publisher = {ACM},
  year = {2012},
  doi = {10.1145/2307436.2307441},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cast12-COP12-DynamicSchema.pdf},
  acmid = {2307441},
  address = {New York, NY, USA},
  annote = {internationalworkshop},
  hal-id = {hal-00720348},
  isbn = {978-1-4503-1276-9},
  keywords = {lse-pub raweb2012},
  location = {Beijing, China},
  numpages = {6},
  series = {COP '12}}

@incollection{Cell13a,
  author = {Nicolas Cellier and St\'ephane Ducasse},
  title = {Fun with Floats},
  booktitle = {Deep Into Pharo},
  pages = 10,
  publisher = {Square Bracket Associates},
  year = {2013},
  url = {http://books.pharo.org},
  isbn = {978-3-9523341-6-4},
  annote = {articlebook},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming, kzVulgarisation},
  month = sep}

@techreport{Char13a,
  author = {Chari, Guido and Garbervetsky, Diego and Bruni, Camillo and Denker, Marcus and Ducasse, St\'ephane},
  title = {Waterfall: Primitives Generation on the Fly},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Char13a-Waterfall.pdf},
  annote = {techReport},
  institution = {Inria},
  abstract = {Modern languages are typically supported by managed runtimes (Virtual Machines). Since VMs have to deal with many concepts such as memory management, abstract execution model and scheduling, they tend to be very complex. Additionally, VMs have to meet strong performance requirements. This demand of performance is one of the main reasons why many VMs are built statically. Thus, design decisions are frozen at compile time preventing changes at runtime. One clear example is the impossibility to dynamically adapt or change primitives of the VM once it has been compiled. In this work we present a toolchain that allows for altering and configuring components such as primitives and plug-ins at runtime. The main contribution is Waterfall, a dynamic and reflective translator from Slang, a restricted subset of Smalltalk, to native code. Waterfall generates primitives on demand and executes them on the fly. We validate our approach by implementing dynamic primitive modification and runtime customization of VM plug-ins.},
  affiliation = {Laboratory on Foundations and Tools for Software Engineering - LAFHIS , RMOD - INRIA Lille - Nord Europe},
  hal-id = {hal-00871353},
  month = {sep},
  keywors = {lse-pub},
  hal-pdf = {http://hal.inria.fr/hal-00871353/PDF/Waterfall.pdf}}

@inproceedings{Char15a,
  author = {Guido Chari and Diego Garbervetsky and Stefan Marr and St\'ephane Ducasse},
  title = {Towards Fully Reflective Environments},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Char15a-Onward-ReflectiveVM.pdf},
  abstract = {Modern development environments promote live programming (LP) mechanisms because it enhances the development experience by providing instantaneous feedback and interaction with live objects. LP is typically supported with advanced reflective techniques within dynamic languages. These languages run on top of Virtual Machines (VMs) that are built in a static manner so that most of their components are bound at compile time. As a consequence, VM developers are forced to work using the traditional edit-compile-run cycle, even when they are designing LP-supporting environments. In this paper we explore the idea of bringing LP techniques to VM development to improve the observabil-ity, evolution and adaptability of VMs at run-time. We define the notion of fully reflective execution environments , systems that provide reflection not only at the application level but also at the level of the execution environment (EE). We characterize such systems, propose a design, and present Mate v1, a prototypical implementation. Based on our prototype, we analyze the feasibility and applicability of incorporating reflective capabilities into different parts of EEs. Furthermore, the evaluation demonstrates the opportunities such reflective capabilities provide for unanticipated dynamic adaptation scenarios, benefiting thus, a wider range of users.},
  annote = {internationalconference},
  hal-id = {hal-01185843},
  keywords = {kzReflection kzLanguageDesign stefPub lse-pub},
  numpages = {10}}

@article{Char18a,
  author = {Chari, Guido and Garbervetsky, Diego and Marr, Stefan and Ducasse, St\'ephane},
  title = {Fully Reflective Execution Environments: Virtual Machines for More Flexible Software},
  journal = {Transaction on Software Engineering},
  year = {2018},
  doi = {10.1109/TSE.2018.2812715},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Char18a-preprint-TSE-ReflectiveExecutionEnvironments.pdf},
  abstract = {VMs are complex pieces of software that implement programming language semantics in an efficient, portable, and secure way. Unfortunately, mainstream VMs provide applications with few mechanisms to alter execution semantics or memory management at run time. We argue that this limits the evolvability and maintainability of running systems for both, the application domain, e.g., to support unforeseen requirements, and the VM domain, e.g., to modify the organization of objects in memory. This work explores the idea of incorporating reflective capabilities into the VM domain and analyzes its impact in the context of software adaptation tasks. We characterize the notion of a fully reflective VM, a kind of VM that provides means for its own observability and modifiability at run time. This enables programming languages to adapt the underlying VM to changing requirements. We propose a reference architecture for such VMs and present TruffleMATE as a prototype for this architecture. We evaluate the mechanisms TruffleMATE provides to deal with unanticipated dynamic adaptation scenarios for security, optimization, and profiling aspects. In contrast to existing alternatives, we observe that TruffleMATE is able to handle all scenarios, using less than 50 lines of code for each, and without interfering with the application's logic.},
  annote = {internationaljournal},
  hal-id = {hal-01728111},
  keywords = {StePub kzLanguageDesign kzVM lse-pub},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Char18a-preprint-TSE-ReflectiveExecutionEnvironments.pdf}}

@article{Chis15c,
  author = {Andrei Chis and Marcus Denker and Tudor Girba and Oscar Nierstrasz},
  title = {Practical domain-specific debuggers using the Moldable Debugger framework},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {44},
  pages = {89-113},
  publisher = {Elsevier},
  year = {2015},
  doi = {10.1016/j.cl.2015.08.005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Chis15c-PracticalDomainSpecificDebuggers.pdf},
  abstract = {Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.},
  annote = {internationaljournal},
  hal-id = {inria-01247941},
  keywords = {marcusdenker lse-pub}}

@inproceedings{Cost17a,
  author = {Costiou, Steven and Kerboeuf, Micka\"{e}l and Denker, Marcus and Plantec, Alain},
  title = {Unanticipated Debugging with Dynamic Layers},
  booktitle = {{LASSY'17} - Companion to the First International Conference on the Art, Science and Engineering of Programming},
  pages = {14:1--14:6},
  publisher = {ACM},
  year = {2017},
  doi = {10.1145/3079368.3079391},
  series = {Programming '17},
  isbn = {978-1-4503-4836-2},
  location = {Brussels, Belgium},
  articleno = {14},
  numpages = {6},
  acmid = {3079391},
  address = {New York, NY, USA},
  keywords = {Dynamic Layers, Dynamic behavior adaptation, Runtime debugging},
  annote = {internationalworkshop},
  keywords = {Dynamic Layers, Dynamic behavior adaptation, Runtime debugging},
  hal-id = {hal-01591077}}

@inproceedings{Cost18a,
  author = {Costiou, Steven and Kerboeuf, Mickael and Plantec, Alain and Denker, Marcus},
  title = {Collectors},
  booktitle = {{PX'18 - Programming Experience 2018}},
  pages = {9},
  publisher = {{ACM Press}},
  year = {2018},
  url = {http://hal.univ-brest.fr/hal-01829183},
  doi = {10.1145/3191697.3214335},
  isbn = {978-1-4503-5513-1},
  abstract = {Observing and modifying object-oriented programs often means interacting with objects. At runtime, it can be a complex task to identify those objects due to the live state of the program. Some objects may exist for only a very limited period of time, others can be hardly reachable because they are never stored in variables. To address this problem we present Collectors. They are dedicated objects which can collect objects of interest at runtime and present them to the developer. Collectors are non-intrusive, removable code instrumentations. They can be dynamically specified and injected at runtime. They expose an API to allow their specification and the access to the collected objects. In this paper, we present an implementation of Collectors in Pharo, a Smalltalk dialect. We enrich the Pharo programming and debugging environment with tools that support the Collectors API. We illustrate the use of these API and tools through the collection and the logging of specific objects in a running IOT application.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cost18a-PX-Collectors.pdf},
  address = {Nice, France},
  series = {Companion of the 2nd International Conference on Art, Science, and Engineering of Programming},
  month = apr,
  hal-id = {hal-01829183},
  keywords = {lse-pub}}

@phdthesis{Cost18b,
  author = {Costiou, Steven},
  title = {{Unanticipated behavior adaptation : application to the debugging of running programs}},
  year = {2018},
  school = {{Universit{\'e} de Bretagne occidentale - Brest}},
  url = {https://tel.archives-ouvertes.fr/tel-02082447},
  number = {2018BRES0069},
  month = nov,
  keywords = {Unanticipated debugging ; Behavior adaptation ; Dynamic object-centric adaptation ; D{\'e}verminage non-anticip{\'e} ; Adaptation de comportement ; Adaptation dynamique centr{\'e}e objet},
  type = {Theses},
  pdf = {https://tel.archives-ouvertes.fr/tel-02082447/file/These-2018-MATHSTIC-Informatique-COSTIOU_Steven.pdf},
  hal-id = {tel-02082447}}

@article{Cost20a,
  author = {Costiou, Steven and Aranega, Vincent and Denker, Marcus},
  title = {{Sub-method, partial behavioral reflection with Reflectivity: Looking back on 10 years of use}},
  journal = {{The Art, Science, and Engineering of Programming}},
  volume = {4},
  publisher = {{aosa, Inc.}},
  year = {2020},
  doi = {10.22152/programming-journal.org/2020/4/5},
  hal-url = {https://hal.inria.fr/hal-02480136},
  number = {3},
  month = feb,
  hal-id = {hal-02480136}}

@inproceedings{Cout12a,
  author = {Cesar Couto and Christofer Silva and Marco T. Valente and Roberto Bigonha and Nicolas Anquetil},
  title = {Uncovering Causal Relationships between Bugs and Software Metrics},
  booktitle = {Proceedings of the 16th European Conference on Software Maintenance and Reengineering (CSMR'12)},
  year = {2012},
  misc = {acceptance rate: 30/108 = 28\%},
  abstract = {Abstract-Bug prediction is an important challenge for software engineering research. It consist in looking for possible early indicators of the presence of bugs in a software. However, despite the relevance of the issue, most experiments designed to evaluate bug prediction only investigate whether there is a linear relation between the predictor and the presence of bugs. However, it is well known that standard regression models can not filter out spurious relations. Therefore, in this paper we describe an experiment to discover more robust evidences towards causality between software metrics (as predictors) and the occurrence of bugs. For this purpose, we have relied on Granger Causality Test to evaluate whether past changes in a given time series are useful to forecast changes in another series. As its name suggests, Granger Test is a better indication of causality between two variables. We present and discuss the results of experiments on four real world systems evaluated over a time frame of almost four years. Particularly, we have been able to discover in the history of metrics the causes --- in the terms of the Granger Test --- for 64\% to 93\% of the defects reported for the systems considered in our experiment.},
  annote = {internationalconference},
  hal-id = {hal-00668151},
  keywords = {moose lse-pub raweb2012},
  tagnicolasa = {metric}}

@inproceedings{Cout13a,
  author = {Cesar Couto and Pedro Pires and Marco T\'ulio Valente and Roberto Bigonha and Andre Hora and Nicolas Anquetil},
  title = {BugMaps-Granger: A Tool for Causality Analysis between Source Code Metrics and Bugs},
  booktitle = {Proceedings of the 4th Brazilian Conference on Software: Theory and Practice (CBSoft'13)},
  year = {2013},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cout13a-BugMapsGranger-CBSoft13.pdf},
  abstract = {Despite the increasing number of bug analysis tools for exploring bugs in software systems, there are no tools supporting the investigation of causality relationships between internal quality metrics and bugs. In this paper, we propose an extension of the BugMaps tool called BugMaps-Granger that allows the analysis of source code properties that caused bugs. For this purpose, we relied on Granger Causality Test to evaluate whether past changes to a given time series of source code metrics can be used to forecast changes in a time series of defects. Our tool extracts source code versions from version control platforms, generates source code metrics and defects time series, computes Granger, and provides interactive visualizations for causal analysis of bugs. We also provide a case study in order to evaluate the tool.},
  annote = {tooldemo},
  hal-id = {hal-00854883},
  inriareport = {2013},
  keywords = {moose lse-pub kzVisualization},
  tagnicolasa = {metric},
  annote = {tooldemo}}

@article{Cout14a,
  author = {Cesar Couto and Pedro Pires and Marco T\'ulio Valente and Roberto da Silva Bigonha and Nicolas Anquetil},
  title = {Predicting software defects with causality tests},
  journal = {Journal of Systems and Software (JSS)},
  volume = {93},
  pages = {24--41},
  year = {2014},
  impactfactor = {Impact Factor (2013) 1.245},
  url = {http://dx.doi.org/10.1016/j.jss.2014.01.033},
  doi = {10.1016/j.jss.2014.01.033},
  annote = {internationaljournal},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl = {http://dblp.uni-trier.de/rec/bib/journals/jss/CoutoPVBA14},
  hal-id = {hal-01086783},
  issn = {0164-1212},
  tagnicolasa = {metric}}

@article{Cout14b,
  author = {Cesar Couto and Marco T\'ulio Valente and Pedro Pires and Andr\'e Hora and Nicolas Anquetil and Roberto S. Bigonha},
  title = {BugMaps-Granger: a tool for visualizing and predicting bugs using Granger causality tests},
  journal = {Journal of Software Engineering Research and Development},
  volume = {2},
  pages = {1},
  publisher = {Springer},
  year = {2014},
  impactfactor = {Impact Factor (2011) 0.130},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cout14b-BugMapsGranger-jserd.pdf},
  annote = {internationaljournal},
  hal-id = {hal-01003078},
  issn = {0218-1940},
  number = {1},
  tagnicolasa = {metric}}

@inproceedings{Cout17a,
  author = {Christian Marlon Souza Couto and Henrique Rocha and Ricardo Terra},
  title = {{Quality-oriented Move Method Refactoring}},
  booktitle = {{BENEVOL'15: 14th BElgian-NEtherlands software
 eVOLution seminar}},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01663666},
  abstract = {Restructuring is an important activity to improve software internal structure. Even though there are many restructuring approaches, very few consider the refactoring impact on the software quality. In this paper, we propose an semi-automatic software restructuring approach based on quality attributes. We rely on the measurements of the Quality Model for Object Oriented Design (QMOOD) to recommend Move Method refactorings that improve software quality. In a nutshell , given a software system S, our approach recommends a sequence of refactorings R1, R2,. .. , Rn that result in system versions S1, S2,. .. , Sn, where quality(Si+1) > quality(Si). We empirically calibrated our approach to find the best criteria to measure the improvement of quality. In our preliminary evaluation on three open-source systems, our approach achieved an average recall of 57\%.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cout17a-BENEVOL-MoveMethod.pdf},
  address = {Lille, France},
  annote = {internationalworkshop},
  month = dec,
  keywords = {lse-pub},
  hal-id = {hal-01663666}}

@inproceedings{Cout18a,
  author = {Couto, Christian Marlon Souza and Rocha, Henrique and Terra, Ricardo},
  title = {A Quality-oriented Approach to Recommend Move Method Refactorings},
  booktitle = {17th Brazilian Symposium on Software Quality},
  pages = {11--20},
  publisher = {ACM},
  year = {2018},
  url = {http://doi.acm.org/10.1145/3275245.3275247},
  doi = {10.1145/3275245.3275247},
  abstract = {Refactoring is an important activity to improve software internal structure. Even though there are many refactoring approaches, very few consider their impact on the software quality. In this paper, we propose a software refactoring approach based on quality attributes. We rely on the measurements of the Quality Model for Object Oriented Design (QMOOD) to recommend Move Method refactorings that improve software quality. In a nutshell, given a software system S, our approach recommends a sequence of refactorings R1,R2,...,Rn that result in system versions S1, S2,..., Sn, where quality (Si+1) > quality (Si). We empirically calibrated our approach, using four systems, to find the best criteria to measure the quality improvement. We performed three types of evaluation to verify the usefulness of our implemented tool, named QMove. First, we applied our approach on 13 open-source systems achieving an average recall of 84.2%. Second, we compared QMove with two state-of-art refactoring tools (JMove and JDeodorant) on the 13 previously evaluated systems, and QMove showed better recall, precision, and f-score values than the others. Third, we evaluated QMove, JMove, and JDeodorant in a real scenario with two proprietary systems on the eyes of their software architects. As result, the experts positively evaluated a greater number of QMove recommendations.},
  series = {SBQS},
  isbn = {978-1-4503-6565-9},
  location = {Curitiba, Brazil},
  numpages = {10},
  hal-id = {hal-01944493},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cout18a-SBQS-QualitedOrientedApproachforMoveMethod.pdf},
  acmid = {3275247},
  address = {New York, NY, USA},
  keywords = {Move Method, Quality Metrics, Refactoring, Software Architecture, lse-pub}}

@inproceedings{Cruz99a,
  author = {Juan-Carlos Cruz and St\'ephane Ducasse},
  title = {A Group Based Approach for Coordinating Active Objects},
  booktitle = {Proceedings of Coordination'99},
  volume = {1594},
  pages = {355--371},
  publisher = {Springer-Verlag},
  year = {1999},
  misc = {Core A},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99a-GroupBasedApproach.pdf},
  abstract = {Although coordination of concurrent objects is a fundamental aspect of object-oriented concurrent programming, there is only little support for its specification and abstraction at the language level.	This is a problem because coordination is often buried in the code of the coordinated objects, leading to a lack of abstraction and reuse. Here we present CoLaS, a coordination model and its implementation based on the notion of Coordination Groups. By clearly identifying and separating the coordination from the co-ordinated objects CoLaS provides a better abstraction and reuse of the coordination and the coordinated objects. Moreover CoLaS's high dynamicity provides better support for coordination of active objects.},
  annote = {internationalconference},
  keywords = {kzLanguageDesign kzCoordination},
  series = {LNCS},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99aGroupBasedApproach.pdf}}

@inproceedings{Cruz99b,
  author = {Juan-Carlos Cruz and St\'ephane Ducasse},
  title = {Coordinating Open Distributed Systems},
  booktitle = {Proceedings of International Workshop in Future Trends in Distributed Computing Systems '99},
  year = {1999},
  doi = {10.1109/FTDCS.1999.818794},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99-FTDCS.pdf},
  abstract = {Open Distributed Systems are the dominating intellectual issue of the end of this century.	Figuring out how to build those systems will become a central issue in distributed system research in the next future. Although CORBA seems to provide all the necessary support to construct those systems. It provides a very limited support to the evolution of requirements in those systems. The main problem is that the description of the elements from which systems are built, and the way in which they are composed are mixed into the application code. Making them difficult to understand, modify and customize.	We think that a solution to this problem goes through the introduction of the so called coordination models and languages into the CORBA model. We propose in this paper the introduction of our object coordination model called CoLaS into the CORBA model.},
  annote = {internationalworkshop},
  keywords = {stefPub kzLanguageDesign kzCoordination},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cruz99FTDCS.pdf}}

@inproceedings{Cuts09a,
  author = {van Cutsem, Tom and Alexandre Bergel and St\'ephane Ducasse and De Meuter, Wolfgang},
  title = {Adding State and Visibility Control to Traits using Lexical Nesting},
  booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'09)},
  publisher = {Springer},
  year = {2009},
  misc = {21\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Cuts09a-ECOOP09-Traits.pdf},
  abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits.
This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.},
  address = {London, UK},
  annote = {internationalconference topconference},
  editor = {Sophia Drossopoulou},
  hal-id = {inria-00498397},
  keywords = {traits alexPub stefPub kzTrait},
  rate = {21\%},
  series = {Lecture Notes in Computer Science}}

@inproceedings{DeWa15a,
  author = {De Wael, Mattias and Marr, Stefan and De Koster, Joeri and Sartor, Jennifer B. and De Meuter, Wolfgang},
  title = {Just-in-Time Data Structures},
  booktitle = {Onward! 2015},
  year = {2015},
  abstract = {Today, software engineering practices focus on finding the single right data representation (i.e., data structure) for a program. The right data representation, however, might not exist: relying on a single representation of the data for the lifetime of the program can be suboptimal in terms of performance. We explore the idea of developing data structures for which changing the data representation is an intrinsic property. To this end we introduce Just-in-Time Data Structures, which enable representation changes at runtime, based on declarative input from a performance expert programmer. Just-in-Time Data Structures are an attempt to shift the focus from finding the right data structure to finding the right sequence of data representations. We present JitDS-Java, an extension to the Java language, to develop Just-in-Time Data Structures. Further, we show two example programs that benefit from changing the representation at runtime.},
  annote = {internationalconference},
  hal-id = {hal-01205343},
  inria = {RMOD},
  keywords = {Algorithms DataStructures DynamicReclassification Optimizations Performance},
  numpages = {10},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/DaWa15a-Onward-Just-in-Time-Data-Structures.pdf}}

@article{DeWa16a,
  author = {De Wael, Mattias and Marr, Stefan and De Fraine, Bruno and Van Cutsem, Tom and De Meuter, Wolfgang},
  title = {Partitioned Global Address Space Languages},
  journal = {ACM Comput. Surv.},
  publisher = {ACM},
  year = {2016},
  url = {http://stefan-marr.de/papers/acm-csur-de-wael-et-al-partitioned-global-address-space-languages/},
  abstract = {The Partitioned Global Address Space (PGAS) model is a parallel programming model that aims to improve programmer productivity while at the same time aiming for high performance. The main premise of PGAS is that a globally shared address space improves productivity, but that a distinction between local and remote data accesses is required to allow performance optimizations and to support scalability on large-scale parallel architectures. To this end, PGAS preserves the global address space while embracing awareness of non-uniform communication costs.
Today, about a dozen languages exist that adhere to the PGAS model. This survey proposes a definition and a taxonomy along four axes: how parallelism is introduced, how the address space is partitioned, how data is distributed among the partitions and finally how data is accessed across partitions. Our taxonomy reveals that today's PGAS languages focus on distributing regular data and distinguish only between local and remote data access cost, whereas the distribution of irregular data and the adoption of richer data access cost models remain open challenges.},
  biburl = {http://www.bibsonomy.org/bibtex/2cb43d130c4e8ddeca20fcb5a8215a1e2/gron},
  hal-id = {hal-01109405},
  keywords = {Concurrency GlobalAddressSpace HPC LanguageDesign MeMyPublication MessagePassing PGAS Parallelism Performance SharedMemory myown lse-pub},
  annote = {internationalconference},
  pdf = {http://stefan-marr.de/downloads/acm-csur-de-wael-et-al-partitioned-global-address-space-languages.pdf}}

@inproceedings{Deho13a,
  author = {Dehouck, Mathieu and Bhatti, Usman and Bergel, Alexandre and Ducasse, St\'ephane},
  title = {Pragmatic Visualizations for Roassal: a Florilegium},
  booktitle = {International Workshop on Smalltalk Technologies},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deho13a-IWST2013-AlgoRoassal.pdf},
  abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits. This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.Software analysis and in particular reverse engineering often involves a large amount of structured data. This data should be pre- sented in a meaningful form so that it can be used to improve soft- ware artefacts. The software analysis community has produced nu- merous visual tools to help understand different software elements. However, most of the visualization techniques, when applied to software elements, produce results that are difficult to interpret and comprehend.
This paper presents five graph layouts that are both expressive for polymetric views and agnostic to the visualization engine. These layouts favor spatial space reduction while emphasizing on clarity. Our layouts have been implemented in the Roassal visualization engine and are available under the MIT License.},
  annote = {internationalworkshop},
  hal-id = {hal-00862065},
  keywords = {stefPub lse-pub kzVisualization}}

@inproceedings{Delp17a,
  author = {Julien Delplanque and Anne Etien and Olivier Auverlot and Tom Mens and Nicolas Anquetil and St\'ephane Ducasse},
  title = {CodeCritics Applied to Database Schema: Challenges and First Results},
  booktitle = {24th IEEE International Conference on Software Analysis, Evolution, and Reengineering},
  year = {2017},
  hal-id = {hal-01596247},
  keywords = {lse-pub kzEvolution kzDB},
  abstract = {Relational databases (DB) play a critical role in many information systems. For different reasons, their schemas gather not only tables and columns but also views, triggers or stored functions (i.e., fragments of code describing treatments). As for any other code-related artefact, software quality in a DB schema helps avoiding future bugs. However, few tools exist to analyse DB quality and prevent the introduction of technical debt.	Moreover, these tools suffer from limitations like the difficulty to deal with some entities (e.g., functions) or dependencies between entities. This paper presents research issues related to assessing the software quality of a DB schema by adapting existing source code analysis research to database schemas. We present preliminary results that have been validated through the implementation of DBCritics, a prototype tool to perform static analysis on the SQL source code of a database schema. DBCritics addresses the limitations of existing DB quality tools based on an internal representation considering all entities of the database and their relationships.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp17a-Saner-CodeCritics-Applied-To-Database-Schemas.pdf},
  annote = {internationalconference},
  tagnicolasa = {other database}}

@inproceedings{Delp17b,
  author = {Delplanque, Julien},
  title = {Software Engineering Issues in RDBMS, a Preliminary Survey},
  booktitle = {16th edition of the BElgian-NEtherlands software eVOLution symposium (BENEVOL 2017)},
  year = {2017},
  keywords = {lse-pub}}

@inproceedings{Delp18a,
  author = {Delplanque, Julien and Auverlot, Olivier and Etien, Anne and Anquetil Nicolas},
  title = {D\'efinition et identification des tables de nomenclatures},
  booktitle = {36 \`eme \'edition d'INFormatique des ORganisations et Syst\`emes d'Information et de D\'ecision (Inforsid 2018)},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp18a-Inforsid-nomenclatures.pdf},
  abstract = {In a relational database, some tables are used to gather additional information to rows of tables forming the core of the database. This data is stored in tables that we call ``nomenclature tables''. Being able to distinguish them offers many interests in the study, mainte- nance and evolution of databases. We propose properties to define the nature of these tables. Then, an experiment to validate the proposed properties is described and applied on a case study. A classification model for nomenclature tables is built using a datamining algorithm. Its evaluation shows a precision of 88.6% and a recall of 88.7%.},
  language = {fr},
  keywords = {lse-pub},
  hal-id = {hal-01944135},
  tagnicolasa = {other database},
  annote = {nationalconference},
  hal-id = {hal-01944135},
  hal-url = {https://hal.inria.fr/hal-01944135v1}}

@techreport{Delp18b,
  author = {Delplanque, Julien and Ducasse, St\'ephane and Black, Andrew P. and Polito, Guillermo},
  title = {Rotten Green Tests: a First Analysis},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Delp18b-RottenTests.pdf},
  annote = {techreport},
  abstract = {Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A passing (green) test is usually taken as a robust sign that the code under test is valid. However, we have noticed that some green tests contain assertions that are never executed; these tests pass not because they assert properties that are true, but because they assert nothing at all. We call such tests Rotten Green Tests. Rotten Green Tests represent a worst case: they report that the code under test is valid, but in fact do nothing to test that validity, beyond checking that the code does not crash. We describe an approach to identify rotten green tests by combining simple static and dynamic analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. We have applied DrTest to several test suites in Pharo 7.0, and identified many rotten tests, including some that have been " sleeping " in Pharo for at least 5 years.},
  institution = {Inria},
  keywords = {moose StefPub kzChecking kzTools lse-pub},
  hal-id = {hal-01819302}}

@inproceedings{Delp18c,
  author = {Delplanque, Julien and Etien, Anne and Anquetil, Nicolas and Auverlot, Olivier},
  title = {Relational Database Schema Evolution: An Industrial Case Study},
  booktitle = {2018 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  year = {2018},
  doi = {10.1109/ICSME.2018.00073},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp18c-ICSME-DatabaseSchemaEvolution.pdf},
  abstract = {Modern relational database management systems provide advanced features allowing, for example, to include behaviour directly inside the database (stored procedures). These features raise new difficulties when a database needs to evolve (e.g. adding a new table). To get a better understanding of these difficulties, we recorded and studied the actions of a database architect during a complex evolution of the database at the core of a software system. From our analysis, problems faced by the database architect are extracted, generalized and explored through the prism of software engineering. Six problems are identified: (1) difficulty in analysing and visualising dependencies between database's entities, (2) difficulty in evaluating the impact of a modification on the database, (3) replicating the evolution of the database schema on other instances of the database, (4) difficulty in testing database's functionalities, (5) lack of synchronization between the IDE's internal model of the database and the database actual state and (6) absence of an integrated tool enabling the architect to search for dependencies between entities, generate a patch or access up to date PostgreSQL documentation. We suggest that techniques developed by the software engineering community could be adapted to help in the development and evolution of relational databases.},
  institution = {Inria},
  keywords = {lse-pub},
  hal-id = {hal-01945042},
  annote = {internationalconference},
  tagnicolasa = {other database}}

@inproceedings{Delp19a,
  author = {Delplanque, Julien and Ducasse, St\'ephane and Black, Andrew P. and Polito, Guillermo and Etien, Anne},
  title = {Rotten Green Tests},
  booktitle = {2019 International Conference on Software Engineering (ICSE)},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp19a-RottenGreenTests-ICSE2019-v2.pdf},
  abstract = {Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A green (passing) test is usually taken as a robust sign that the code under test is valid. However, some green tests contain assertions that are never executed. We call such tests Rotten Green Tests. Rotten Green Tests represent a case worse than a broken test: they report that the code under test is valid, but in fact do not test that validity. We describe an approach to identify rotten green tests by combining simple static and dynamic call-site analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. DrTest reports no false negatives, yet it still reports some false positives due to conditional use or multiple test contexts. Using DrTest we conducted an empirical evaluation of 19,905 real test cases in mature projects of the Pharo ecosystem. The results of the evaluation show that the tool is effective; it detected 294 tests as rotten-green tests that contain assertions that are not executed. Some rotten tests have been "sleeping" in Pharo for at least 5 years.},
  institution = {Inria},
  keywords = {lse-pub kzChecking},
  hal-id = {hal-02002346},
  hal-url = {https://hal.inria.fr/hal-02002346},
  annote = {topconference internationalconference}}

@inproceedings{Delp19b,
  author = {Julien Delplanque and St\'ephane Ducasse and Oleksandr Zaitsev},
  title = {Magic Literals in Pharo},
  booktitle = {International workshop of Smalltalk Technologies},
  year = {2019},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02266137v1},
  hal-id = {hal-02266137},
  annote = {internationalworkshop},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp19b-IWST-MagicLiterals.pdf},
  keywords = {kzEvolution}}

@inproceedings{Delp20a,
  author    = {Julien Delplanque and Anne Etien and Nicolas Anquetil and
               St{\'{e}}phane Ducasse},
  editor    = {Schahram Dustdar and Eric Yu and Camille Salinesi and
               Dominique Rieu and Vik Pant},
  title     = {Recommendations for Evolving Relational Databases},
  booktitle = {International Conference on Advanced Information Systems Engineering (CAiSE'20)},
  series    = {Lecture Notes in Computer Science},
  volume    = {12127},
  pages     = {498--514},
  publisher = {Springer},
  year      = {2020},
  url       = {https://doi.org/10.1007/978-3-030-49435-3\_31},
  doi       = {10.1007/978-3-030-49435-3\_31}
}

@inproceedings{Dema14a,
  author = {Demarey, Christophe and Cassou, Damien and Ducasse, St\'ephane},
  title = {Towards a new package dependency model},
  booktitle = {IWST'14: Proceedings of the 6th International Workshop on Smalltalk Technologies},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dema14a-esug2014-dependencies-model.pdf},
  address = {Cambridge, United Kingdom},
  hal-id = {hal-01086083},
  keywords = {package management system ; package manager ; dependency kzModularisation},
  annote = {internationalworkshop},
  month = {aug},
  hal-url = {https://hal.inria.fr/hal-01086083}}

@inproceedings{Deme00a,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Finding Refactorings via Change Metrics},
  booktitle = {Proceedings of 15th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA '00)},
  pages = {166--178},
  publisher = {ACM Press},
  year = {2000},
  misc = {acceptance rate: 26/142 = 18\%, SCI impact factor 0.190, ranked 66/77},
  doi = {10.1145/353171.353183},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00a-OOPSLA00-FindingRefactoring.pdf},
  abstract = {Reverse engineering is the process of uncovering the design and the design rationale from a functioning software system. Reverse engineering is an integral part of any successful software system, because changing requirements lead to implementations that drift from their original design. In contrast to traditional reverse engineering techniques -which analyse a single snapshot of a system- we focus the reverse engineering effort by determining where the implementation has changed. Since changes of object-oriented software are often phrased in terms of refactorings, we propose a set of heuristics for detecting refactorings by applying lightweight, object-oriented metrics to successive versions of a software system. We validate our approach with three separate case studies of mature object-oriented software systems for which multiple versions are available. The case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system.},
  acceptnum = {26},
  accepttotal = {142},
  address = {New York NY},
  annote = {internationalconference topconference},
  keywords = {olit scg-pub jb00 snf00 oorp stefPub moose kzMetric kzEvolution},
  note = {Also in ACM SIGPLAN Notices 35 (10)},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00aFindingRefactoring.pdf}}

@inproceedings{Deme00d,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {A Pattern Language for Reverse Engineering},
  booktitle = {Proceedings of EuroPLoP '00},
  pages = {189--208},
  publisher = {UVK GmbH},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00d-RevEng.pdf},
  abstract = {Since object-oriented programming is usually associated with iterative development, reverse engineering must be considered an essential facet of the object-oriented paradigm. The reverse engineering pattern language presented here summarises the reverse engineering experience gathered as part of the FAMOOS project, a project with the explicit goal of investigating reverse and reengineering techniques in an object-oriented context. Due to limitations on EuroPLOP submissions, only part of the full pattern language is presented, namely the patterns describing how to gain an initial understanding of a software system.},
  annote = {internationalworkshop},
  isbn = {3-87940-775-4},
  keywords = {snf-none stefPub scg-pub skip-doi jb00 kzMetric},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme00dRevEng.pdf}}

@techreport{Deme01y,
  author = {Serge Demeyer and Sander Tichelaar and St\'ephane Ducasse},
  title = {{FAMIX} 2.1 --- {The} {FAMOOS} {Information} {Exchange} {Model}},
  year = {2001},
  annote = {report notrefereed},
  institution = {University of Bern},
  keywords = {kzMeta}}

@book{Deme02a,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Object-Oriented Reengineering Patterns},
  pages = {360},
  publisher = {Morgan Kaufmann},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/OORP.pdf},
  abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems. This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
  annote = {book},
  isbn = {1-55860-639-4},
  keywords = {kzBook},
  web = {http://www.iam.unibe.ch/~scg/OORP}}

@inproceedings{Deme03a,
  author = {Serge Demeyer and St\'ephane Ducasse and Kim Mens and Adrian Trifu and Rajesh Vasa},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
  pages = {72-85},
  publisher = {Springer-Verlag},
  year = {2003},
  annote = {workshopproceedings},
  keywords = {kzEditor},
  series = {LNCS}}

@misc{Deme03b,
  author = {Wolfgang Demeuter and St\'ephane Ducasse and Theo D'hondt and Ole Lehrmann Madsen},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
  booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {2003},
  annote = {workshopproceedings},
  keywords = {kzEditor},
  series = {LNCS}}

@inproceedings{Deme05a,
  author = {Serge Demeyer and Filip Van Rysselberghe and Tudor G\^irba and Jacek Ratzinger and Radu Marinescu and Tom Mens and Bart Du Bois and Dirk Janssens and St\'ephane Ducasse and Michele Lanza and Matthias Rieger and Harald Gall and Michel Wermelinger and Mohammad El-Ramly},
  title = {The {LAN}-simulation: A Research and Teaching Example for Refactoring},
  booktitle = {Proceedings of IWPSE 2005 (8th International Workshop on Principles of Software Evolution)},
  pages = {123--131},
  publisher = {IEEE Computer Society Press},
  year = {2005},
  misc = {acceptance rate: 13/54=24\%},
  doi = {10.1109/IWPSE.2005.30},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme05a-LANRefactoring.pdf},
  abstract = {The notion of refactoring --- transforming the source-code of an object-oriented program without changing its external behaviour --- has been studied intensively within the last decade. This diversity has created a plethora of toy-examples, cases and code snippets, which make it hard to assess the current state-of-the-art.	Moreover, due to this diversity, there is currently no accepted way of teaching good refactoring practices, despite the acknowledgment in the software engineering body of knowledge. Therefore, this paper presents a common example --- the LAN simulation --- which has been used by a number of European Universities for both research and teaching purposes.},
  acceptnum = {13},
  accepttotal = {54},
  address = {Los Alamitos CA},
  annote = {internationalworkshop},
  inri = {hors},
  keywords = {kzEvolution},
  location = {Lisbon, Portugal},
  rate = {24\%},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme05aLANRefactoring.pdf}}

@inproceedings{Deme06a,
  author = {Serge Demeyer and Kim Mens and Roel Wuyts and Yann-Ga\"el Gu\'{e}h\'{e}neuc and Andy Zaidman and Neil Walkinshaw and Ademar Aguiar and St\'ephane Ducasse},
  title = {Report of the 6th ECOOP'05 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology. ECOOP'05 Workshop Reader},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Deme06a-ECOOP2006-WOOR.pdf},
  annote = {workshopproceedings},
  keywords = {scg-pub skip-abstract skip-doi stefPub kzEditor}}

@book{Deme08a,
  author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Object-Oriented Reengineering Patterns},
  publisher = {Square Bracket Associates},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/OORP.pdf},
  abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems.	This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
  annote = {book},
  isbn = {978-3-9523341-2-6},
  keywords = {scg-pub skip-doi stefPub moose kzBook},
  medium = {2},
  peerreview = {no},
  web = {http://scg.unibe.ch/download/oorp/}}

@inproceedings{Deme18a,
  author = {Demeyer, Serge and Verhaeghe, Beno{\^\i}t and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {Evaluating the Efficiency of Continuous Testing during Test-Driven Development},
  booktitle = {Proceedings {VST 2018} (2nd IEEE International Workshop on Validation, Analysis and Evolution of Software Tests)},
  pages = {1 -- 5},
  year = {2018},
  url = {https://hal.inria.fr/hal-01717343},
  month = mar,
  tagnicolasa = {other test},
  annote = {internationalworkshop}}

@inproceedings{Deme98n,
  author = {Serge Demeyer and St\'ephane Ducasse},
  title = {Do Metrics Support Framework Development?},
  booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
  volume = {1543},
  pages = {247--249},
  publisher = {Springer-Verlag},
  year = {1998},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {famoos scg-pub skip-pdf skip-abstract skip-doi metrics stefPub kzEditor},
  series = {LNCS}}

@inproceedings{Deme99a,
  author = {Serge Demeyer and St\'ephane Ducasse},
  title = {Metrics, Do They Really Help?},
  booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO'99)},
  pages = {69--82},
  publisher = {HERMES Science Publications, Paris},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99a-LMO99-DemeyerDucasse.pdf},
  abstract = {Maturing a well designed framework requires a set of software metrics to steer the iterative development process. Based on a case study of the VisualWorks/Smalltalk framework for user-interface building, we conclude that today's size and inheritance metrics are not reliable to detect problems but are useful in measuring stability. We expect that this work will contribute to the application of metrics as a project management tool.},
  annote = {nationalconference},
  editor = {Jacques Malenfant},
  keywords = {famoos scg-pub skip-doi oorp stefPub moose kzMetric},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99aDemeyerDucasseLMO99.pdf}}

@inproceedings{Deme99c,
  author = {Serge Demeyer and St\'ephane Ducasse and Michele Lanza},
  title = {A Hybrid Reverse Engineering Platform Combining Metrics and Program Visualization},
  booktitle = {Proceedings of Working Conference on Reverse Engineering (WCRE'99)},
  publisher = {IEEE Computer Society},
  year = {1999},
  doi = {10.1109/WCRE.1999.806958},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99c-WCRE-CodeCrawler.pdf},
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. Consequently, reverse engineering techniques are relevant in an object-oriented context as well. This paper investigates a hybrid approach, combining the immediate appeal of visualisations with the scalability of metrics. We validate such a hybrid approach by showing how CodeCrawler ---the experimental platform we built--- allowed us to understand the program structure of, and identify potential design anomalies in a public domain software system.},
  annote = {internationalconference},
  editor = {Fran\c{c}oise Balmas and Mike Blaha and Spencer Rugaber},
  keywords = {famoos scg-pub oorp stefPub moose kzVisualization},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99cCodeCrawler.pdf}}

@inproceedings{Deme99d,
  author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
  title = {Why Unified is not Universal. {UML} Shortcomings for Coping with Round-trip Engineering},
  booktitle = {Proceedings of the International Conference on The Unified Modeling Language (UML'99)},
  volume = {1723},
  pages = {630--644},
  publisher = {Springer-Verlag},
  year = {1999},
  misc = {acceptance rate: 44/166 = 26\%, SCI impact 0.515, ranked 39/69},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99d-UML99.pdf},
  abstract = {UML is currently embraced as "the" standard in object-oriented modeling languages, the recent work of OMG on the Meta Object Faci lity (MOF) being the most noteworthy example. We welcome these standardisation efforts, yet warn against the tendency to use UML as the panacea for all exchange standards. In particular, we argue that UML is not sufficient to serve as a tool-interoperability standard for integrating round-trip engineering tools, because one is forced to rely on UML's built-in extension mechanisms to a dequately model the reality in source-code. Meanwhile, our argumentation includes a number of constructive suggestions that we ho pe will influence future releases of the UML and MOF standards.},
  acceptnum = {44},
  accepttotal = {166},
  address = {Kaiserslautern, Germany},
  annote = {internationalconference},
  editor = {Bernhard Rumpe},
  keywords = {famoos-papref scg-pub skip-doi stefPub moose kzMeta},
  month = oct,
  series = {LNCS},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99dUML99.pdf}}

@inproceedings{Deme99n,
  author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
  title = {A Pattern Language for Reverse Engineering},
  booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing},
  publisher = {UVK Universit\"atsverlag Konstanz GmbH},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99n-Europlop99.pdf},
  abstract = {This pattern language describes how to reverse engineer an object-oriented software system. Since the only way to achieve a truly reusable object-oriented design is recognised to be iterative development, reverse engineering is indeed an essential facet of any object-oriented development process. The pattern language itself covers the different phases one encounters when reverse engineering a large software system: from being unfamiliar with a software system up untill preparations for actual reengineering. What you read here is a short version of a complete pattern language. We present only five patterns in full detail and include a summary for the remaining patterns.},
  address = {Konstanz, Germany},
  annote = {internationalworkshop},
  editor = {Paul Dyson},
  keywords = {scg-pub skip-doi stefPub kzPattern},
  month = jul,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deme99nEuroplop99.pdf}}

@inproceedings{Deni04a,
  author = {Simon Denier},
  title = {Traits Programming with {AspectJ}},
  booktitle = {Actes de la Premi\`ere Journ\'ee Francophone sur le D\'eveloppement du Logiciel par Aspects (JFDLPA'04)},
  pages = {62--78},
  year = {2004},
  url = {http://www.emn.fr/x-info/obasco/events/jfdlpa04/},
  address = {Paris, France},
  editor = {Pierre Cointe},
  month = sep}

@inproceedings{Deni09a,
  author = {Simon Denier and Houari A. Sahraoui},
  title = {Understanding the Use of Inheritance with Visual Patterns},
  booktitle = {Proceedings of the 3rd International Symposium on Empirical Software Engineering and Measurement (ESEM'09)},
  publisher = {IEEE Computer Society Press},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deni09a-ESEM09-VisuInheritance.pdf},
  abstract = {The goal of this work is to visualize inheritance in object-oriented programs to help its comprehension. We propose a single, compact view of all class hierarchies at once using a custom Sunburst layout. It enables to quickly discover interesting facts across classes while preserving the essential relationship between parent and children classes. We explain how standard inheritance metrics are mapped into our visualization. Additionally, we define a new metric characterizing similar children classes. Using these metrics and the proposed layout, a set of common visual patterns is derived.	These patterns allow the programmer to quickly understand how inheritance is used and provide answers to some essential questions when performing program comprehension tasks. Our approach is evaluated through a case study that involves examples from large programs, demonstrating its scalability.},
  address = {Lake Buena Vista, FL, USA},
  annote = {internationalconference},
  editor = {James Miller and Rick Selby},
  hal-id = {hal-00746244},
  keywords = {lse-pub remoose},
  rate = {39\%}}

@inproceedings{Deni09b,
  author = {Simon Denier and Damien Pollet and St\'ephane Ducasse},
  title = {Proposals for the Reborn Pharo Developer},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'09)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deni09b-IWST09-PharoBrowsers.pdf},
  abstract = {Smalltalk was at the birth of current IDEs. Current Smalltalk
IDEs, however, lost their abilities to adapt to developer needs
(edit and jump, back button, auto-completion,...). Therefore
while offering a powerful sets of tools current Smalltalk
IDEs looks clunky and often lacks the application of a consistent set of guidelines. In this paper we sketch some possible IDEs future features or reorganization.},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {hal-00746260},
  keywords = {lse-pub pharo-pub kzIDE}}

@proceedings{Deni09c,
  author = {Simon Denier and Tudor G\^irba},
  title = {Proceedings of the 3rd Workshop on FAMIX and MOOSE in Software Reengineering (FAMOOSr'09)},
  pages = {27},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Deni09c-famoosr09-proceedings.pdf},
  abstract = {The increasing amount of data available about software systems poses new challenges for re- and reverse engineering research, as the proposed approaches need to scale. In this context, concerns about meta-modeling and analysis techniques need to be augmented by technical concerns about how to reuse and how to build upon the efforts of previous research. MOOSE is an extensive infrastructure for reverse engineering evolved for over 10 years that promotes the reuse of engineering efforts in research. MOOSE accommodates various types of data modeled in the FAMIX family of meta-models. The goal of this half-day workshop is to strengthen the community of researchers and practitioners who are working in re- and reverse engineering, by providing a forum for building future research starting from MOOSE and FAMIX as shared infrastructure.},
  annote = {workshopproceedings},
  editor = {Simon Denier and Tudor G\^irba},
  hal-id = {hal-00746250},
  keywords = {moose lse-pub}}

@techreport{Deni10a,
  author = {Simon Denier and Jannik Laval and St\'ephane Ducasse and Fabrice Bellingard},
  title = {Technical and Economical Model (Squale Deliverable 2.1)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Deni10a-Squale-deliverable21-EcoModel.pdf},
  abstract = {The objective of this deliverable is to define a model for (i) assessing the effort of software modification, (ii) identifying healing actions following practices from the Squale quality model defined in the previous workpackage (WP1.3). It defines the input for the next deliverable which is about planning actions once their effort is characterized.},
  hal-id = {inria-00533656},
  inriareport = {2010},
  institution = {INRIA},
  keywords = {Squale report2010 kzQualityModel}}

@techreport{Deni10b,
  author = {Simon Denier and Jannik Laval and St\'ephane Ducasse and Fabrice Bellingard},
  title = {Technical Model for Remediation (Squale Deliverable 2.2)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Deni10a-Squale-deliverable21-EcoModel.pdf},
  abstract = {The objective of this workpackage is the definition of the global remediation effort on a project. It defines strategies for upgrading quality through assessment and organization of the single remediation tasks as described in WorkPackage 2.1.},
  hal-id = {inria-00533659},
  inriareport = {2010},
  institution = {INRIA},
  keywords = {Squale report2010 kzQualityModel}}

@inproceedings{Denk00a,
  author = {Marcus Denker},
  title = {Event und Notification Service in CORBA},
  booktitle = {Architektur vernetzter Systeme},
  publisher = {Universit\"at Karlsruhe, Institut fuer Telematik (Interner Bericht)},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk00a-TechReport-Corba.pdf},
  abstract = {Mittels CORBA k\"onnen verteilte Applikationen einfach \"uber ein Netzwerk miteinander kommunizieren. Doch das von CORBA zur Verf\"ugung gestellte Kommunikationsmodell reicht in manchen F\"allen nicht aus, es wird ein Modell zur asynchronen Kommunikation zwischen lose gekoppelten Objekten ben\"otigt. Der CORBA Event Service ist ein Versuch, ein solches Kommunikationsmodell bereitzustellen. Der Event Service hat sich aber als unzureichend herausgestellt. Daher wurde er um einige Aspekte zum Notiocation Service erweitert.},
  issn = {1432-7864},
  keywords = {marcusdenker fromscgbib},
  page = {7--13}}

@article{Denk01a,
  author = {Marcus Denker},
  title = {Squeak: Zur\"uck in die Zukunft},
  journal = {Der Eulenspiegel},
  volume = {2001},
  publisher = {Fachschaft Mathematik/Informatik, University of Karlsruhe},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Vulgarisations/Denk01a-EulenSpiegel-Squeak.pdf},
  annote = {notrefereed},
  keywords = {Etoys Squeak Education marcusdenker fromscgbib},
  number = {2}}

@misc{Denk02a,
  author = {Marcus Denker},
  title = {Entwurf von Optimierungen f\"ur Squeak},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk02a-Studienarbeit-J3.pdf},
  abstract = {Das Squeak-System m\"ochte eine flexible Programmierumgebung und ein m\"achtiges multimediales Autorensystem f\"ur Kinder bereitstellen. Die besonderen Eigenschaften eines solchen Systems stellen besondere Anforderungen an die Implementierung. Die Studienarbeit zeigt die Probleme der bestehenden Implementierungen auf und stellt einen verbesserten Entwurf vor.},
  keywords = {Squeak marcusdenker fromscgbib},
  note = {Studienarbeit, Universit\"at Karlsruhe}}

@mastersthesis{Denk04a,
  author = {Marcus Denker},
  title = {Erweiterung eines statischen \"Ubersetzers zu einem Laufzeit\"ubersetzungssystem},
  year = {2004},
  school = {University of Karlsruhe},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk04a-Thesis-Karlsruhe.pdf},
  keywords = {marcusdenker fromscgbib},
  type = {diploma thesis}}

@inproceedings{Denk04b,
  author = {Marcus Denker},
  title = {Squeak@21c3},
  booktitle = {Proceedings of the 21st Chaos Communication Congress},
  publisher = {Chaos Computer Club},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Vulgarisations/Denk04b-21C3-Squeak.pdf},
  abstract = {This is not a real article. While putting together
 the demo image for for 21C3, I decided to not write
 an article that is just to be read (mostly because
 these are really boring to write...) This text is
 just a short user manual for that thing (we call it
 Squeak Image) that I will use for the demo at 21C3.
 So if you follow the instructions, you will be able
 to go through the slides and play with everything
 yourself.},
  isbn = {3-934636-02-0},
  keywords = {fromscgbib marcusdenker},
  page = {52--59}}

@inproceedings{Denk05a,
  author = {Marcus Denker},
  title = {Squeak and Croquet},
  booktitle = {Proceedings of LinuxTag 2005},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Vulgarisations/Denk05a-LinuxTag-Squeak.pdf},
  abstract = {Squeak allows kids of all ages to be creative with their computer. The goal of the Squeak Project is to build a system without constraints: It is used at schools, universities and in industry. Squeak is an open System: It is implemented in Squeak itself, all parts are available for learning and hacking. The whole source code is available and can be changed while the system is running. Squeak is available on the internet under a free license, it is highly portable and currently used on over 20 different platforms. This talk will give an overview over the Squeak Project: From the eToy kids programming environment up to the Seaside system for professional web development. The eToys make programming fun for children from around age 8. The talk will show how to build simple eToy programs and how Squeak is used at school. But even professional developers are using Squeak; The Seaside framework shows how the openness of Squeak can help to make developers more productive. The last part of the talk will give a glimpse into the future: OpenCroquet. The Croquet project is building a revolutionary collaborative environment based on Squeak. It provides a scalable, peer-to-peer multiuser 3D environment that is completely open for exploration and makes novel ways for communication and interaction possible.},
  keywords = {fromscgbib marcusdenker}}

@article{Denk06a,
  author = {Marcus Denker and St\'ephane Ducasse and {\'E}ric Tanter},
  title = {Runtime Bytecode Transformation for {Smalltalk}},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {32},
  pages = {125--139},
  publisher = {Elsevier},
  year = {2006},
  impactfactor = {Impact factor (2010) 0.541},
  doi = {10.1016/j.cl.2005.10.002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk06a-COMLAN-RuntimeByteCode.pdf},
  abstract = {Transforming programs to alter their semantics is of
 wide interest, for purposes as diverse as
 off-the-shelf component adaptation, optimization,
 trace generation, and experimentation with new
 language features. The current wave of interest in
 advanced technologies for better separation of
 concerns, such as aspect-oriented programming, is a
 solid testimony of this fact. Strangely enough,
 almost all proposals are formulated in the context
 of {Java}, in which tool providers encounter severe
 restrictions due to the rigidity of the environment.
 This paper present ByteSurgeon, a library to
 transform binary code in Smalltalk. ByteSurgeon
 takes full advantage of the flexibility of the
 Squeak environment to enable bytecode transformation
 at runtime, thereby allowing dynamic, on-the-fly
 modification of applications. ByteSurgeon operates
 on bytecode in order to cope with situations where
 the source code is not available, while providing
 appropriate high-level abstractions so that users do
 not need to program at the bytecode level. We
 illustrate the use of ByteSurgeon via the
 implementation of method wrappers and a simple MOP,
 and report on its efficiency.},
  annote = {internationaljournal},
  keywords = {scg-pub stefPub mdPub fromscgbib marcusdenker kzReflection},
  month = jul,
  number = {2-3}}

@inproceedings{Denk06c,
  author = {Marcus Denker and Orla Greevy and Michele Lanza},
  title = {Higher Abstractions for Dynamic Analysis},
  booktitle = {2nd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2006)},
  pages = {32--38},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk06c-PCODA06-HigherAbstractions.pdf},
  abstract = {The developers of tools for dynamic analysis are faced with choosing from the many approaches to gathering runtime data. Typically, dynamic analysis involves instrumenting the program under investigation to record its runtime behavior.	Current approaches for byte-code based systems like Java and Smalltalk rely often on inserting byte-code into the program under analysis. However, detailed knowledge of the target programming language or virtual machine is required to implement dynamic analysis tools. Obtaining and exploiting this knowledge to build better analysis tools is cumbersome and often distracts the tool builder from the actual goal, which is the analysis of the runtime behavior of a system. In this paper, we argue that we need to adopt a higher level view of a software system when considering the task of abstracting runtime information. We focus on object-oriented virtual machine based languages. We want to be able to deal with the runtime system as a collection of reified first-class entities. We propose to achieve this by introducing a layer of abstraction, i.e., a behavioral middle layer. This has the advantage that the task of collecting dynamic information is not concerned with low level details of a specific language or virtual machine.	The positive effect of such a behavioral middle layer is twofold: on the one hand it provides us with a standard API for all dynamic analysis based tools to use, on the other hand it allows the tool developer to abstract from the actual implementation technique.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi snf07 jb07 fb06 reflectivity fromscgbib marcusdenker},
  medium = {2}}

@inproceedings{Denk07a,
  author = {Marcus Denker and St\'ephane Ducasse},
  title = {Software Evolution from the Field: an Experience Report from the {Squeak} Maintainers},
  booktitle = {Proceedings of the ERCIM Working Group on Software Evolution (2006)},
  volume = {166},
  pages = {81--91},
  publisher = {Elsevier},
  year = {2007},
  doi = {10.1016/j.entcs.2006.08.003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk07a-Ercim06-EvolutionSqueak.pdf},
  abstract = {Over the last few years, we actively participated in the maintenance and evolution of Squeak, an open-source Smalltalk. The community is constantly faced with the problem of enabling changes while at the same time preserving compatibility. In this paper we describe the current situation, the problems that faced the community and we outline the solutions that have been put in place. We also identify some areas where problems continue to exist and propose these as potential problems to addressed by the research community.},
  annote = {internationalworkshop},
  issn = {1571-0661},
  keywords = {scg07 stefPub scg-pub snf06 recast06 jb07 marcusdenker kzEvolution},
  medium = {2},
  month = jan,
  series = {Electronic Notes in Theoretical Computer Science}}

@inproceedings{Denk07b,
  author = {Marcus Denker and St\'ephane Ducasse and Adrian Lienhard and Philippe Marschall},
  title = {Sub-Method Reflection},
  booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
  volume = {6/9},
  pages = {231--251},
  publisher = {ETH},
  year = {2007},
  doi = {10.5381/jot.2007.6.9.a14},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk07b-TOOLS07-Submethod.pdf},
  abstract = {Reflection has proved to be a powerful feature to support the design of development environments and to extend languages. However, the granularity of structural reflection stops at the method level.	This is a problem since without sub-method reflection developers have to duplicate efforts, for example to introduce transparently pluggable type-checkers or fine-grained profilers. In this paper we present Persephone, an efficient implementation of a sub-method meta-object protocol (MOP) based on AST annotations and dual methods (a compiled method and its meta-object) that reconcile AST expressiveness with bytecode execution. We validate the MOP by presenting TreeNurse, a method instrumentation framework and TypePlug, an optional, pluggable type system which is based on Persephone.},
  annote = {internationalconference},
  issn = {1660-1769},
  keywords = {skip-doi jot snf-bmcc reflectivity fromscgbib marcusdenker kzReflection},
  medium = {2},
  month = oct}

@inproceedings{Denk07c,
  author = {Marcus Denker and Tudor G\^irba and Adrian Lienhard and Oscar Nierstrasz and Lukas Renggli and Pascal Zumkehr},
  title = {Encapsulating and Exploiting Change with {Changeboxes}},
  booktitle = {Proceedings of International Conference on Dynamic Languages (ICDL 2007)},
  pages = {25--49},
  publisher = {ACM Digital Library},
  year = {2007},
  doi = {10.1145/1352678.1352681},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk07c-ICDL07-Changeboxes.pdf},
  abstract = {Real world software systems change continuously to meet new demands. Most programming languages and development environments, however, are more concerned with limiting the effects of change rather than enabling and exploiting change. Various techniques and technologies to exploit change have been developed over the years, but there exists no common support for these approaches. We propose Changeboxes as a general-purpose mechanism for encapsulating change as a first-class entity in a running software system. Changeboxes support multiple, concurrent and possibly inconsistent views of software artifacts within the same running system.	Since Changeboxes are first-class, they can be manipulated to control the scope of change in a running system.Furthermore, Changeboxes capture the semantics of change. Changeboxes can be used, for example, to encapsulate refactorings, or to replay or analyze the history of changes. In this paper we introduce Changeboxes by means of a prototype implementation. We illustrate the benefits that Changeboxes offer for evolving software systems, and we present the results of a preliminary performance evaluation that assesses the costs associated with Changeboxes while suggesting possible strategies for improvement.},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {scg07 scg-pub jb08 snf08 girba cop-lit marcusdenker fromscgbib}}

@inproceedings{Denk07d,
  author = {Marcus Denker and Orla Greevy and Oscar Nierstrasz},
  title = {Supporting Feature Analysis with Runtime Annotations},
  booktitle = {Proceedings of the 3rd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2007)},
  pages = {29--33},
  publisher = {Technische Universiteit Delft},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk07d-PCODA07-FeatureAnnotation.pdf},
  abstract = {The dynamic analysis approach to feature identification describes a technique for capturing feature behavior and mapping it to source code.	Major drawbacks of this approach are (1) large amounts of data and (2) lack of support for sub-method elements. In this paper we propose to leverage sub-method reflection to identify and model features. We perform an on-the-fly analysis resulting in annotating the operations participating in a feature's behavior with meta-data.The primary advantage of our annotation approach is that we obtain a fine-grained level of granularity while at the same time eliminating the need to retain and analyze large traces for feature analysis.},
  annote = {internationalworkshop},
  issn = {1872-5392},
  keywords = {scg07 scg-pub skip-doi snf08 jb08 reflectivity fromscgbib marcusdenker},
  medium = {2}}

@phdthesis{Denk08a,
  author = {Marcus Denker},
  title = {Sub-method Structural and Behavioral Reflection},
  year = {2008},
  school = {University of Bern},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2008-Denker.pdf},
  abstract = {Computational reflection is a fundamental mechanism in object oriented languages. Reflection has proved useful in many contexts, such as in the design of development environments, language extension, and the dynamic, unanticipated adaptation of running systems We identify three problems with the current approach to reflection in object oriented languages: partial behavioral reflection needs to be anticipated, structural reflection is limited to the granularity of a method, and behavioral reflection cannot be applied to the whole system. To address these problems, we extend structural reflection to cover sub-method elements and present how sub-method structural reflection supports unanticipated partial behavioral reflection. We add the concept of context to represent meta-level execution and show how this allows behavioral reflection to be applied even to system classes. We describe an implementation in Smalltalk. Benchmarks validate the practicability of our approach. In addition, we present an experimental evaluation in which we show how the system is used for dynamic analysis. We realize dynamic feature analysis by annotating the sub-method structure of the system directly to denote features instead of recording full execution traces.},
  keywords = {scg-phd reflectivity marcusdenker fromscgbib},
  month = may,
  type = {{PhD} thesis}}

@inproceedings{Denk08b,
  author = {Marcus Denker and Mathieu Suen and St\'ephane Ducasse},
  title = {The Meta in Meta-object Architectures},
  booktitle = {Proceedings of TOOLS EUROPE 2008},
  volume = {11},
  pages = {218--237},
  publisher = {Springer-Verlag},
  year = {2008},
  doi = {10.1007/978-3-540-69824-1\_13},
  isbn = {978-3-540-69824-1},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk08b-Tools08-MetaContext.pdf},
  abstract = {Behavioral reflection is crucial to support for example functional upgrades, on-the-fly debugging, or monitoring critical applications. However the use of reflective features can lead to severe problems due to infinite metacall recursion even in simple cases. This is especially a problem when reflecting on core language features since there is a high chance that such features are used to implement the reflective behavior itself. In this paper we analyze the problem of infinite meta-object call recursion and solve it by providing a first class representation of meta-level execution: at any point in the execution of a system it can be determined if we are operating on a meta-level or base level so that we can prevent infinite recursion. We present how meta-level execution can be represented by a meta-context and how reflection becomes context-aware. Our solution makes it possible to freely apply behavioral reflection even on system classes: the meta-context brings stability to behavioral reflection. We validate the concept with a robust implementation and we present benchmarks.},
  annote = {internationalconference},
  hal = {inria-00271286,p56w09p},
  issn = {1865-1348},
  keywords = {scg-pub jb08 fb08 snf08 reflectivity marcusdenker remoose kzReflection},
  series = {LNBIP}}

@inproceedings{Denk10a,
  author = {Marcus Denker and Jorge Ressia and Orla Greevy and Oscar Nierstrasz},
  title = {Modeling Features at Runtime},
  booktitle = {Proceedings of MODELS 2010},
  volume = {6395},
  pages = {138--152},
  publisher = {Springer-Verlag},
  year = {2010},
  misc = {Acceptance rate: 20.8\%},
  doi = {10.1007/978-3-642-16129-2\_11},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Denk10a-Models10-FeatureModels.pdf},
  abstract = {A feature represents a functional requirement fulfilled by a system. Since many maintenance tasks are expressed in terms of features, it is important to establish the correspondence between a feature and its implementation in source code.	Traditional approaches to establish this correspondence exercise features to generate a trace of runtime events, which is then processed by post-mortem analysis.	These approaches typically generate large amounts of data to analyze. Due to their static nature, these approaches do not support incremental and interactive analysis of features. We propose a radically different approach called live feature analysis, which provides a model at runtime of features. Our approach analyzes features on a running system and also makes it possible to grow feature representations by exercising different scenarios of the same feature, and identifies execution elements even to the sub-method level.	We describe how live feature analysis is implemented effectively by annotating structural representations of code based on abstract syntax trees. We illustrate our live analysis with a case study where we achieve a more complete feature representation by exercising and merging variants of feature behavior and demonstrate the efficiency or our technique with benchmarks.},
  inriareport = {2010},
  isbn = {978-3-642-16128-5},
  keywords = {snf10 jb11 scg-pub lse-pub marcusdenker pharo},
  month = oct,
  series = {LNCS}}

@incollection{Denk13a,
  author = {Christian Denker and Norbert Hartl and Marcus Denker},
  title = {Kapitel 1: Apps},
  booktitle = {Mobile Apps - Rechtsfragen und rechtliche Rahmenbedingungen},
  pages = {1-8},
  publisher = {De Gruyter},
  year = {2013},
  annote = {articlebook},
  editor = {Christian Solmecke and Juergen Taeger and Thorsten Feldmann},
  hal-id = {hal-00865117},
  isbn = {978-3-11-030503-6},
  keywords = {lse-pub},
  month = {aug}}

@techreport{Denk14a,
  author = {Marcus Denker and Nicolas Anquetil and Damien Cassou and St\'ephane Ducasse and Anne Etien and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2013 Activity Report},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk14a-RAWEB-RMOD-2013-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-00936375},
  inriareport = {2014},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@techreport{Denk15a,
  author = {Marcus Denker and Nicolas Anquetil and Damien Cassou and St\'ephane Ducasse and Anne Etien and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2014 Activity Report},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk15a-RAWEB-RMOD-2014-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-01247323},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@techreport{Denk16a,
  author = {Marcus Denker and Nicolas Anquetil and Damien Cassou and St\'ephane Ducasse and Anne Etien and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2015 Activity Report},
  year = {2016},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk16a-RAWEB-RMOD-2015-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-01267026},
  inriareport = {2016},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@techreport{Denk18a,
  author = {Marcus Denker and Nicolas Anquetil and St\'ephane Ducasse and Anne Etien and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2017 Activity Report},
  year = {2018},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk18a-RAWEB-RMOD-2017-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-01683649},
  inriareport = {2018},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@techreport{Denk19a,
  author = {Marcus Denker and Nicolas Anquetil and St\'ephane Ducasse and Anne Etien and Damien Pollet},
  title = {Project-Team RMoD 2018 Activity Report},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Denk19a-RAWEB-RMOD-2018-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-02006630},
  inriareport = {2019},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@inproceedings{Dery96a,
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
  title = {Inhibition et resynchronisation des contr\^oleurs de dialogue},
  booktitle = {Actes d'Interfaces Hommes Machine (IHM'96)},
  year = {1996},
  annote = {nationalconference},
  keywords = {stefPub kzDependency}}

@incollection{Dery96b,
  author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
  title = {Objets et D\'ependances},
  booktitle = {Ing\'eni\`erie Objet},
  pages = {131--155},
  publisher = {Inter-Editions},
  year = {1996},
  annote = {articlebook},
  editor = {O. Mourad},
  keywords = {stefPub kzDependency},
  note = {ISBN: 2-7296-0642-4}}

@article{Dias03a,
  author = {M\'{a}rcio G. B. Dias and Nicolas Anquetil and K\'{a}thia M. de Oliveira},
  title = {Organizing the Knowledge Used in Software Maintenance},
  journal = {Journal of Universal Computer Science},
  volume = {9},
  pages = {641--658},
  year = {2003},
  doi = {10.1049/ip-sen:20030581},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias03a-Organizing_the_knowledge_used_in_software_maintena.pdf},
  abstract = {Knowledge engineering emerged as a very promising area to help improve software engineering practice. One of its possible applications would be to help in solving the numerous problems that affect the software maintenance activity. Maintainers of legacy systems developed years ago with obsolete techniques and tools, and not documented, need all kinds of knowledge (application domain, programming skills, software engineering techniques, etc.) It is generally assumed that formalizing all this knowledge and recording it would be a worthwhile effort. However, research is still in a early stage and numerous questions need to be answered: What knowledge should be targeted first? Where to find this knowledge? etc. To answer these questions, one needs a precise understanding of what knowledge is at stake here. We, therefore, propose an ontology of the knowledge needed to perform software maintenance. This ontology would be most useful as a framework for future research in knowledge engineering for software maintenance.},
  aeres = {ACLN},
  annote = {internationaljournal},
  number = {7},
  tagnicolasa = {knowledge}}

@inproceedings{Dias03b,
  author = {M{\'a}rcio Greyck Batista Dias and Nicolas Anquetil and K{\'a}thia Mar\c{c}al de Oliveira},
  title = {Organizing the Knowledge Used in Software Maintance},
  booktitle = {WM 2003: Professionelles Wissesmanagement - Erfahrungen und Visionen, Beitr{\"a}ge der 2. Konferenz Professionelles Wissensmanagement},
  volume = {28},
  pages = {65-72},
  year = {2003},
  annote = {internationalworkshop},
  editor = {Ulrich Reimer and Andreas Abecker and Steffen Staab and Gerd Stumme},
  isbn = {3-88579-357-1},
  tagnicolasa = {knowledge}}

@inproceedings{Dias11a,
  author = {Mart\'in Dias and Martinez Peck, Mariano and St\'ephane Ducasse and Gabriela Ar\'evalo},
  title = {Clustered Serialization with {Fuel}},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2011)},
  year = {2011},
  doi = {10.1145/2166929.2166930},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dia11a-IWST11-Fuel.pdf},
  abstract = {Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.},
  address = {Edinburgh, Scotland},
  annote = {internationalworkshop},
  hal-id = {inria-00614838},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter kzInfrastructure}}

@inproceedings{Dias13a,
  author = {Mart\'in Dias and Damien Cassou and St\'ephane Ducasse},
  title = {Representing Code History with Development Environment Events},
  booktitle = {IWST'13: International Workshop on Smalltalk Technologies 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias13a-IWST13-Epicea.pdf},
  abstract = {Modern development environments handle information about the intent of the programmer: for example, they use abstract syntax trees for providing high-level code manipulation such as refactorings; nevertheless, they do not keep track of this information in a way that would simplify code sharing and change understanding. In most Smalltalk systems, source code modifications are immediately registered in a transaction log often called a ChangeSet. Such mechanism has proven reliability, but it has several limitations. In this paper we analyse such limitations and describe scenarios and requirements for tracking fine-grained code history with a semantic representation. We present Epicea, an early prototype implementation. We want to enrich code sharing with extra information from the IDE, which will help understanding the intention of the changes and let a new generation of tools act in consequence.},
  annote = {internationalworkshop},
  hal-id = {hal-00862626},
  keywords = {pharo lse-pub kzMerging kzMeta}}

@article{Dias14a,
  author = {Mart\'in Dias and Martinez Peck, Mariano and St\'ephane Ducasse and Gabriela Ar\'evalo},
  title = {Fuel: A Fast General-Purpose Object Graph Serializer},
  journal = {Journal of Software: Practice and Experience},
  volume = {44},
  pages = {433-453},
  publisher = {John Wiley \& Sons, Ltd.},
  year = {2014},
  impactfactor = {Impact Factor (2012) 0.519},
  doi = {10.1002/spe.2136},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias14a-Official-SPE-Fuel.pdf},
  annote = {internationaljournal},
  hal-id = {hal-00703574},
  keywords = {lse-pub pharo kzInfrastructure}}

@techreport{Dias14b,
  author = {Mart\'in Dias and Uquillas G\'{o}mez, Ver\'{o}nica and Damien Cassou and St\'ephane Ducasse},
  title = {Software Integration Questions: A Quantitative Survey},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Dias14b-Survey.pdf},
  annote = {technicalReport},
  hal-id = {hal-01093496},
  institution = {INRIA Lille},
  keywords = {lse-pub},
  hal-url = {https://hal.inria.fr/hal-01093496}}

@inproceedings{Dias15a,
  author = {Mart\'in Dias and Alberto Bacchelli and Georgios
 Gousios and Damien Cassou and St\'ephane Ducasse},
  title = {Untangling Fine-Grained Code Changes},
  booktitle = {SANER'15: Proceedings of the 22nd International Conference on Software Analysis, Evolution, and Reengineering},
  pages = {341--350},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias15a-Saner-FineGrainedChanges.pdf},
  acceptnum = {39},
  accepttotal = {144},
  address = {Montreal, Canada},
  abstract = {After working for some time, developers commit their code changes to a version control system. When doing
 so, they often bundle unrelated changes (e.g., bug fix and refactoring) in a single commit, thus creating a so-called tangled commit. Sharing tangled commits is problematic because it makes review, reversion, and integration of these commits harder and historical analyses of the project less reliable. Researchers have worked at untangling existing commits, i.e., finding which part of a commit relates to which task. In this paper, we contribute to this line of work in two ways: (1) A publicly available dataset of untangled code changes, created with the help of two developers who accurately split their code changes into self contained tasks over a period of four months; (2) a novel approach, EpiceaUntangler, to help developers share untangled commits (aka. atomic commits) by using fine-grained code change information. EpiceaUntangler is based and tested on the publicly available dataset, and further evaluated by deploying it to 7 developers, who used it for 2 weeks. We recorded a median success rate of 91% and average one of 75\%, in automatically creating clusters of untangled fine-grained code changes.},
  annote = {internationalconference},
  hal-id = {hal-01116225},
  keywords = {lse-pub pharo kzAnalysis kzChange kzMerging},
  note = {(candidate for IEEE Research Best Paper Award)},
  hal-url = {https://hal.inria.fr/hal-01116225},
  pages = {341--350}}

@inproceedings{Dias15b,
  author = {Mart\'in Dias and Guillermo Polito and Damien Cassou and St\'ephane Ducasse},
  title = {DeltaImpactFinder: Assessing Semantic Merge Conflicts with Dependency Analysis},
  booktitle = {IWST'15: International Workshop on Smalltalk Technologies 2015},
  year = {2015},
  url = {https://hal.inria.fr/hal-01199035},
  abstract = {In software development, version control systems (VCS) provide branching and merging support tools. Such tools are popular among developers to concurrently change a codebase in separate lines and reconcile their changes automatically afterwards. However, two changes that are correct independently can introduce bugs when merged together. We call semantic merge conflicts this kind of bugs.
Change impact analysis (CIA) aims at estimating the effects of a change in a codebase. In this paper, we propose to detect semantic merge conflicts using CIA. On a merge, DELTAIMPACTFINDER analyzes and compares the impact of a change in its origin and destination branches. We call the difference between these two impacts the delta-impact. If the delta-impact is empty, then there is no indicator of a semantic merge conflict and the merge can continue automatically. Otherwise, the delta-impact contains what are the sources of possible conflicts.},
  annote = {internationalworkshop},
  keywords = {pharo lse-pub kzMerging kzMeta},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias15b-IWST-DeltaImpactFinder.pdf},
  hal-id = {hal-01199035}}

@phdthesis{Dias15c,
  author = {Mart\'in Dias},
  title = {Supporting Software Integration Activities with First-Class Code Changes},
  year = {2015},
  school = {University Lille 1 - Sciences et Technologies - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2015-Dias.pdf},
  hal-id = {tel-01247696v1},
  abstract = {In this work, we study the activities involved in codebase integration, and propose approaches to support integration. First, we conducted an exploratory study to understand what are the most relevant problems in integration activities that have little tool support. We used such information as guidelines to propose:
Epicea, a first-class change model and associated IDE tools and	EpiceaUntangler, an approach to help developers share untangled commits (aka. atomic commits) by using fine-grained code change information gathered from the IDE through Epicea model and tools.},
  month = {nov}}

@article{Dias16a,
  author = {Mart\'in Dias and St\'ephane Ducasse and Damien Cassou and Uquillas G\'{o}mez, Ver\'{o}nica},
  title = {Do Tools Support Code Integration? A Survey},
  journal = {Journal of Object Technology},
  volume = {16},
  pages = {2:1-20},
  year = {2016},
  doi = {10.5381/jot.2016.15.2.a2},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias16a-IntegratorSurvey.pdf},
  annote = {internationaljournal},
  keywords = {lse-pub kzMerging},
  number = {2},
  issn = {1660-1769},
  month = mar,
  pdf-second = {http://www.jot.fm/issues/issue_2016_02/article2.pdf}}

@inproceedings{Duca00a,
  author = {St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  title = {Tie Code And Questions: a Reengineering Pattern},
  booktitle = {Proceedings of EuroPLoP '2000},
  pages = {209--217},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00aTieCode.pdf},
  abstract = {Reengineering is an inherent aspect of modern software development, with its emphasis on iterative and incremental development. The reengineering pattern presented in this paper shows how you can support your understanding during system reengineering by linking your questions or information about the code in the code itself.},
  annote = {internationalworkshop},
  keywords = {snf-none olit scg-pub skip-doi jb00 stefPub kzPattern}}

@inproceedings{Duca00b,
  author = {Ducasse, St\'ephane and Lanza, Michele and Tichelaar, Sander},
  title = {Moose: an {Extensible} {Language}-{Independent} {Environment} for {Reengineering} {Object}-{Oriented} {Systems}},
  booktitle = {Proceedings of the 2nd International Symposium on Constructing Software Engineering Tools},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00bMooseCoset.pdf},
  abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. The reengineering of those systems often poses problems because of the considerable size and complexity of such systems. In the context of the FAMOOS project we have developed a language independent environment called Moose which can deal with that complexity. This paper describes the architecture of Moose, the tools which have been developed around it and the industrial experiences we have obtained.},
  annote = {internationalworkshop},
  keywords = {components scg-pub skip-doi repository oorp stefPub moose kzMoose},
  month = jun,
  series = {CoSET '00}}

@inproceedings{Duca00c,
  author = {St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  title = {Transform Conditionals to Polymorphism},
  booktitle = {Proceedings of EuroPLoP '2000},
  pages = {219--252},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00cTransform.pdf},
  abstract = {Conditionals -i.e., switch statements, nested ifs- that are used to simulate polymorphism hamper evolution and flexibility of applications. The reengineering patterns presented in this paper show you how to transform conditionals in object-oriented code to improve the flexibility of application.},
  annote = {internationalworkshop},
  keywords = {snf-none skip-doi olit scg-pub jb00 stefPub kzPattern}}

@inproceedings{Duca00d,
  author = {St\'ephane Ducasse and Thomas Hofmann and Oscar Nierstrasz},
  title = {OpenSpaces: An Object-Oriented Framework For Reconfigurable Coordination Spaces},
  booktitle = {Coordination Languages and Models},
  volume = {1906},
  pages = {1--19},
  year = {2000},
  misc = {acceptance rate: 18/52 = 35\%},
  doi = {10.1007/3-540-45263-X\_1},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00dOpenSpaces.pdf},
  abstract = {Tuple spaces have turned out to be one of the most fundamental abstractions for coordinating communicating agents. At the same time, researchers continue to propose new variants of tuple spaces, since no one approach seems to be universally applicable to all problem domains. Some models offer a certain configurability, but existing approaches generally stop at afixed set of configuration options and static configuration at instantiation time. We argue that a more open approach is needed, and present OpenSpaces, an object-oriented framework that supports static configurability through subclassing across several dimensions, as well as dynamic configurability of policies through runtime composition. We introduce OpenSpaces by showing how it can be used to instantiate a typical application, and we present an overview of the framework, implemented in Smalltalk, detailing the various degrees of configurability.},
  acceptnum = {18},
  accepttotal = {52},
  address = {Limassol, Cyprus},
  annote = {internationalconference},
  editor = {Ant{\'o}nio Porto and Gruia-Catalin Roman},
  isbn = {978-3-540-41020-1},
  keywords = {scg-pub coordination stefPub kzCoordination},
  month = sep,
  series = {LNCS}}

@inproceedings{Duca00f,
  author = {St\'ephane Ducasse and Michele Lanza and Lukas Steiger},
  title = {Supporting Evolution Recovery: a Query-based Approach},
  booktitle = {ECOOP 2000 International Workshop of Architecture Evolution},
  year = {2000},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-abstract skip-pdf skip-doi stefPub design-recovery moose kzHistory}}

@techreport{Duca00g,
  author = {St\'ephane Ducasse and Michele Lanza and Oscar Nierstrasz and Matthias Rieger and Sander Tichelaar},
  title = {BEOC Analysis Report},
  year = {2000},
  annote = {report notrefereed},
  institution = {University of Bern},
  keywords = {skip-abstract skip-pdf skip-doi stefPub kzOut}}

@article{Duca00x,
  author = {St\'ephane Ducasse and Florence Ducasse},
  title = {De l'enseignement de concepts informatiques},
  journal = {Journal de l'association EPI Enseignement Public et Informatiques},
  volume = {4},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00xExperienceEnseig.pdf},
  address = {13 rue du Jura, Paris 13},
  annote = {notrefereed},
  keywords = {scg-pub skip-abstract skip-doi stefPub kzTeaching},
  month = sep,
  number = 97}

@booklet{Duca00z,
  author = {St\'ephane Ducasse and Florence Ducasse},
  title = {Caro, Dis-moi c'est quoi programmer?},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/Duca00z-CaroLecturesFr.pdf},
  annote = {booklet},
  keywords = {scg-old scg-misc stefPub kzTeaching},
  note = {Support de cours de Technologie, 150 pages},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca00zCaroLecturesFr.pdf}}

@article{Duca01a,
  author = {St\'ephane Ducasse and Michele Lanza},
  title = {Towards a Methodology for the Understanding of Object-Oriented Systems},
  journal = {Technique et science informatiques},
  volume = {20},
  pages = {539--566},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca01aTowardsAMethod.pdf},
  abstract = {The reverse engineering of object-oriented legacy systems presents a number
of problems typically encountered in large-scale legacy systems: the lack of overview and
the need to focus on interesting parts. To help in reverse engineering large
object-oriented legacy systems, we proposed a hybrid approach combining the immediate
appeal of visualisations with the scalability of metrics. However, our approach lacked of a
methodology that guides the reverse engineer. In this paper we present a first methodology
that we developed from our industrial experiments.},
  annote = {nationaljournal},
  keywords = {scg-pub skip-doi jb01 snf02 stePub kzVisualization},
  number = {4}}

@article{Duca01b,
  author = {St\'ephane Ducasse and Michele Lanza and Sander Tichelaar},
  title = {The Moose Reengineering Environment},
  journal = {Smalltalk Chronicles},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca01bMoose.pdf},
  abstract = {This article presents the Moose Reengineering
 Environment, a language-independent tool environment
 to reverse engineer, i.e., understand, and
 reengineer software systems, as well as the tools
 which have been developed around it and the
 experience, both academic and industrial, we have
 obtained.},
  annote = {notrefereed},
  keywords = {scg-pub skip-doi reengineering stefPub moose kzEvolution},
  month = aug}

@techreport{Duca01c,
  author = {Ducasse, St\'ephane},
  title = {Reengineering Object-Oriented Applications},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca01cHab.pdf},
  abstract = {Reengineering object-oriented applications is becoming a vital activity in today industry where the developer turnover drains the system oral memory out of the systems themselves and where applications should constantly evolve to meet new requirements.	This document summarizes the research effort led on reverse engineering and reengineering ob ject-oriented legacy systems. It includes (1) the definition of a suitable meta-model for reengineering, FAMIX. This meta-model, even if flat, supports both reverse engineering and code refac- toring analysis, (2) the presentation of a reengineering platform, MOOSE, (3) the evalution of software metrics for reengineer, (4) the definition of simple visual techniques to support large system understanding or finer grain code element, (5) the identification and cure sup- port for duplicated code, (6) the use of dynamic information to support composable views and collaboration extraction, and (7) the identification of reengineer patterns.	Keywords. Meta-Modeling, Language Independence, Reengineering, Reverse Engineering, Code Duplication, Reengineering Patterns, Program Traces, Dynamic Information, Program Visualization, Software Metrics, Refactorings, Interexchange Format, CODECRAWLER, FAMIX, MOOSE, FAMOOS, Smalltalk, Java, C\+\+.},
  annote = {habilitation},
  institution = {Universit\'e Pierre et Marie Curie (Paris 6)},
  keywords = {scg-pub skip-doi jb-none reengineering snf02 stefPub moose kzHDR},
  month = sep,
  note = {TR University of Bern, Institute of Computer Science and Applied Mathematics --- iam-03-008}}

@article{Duca01s,
  author = {Ducasse, St\'ephane},
  title = {Squeak: Introspection},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = nov,
  number = 37}

@article{Duca01t,
  author = {St\'ephane Ducasse},
  title = {Squeak: Classes},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = oct,
  number = 36}

@article{Duca01u,
  author = {St\'ephane Ducasse},
  title = {Squeak: Syntaxe par l'example},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = sep,
  number = 35}

@article{Duca01v,
  author = {St\'ephane Ducasse},
  title = {Squeak: Une syntaxe minimaliste},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jul,
  number = 34}

@article{Duca01w,
  author = {St\'ephane Ducasse},
  title = {Squeak: Un smalltalk open-source d\'etonnant},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2001},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jun,
  number = 33}

@inproceedings{Duca02a,
  author = {St\'ephane Ducasse and Roel Wuyts},
  title = {Supporting Objects as An Anthropomorphic View at Computation or Why {Smalltalk} for Teaching Objects?},
  booktitle = {Proceedings of the Ecoop'02 International Educator Symposium},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca02aTeacherWorkshop.pdf},
  abstract = {In this paper we stress the fact that a language and an environment for teaching object-oriented programming should support the anthropomorphic metaphor promoted by the paradigm. We show that all the cultural aspects of Smalltalk, i.e., the vocabulary and the syntax support the object metaphor. In addition, we stress that the programming environment should also support the metaphor. We show that Smalltalk environments offer an important property we named liveness or object proximity that promotes the anthropomorphic perception of objects. By providing excerpt from our forth coming book, we show how Squeak with the Morphic framework reinforces this ability to make object into living entities.},
  annote = {internationalworkshop},
  keywords = {stefPub scg-pub skip-doi kzTeaching}}

@article{Duca02v,
  author = {St\'ephane Ducasse},
  title = {Refactoring Browser et SmallLint},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2002},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = sep,
  number = 46}

@article{Duca02w,
  author = {St\'ephane Ducasse},
  title = {SUnit: Ces tests que souvent l'on deteste},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2002},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jan,
  number = 39}

@article{Duca03a,
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Composing Embedded Real-Time Software Components: the {PECOS} Data-Centric Approach},
  journal = {ERCIM News},
  volume = {52},
  year = {2003},
  url = {http://www.ercim.org/publication/Ercim\_News/enw52/nierstrasz.html},
  abstract = {Although component-based software development (CBSD) has become mainstream for conventional applications, it has remained elusive for embedded applications due to non-functional constraints. The PECOS project has demonstrated that CBSD can also be applied to severely constrained embedded devices, with timing and memory requirements being taken into account.},
  annote = {notrefereed},
  cvs = {ErcimPecos},
  keywords = {scg-pub skip-doi pecos stefPub kzLanguageDesign},
  month = jan}

@inproceedings{Duca03b,
  author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
  title = {Open Surfaces for Controlled Visibility},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca03bSurfaces.pdf},
  abstract = {Current languages contain visibility mechanisms such as private, protected, or public to control who can see what. However, these visibility mechanisms are fixed once for all. Moreover, they do not solve all problems related to the visibility, and are typically of a static nature. In this position paper we present an open and uniform way of dealing with visibility and introduce surfaces: i.e., list of methods that control the way the behavior of an ob ject is accessible. We introduce two problems that other visibility mechanisms cannot solve, and show how surfaces can.},
  annote = {internationalworkshop},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub schaerli kzLanguageDesign},
  month = jul}

@inproceedings{Duca03c,
  author = {St\'ephane Ducasse and Philippe Mougin},
  title = {Power to Collections: Generalizing Polymorphism by Unifying Array Programming and Object-Oriented Programming},
  booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
  year = {2003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca03cOOPALEcoop.pdf},
  abstract = {Array programming shines in its ability to express computations at a high-level of abstraction, allowing one to manipulate and query whole sets of data at once. This paper presents the OOPAL model that enhances object-oriented programming with array programming features. The goal of OOPAL is to determine a minimum set of modifications that must be made to the traditional object model in order to take advantage of the possibilities of array programming. It is based on a minimal extension of method invocation and the definition of a kernel of methods implementing the fundamental array programming operations. The model is validated in F-SCRIPT, a new scripting language.},
  annote = {internationalworkshop},
  keywords = {snf03 scg-pub skip-doi jb03 stefPub kzLanguageDesign},
  month = jul}

@article{Duca03d,
  author = {St\'ephane Ducasse and Sander Tichelaar},
  title = {Dimensions of Reengineering Environment Infrastructures},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  volume = {15},
  pages = {345--373},
  year = {2003},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/smr.279},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca03dInfrastructures.pdf},
  abstract = {Over the last decade many research groups and commercial companies have been developing reengineering environments. However, many design decisions such as support for multiple models, incremental loading of information, tool integration, entity grouping, and their impacts on the underlying meta-model and resulting environment have remained implicit. Based on the experience accumulated while developing the Moose reengineering environment and on a survey of reengineering environments, we present a design space defined by a set of criteria that makes explicit the different options and especially their dependencies and trade-offs. Using this design space, developers of future environments should have a better understanding of the problems they face and the impact of design choices.},
  annote = {internationaljournal},
  keywords = {scg-pub recast04 jb04 stefPub moose kzTools kzEvolution},
  month = oct,
  number = 5}

@misc{Duca03e,
  author = {St\'ephane Ducasse},
  title = {{SUnit} Explained},
  pdf = {http://www.iam.unibe.ch/~ducasse/Programmez/OnTheWeb/SUnitEnglish2.pdf},
  abstract = {SUnit is a minimal yet powerful framework that supports the creation of tests. In this article we start by discussing why we test, then we present an example with SUnit and we go deep into the SUnit implementation.},
  keywords = {kzVulgarisation}}

@article{Duca03w,
  author = {St\'ephane Ducasse},
  title = {Seaside: Des composants pour le web},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation kzWeb},
  month = may,
  number = 53}

@article{Duca03x,
  author = {St\'ephane Ducasse},
  title = {Seaside: Des applications web complexes simplement...},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation kzWeb},
  month = apr,
  number = 52}

@article{Duca03y,
  author = {St\'ephane Ducasse},
  title = {Squeak: R\'eflexion pour Prototyper},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = mar,
  number = 51}

@article{Duca03z,
  author = {St\'ephane Ducasse},
  title = {Espionnage en Squeak},
  journal = {Programmez! Le Magazine du D\'eveloppement},
  volume = {1},
  year = {2003},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = feb,
  number = 50}

@inproceedings{Duca04a,
  author = {St\'ephane Ducasse and Michele Lanza and Roland Bertuli},
  title = {High-Level Polymetric Views of Condensed Run-Time Information},
  booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
  pages = {309--318},
  publisher = {IEEE Computer Society Press},
  year = {2004},
  misc = {acceptance rate: 33/62 = 52\%},
  doi = {10.1109/CSMR.2004.1281433},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04aRuntimePolymetricViews.pdf},
  abstract = {Understanding the run-time behavior of object-oriented legacy systems is a complex task due to factors such as late binding and polymorphism.	Current approaches extract and use information from the complete execution trace of a system. The sheer size and complexity of such traces make their handling, storage, and analysis difficult. Current software systems which run almost non-stop do not permit such a full analysis. In this paper we present a lightweight approach based on the extraction of a condensed amount of information, e.g., measurements, that does not require a full trace. Using this condensed information, we propose a visualization approach which allows us to identify and understand certain aspects of the objects' lifetime such as their role played in the creation of other objects and the communication architecture they support.},
  acceptnum = {33},
  accepttotal = {62},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {recast04 scg-pub stefPub jb04 moose kzVisualisation kzDynamicInformation}}

@inproceedings{Duca04b,
  author = {St\'ephane Ducasse and Michael Freidig and Roel Wuyts},
  title = {Logic and Trace-based Object-Oriented Application Testing},
  booktitle = {Fifth International Workshop on Object-Oriented Reengineering (WOOR 2004)},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04bTestLogicWoor04.pdf},
  abstract = {Due to the size and the extreme complexity of legacy systems, it is nearly impossible to write from scratch tests before refactoring them. In addition object-oriented legacy systems present specific requirements to test them. Indeed late-binding allow subclasses to change fundamental aspects of the superclass code and in particular call flows.	Moreover Object-oriented programming promotes a distribution of the responsibilities to multiple entities leading to complex scenario to be tested.	In such a context one of the few trustable source of information is the execution of the application itself. Traditional forward engineering approaches such as unit testing do not really provide adequate solution to this problem. Therefore there is a need for a more expressive way of testing the execution of object-oriented applications. We propose to represent the trace of object-oriented applications as logic facts and express tests over the trace.	This way complex sequences of message exchanges, sequence matching, or expression of negative information are expressed in compact form. We validated our approach by implementing TestLog a prototype tool and testing the Moose reengineering environment and a meta-interpreter.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi recast04 evolution visualization test stefPub kzDynamicInformation}}

@techreport{Duca04d,
  author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
  title = {A Top-Down Program Comprehension Strategy for Packages},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04dPackageVisualization.pdf},
  abstract = {Understanding packages is an important activity in the reengineering of large object-oriented systems.	The relationships between packages and their contained classes can affect the cost of modifying the system. The main problem of this task is to quickly grasp the structure of a package and how it interacts with the rest of the system. In this paper we present a top-down program comprehension strategy based on polymetric views, radar charts, and software metrics. We illustrate this approach on two applications and show how we can retrieve the important characteristics of packages.},
  annote = {report notrefereed},
  institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
  keywords = {jb05 scg-pub skip-doi stefPub snf04 recast05 moose kzMetric},
  number = {IAM-04-007},
  type = {Technical Report}}

@inproceedings{Duca04e,
  author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
  title = {Seaside --- a Multiple Control Flow Web Application Framework},
  booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
  pages = {231--257},
  year = {2004},
  misc = {Also Technical Report IAM-04-008},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04eSeaside.pdf},
  abstract = {Developing web applications is difficult since (1) the client-server relationship is asymmetric: the server cannot update clients but only responds to client requests and (2) the navigation facilities of web browsers lead to a situation where servers cannot control the state of the clients. Page-centric web application frameworks fail to offer adequate solutions to model control flow at a high-level of abstraction. Developers have to work manually around the shortcomings of the HTTP protocol. Some approaches offer better abstractions by composing an application out of components, however they still fail to offer modeling control flow at a high level. Continuation-based approaches solve this problem by providing the facilities to model a control flow over several pages with one piece of code. However combining multiple flows inside the same page is difficult. This article presents Seaside. Seaside is a framework which combines an object-oriented approach with a continuation-based one. A Seaside application is built out of components (i.e., objects) and the logic of the application benefits from the continuation-based program flow infrastructure. Seaside offers a unique way to have multiple control flows on a page, one for each component. This enables the developer to write components that are highly reusable and that can be used to compose complex web applications with higher quality in less time.},
  annote = {internationalconference},
  cvs = {seaside},
  keywords = {scg-pub skip-doi stefPub seaside kzWeb},
  month = sep}

@inproceedings{Duca04f,
  author = {St\'ephane Ducasse and Tudor G\^irba and Jean-Marie Favre},
  title = {Modeling Software Evolution by Treating History as a First Class Entity},
  booktitle = {Proceedings Workshop on Software Evolution Through Transformation (SETra 2004)},
  pages = {75--86},
  publisher = {Elsevier},
  year = {2004},
  doi = {10.1016/j.entcs.2004.08.035},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca04fHismo.pdf},
  abstract = {The histories of software systems hold useful information when reasoning about the systems at hand or about general laws of software evolution. Yet, the approaches developed so far, do not rely on an explicit meta-model and do not facilitate the comparison of different evolutions. We argue for the need to define history as a first class entity and propose a meta-model centered around the notion of history. We show the usefulness of our a meta-model by discussing the different analysis it enables.},
  address = {Amsterdam},
  annote = {internationalworkshop},
  keywords = {scg-pub evolution van stefPub recast05 girba hismo moose kzMeta}}

@incollection{Duca05a,
  author = {St\'ephane Ducasse and Tudor G\^irba and Michele Lanza and Serge Demeyer},
  title = {Moose: a Collaborative and Extensible Reengineering Environment},
  booktitle = {Tools for Software Maintenance and Reengineering},
  pages = {55--71},
  publisher = {Franco Angeli},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05aMooseBookChapter.pdf},
  abstract = {Software systems are complex and difficult to analyze. Reverse engineering is a complex analysis that usually involves combining different techniques and tools. Moreover, oftentimes the existing tools are not perfectly suitable for the task, and customization of existing tools, or development of new tools is required. Moose is an extensible reengineering environment designed to provide the necessary infrastructure for tool integration. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and advanced tool integration mechanism.},
  address = {Milano},
  annote = {articlebook},
  isbn = {88-464-6396-X},
  keywords = {moose scg-pub skip-doi jb05 recast05 stefPub jointERCIM girba kzMoose kzEvolution},
  series = {RCOST / Software Technology Series}}

@article{Duca05b,
  author = {St\'ephane Ducasse and Michele Lanza},
  title = {The {Class} {Blueprint}: Visually Supporting the Understanding of Classes},
  journal = {Transactions on Software Engineering (TSE)},
  volume = {31},
  pages = {75--90},
  publisher = {IEEE Computer Society},
  year = {2005},
  impactfactor = {5 Year ISI impact factor (2010) 4.865},
  doi = {10.1109/TSE.2005.14},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05bTSEClassBlueprint.pdf},
  abstract = {Understanding source code is an important task in the maintenance of software systems. Legacy systems are not only limited to procedural languages, but are also written in object-oriented languages. In such a context, understanding classes is a key activity as they are the cornerstone of the object-oriented paradigm and the primary abstraction from which applications are built. Such an understanding is however difficult to obtain because of reasons such as the presence of late binding and inheritance. A first level of class understanding consists of the understanding of its overall structure, the control flow among its methods, and the accesses on its attributes. We propose a novel xvisualization of classes called class blueprint that is based on a semantically enriched visualization of the internal structure of classes. This visualization allows a software engineer to build a first mental model of a class that he validates via opportunistic code-reading. Furthermore, we have identified visual patterns that represent recurrent situations and as such convey additional information to the viewer. The contributions of this article are the class blueprint, a novel visualization of the internal structure of classes, the identification of visual patterns, and the definition of a vocabulary based on these visual patterns. We have performed several case studies of which one is presented in depth, and validated the usefulness of the approach in a controlled experiment.},
  annote = {internationaljournal},
  keywords = {scg-pub stefPub recast05 mooseCincom moose kzVisualization},
  month = jan,
  number = {1}}

@inproceedings{Duca05d,
  author = {St\'ephane Ducasse and Tudor G\^irba},
  title = {Being a Long-Living Software Mayor --- the SimCity Metaphor to Explain the Challenges Behind Software Evolution},
  booktitle = {Proceedings of CHASE International Workshop 2005},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05dChaseSimCity.pdf},
  annote = {internationalworkshop},
  keywords = {stefPub jb05 kzEvolution}}

@inproceedings{Duca05e,
  author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
  title = {Butterflies: A Visual Approach to Characterize Packages},
  booktitle = {Proceedings of the 11th IEEE International Software Metrics Symposium (METRICS'05)},
  pages = {70--77},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 39/89 = 44\%},
  doi = {10.1109/METRICS.2005.15},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05e-Metrics-Butterflies-Ponisio.pdf},
  abstract = {Understanding sets of classes, or packages, is an important activity in the
development and reengineering of large object-oriented systems. Packages represent the
coarse-grained structure of an application. They are artefacts to deploy and structure
software, and therefore more than a simple generalization of classes. The relationships
between packages and their contained classes are key in the decomposition of an application
and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a
package and to understand how a package interacts with the rest of the system. We tackle
this problem using butterfly visualizations, i.e. dedicated radar charts built from simple
package metrics based on a language-independent meta-model. We illustrate our approach on
two applications and show how we can retrieve the relevant characteristics of packages.},
  acceptnum = {39},
  accepttotal = {89},
  annote = {internationalconference},
  keywords = {scg-pub stefPub moose recast06 kzMetric},
  rate = {44\%},
  pdf-second = {http://rmod.inria.fr/archive/papers/Duca05ePackageVisualization.pdf}}

@inproceedings{Duca05f,
  author = {St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {{Moose}: an Agile Reengineering Environment},
  booktitle = {Proceedings of ESEC/FSE 2005},
  pages = {99--102},
  year = {2005},
  doi = {10.1145/1081706.1081723},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05fMooseDemo.pdf},
  abstract = {Software systems are complex and difficult to analyze. Reengineering is a complex activity that usually involves combining different techniques and tools. Moose is an reengineering environment designed to provide the necessary infrastructure for building new tools and for integrating them. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and meta-descriptions. Several tools have been built on top of Moose dealing with different aspects of reengineering like: visualization, evolution analysis, semantic analysis, concept analysis or dynamic analysis.},
  annote = {conference},
  keywords = {scg-pub moose stefPub recast06 girba kzEvolution kzMoose},
  month = sep,
  note = {Tool demo}}

@article{Duca05g,
  author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
  title = {Uniform and Safe Metaclass Composition},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {31},
  pages = {143--164},
  publisher = {Elsevier},
  year = {2005},
  impactfactor = {Impact factor (2009) 0.619},
  doi = {10.1016/j.cl.2004.11.003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05ySafeMetaclassTrait.pdf},
  abstract = {In pure object-oriented languages, classes are objects, instances of other classes called metaclasses. In the same way as classes define the properties of their instances, metaclasses define the properties of classes. It is therefore very natural to wish to reuse class properties, utilizing them amongst several classes. However this introduced metaclass composition problems, i.e., code fragments applied to one class may break when used on another class due to the inheritance relationship between their respective metaclasses.	Numerous approaches have tried to solve metaclass composition problems, but they always resort to an ad-hoc manner of handling conflicting properties, alienating the meta-programmer. We propose a uniform approach that represents class properties as traits, groups of methods that act as a unit of reuse from which classes are composed. Like all the other classes in the system, metaclasses are composed out of traits. This solution supports the reuse of class properties, and their safe and automatic composition based on explicit conflict resolution. The paper discusses traits and our solution, shows concrete examples implemented in the Smalltalk environment Squeak, and compares our approach with existing models for composing class properties.},
  aeresstastus = {2008},
  annote = {internationaljournal},
  keywords = {scg-pub stefPub kzReflection},
  month = dec,
  number = {3-4}}

@inproceedings{Duca05h,
  author = {St\'ephane Ducasse and Lukas Renggli and Roel Wuyts},
  title = {{SmallWiki} --- A Meta-Described Collaborative Content Management System},
  booktitle = {Proceedings ACM International Symposium on Wikis (WikiSym'05)},
  pages = {75--82},
  publisher = {ACM Computer Society},
  year = {2005},
  doi = {10.1145/1104973.1104981},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05hSmallwikiWikiSymp05.pdf},
  abstract = {Wikis are often implemented using string-based approaches to parse and generate their pages. While such approaches work well for simple wikis, they hamper the customization and adaptability of wikis to the variety of end-users when more sophisticated needs are required (i.e., different output formats, user-interfaces, wiki managment, security policies, ...). In this paper we present SmallWiki, the second version of a fully object-oriented implementation of a wiki. SmallWiki is implemented with objects from the top to the bottom and it can be customized easily to accommodate new needs. In addition, SmallWiki is based on a powerful meta-description called Magritte that allows one to create user-interface elements declaratively.},
  address = {New York, NY, USA},
  annote = {internationalconference},
  cvs = {SmallWikiTwoOOPSLASymp2005},
  keywords = {scg-pub snf-none stefPub kzOut}}

@inproceedings{Duca05i,
  author = {St\'ephane Ducasse and Michele Lanza and Romain Robbes},
  title = {Multi-level Method Understanding Using {Microprints}},
  booktitle = {Proceedings of {VISSOFT} 2005 (3th IEEE International Workshop on Visualizing Software for Understanding)},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca05imicroprintsVissoft.pdf},
  abstract = {Understanding classes and methods is a key activity in object-oriented programming, since classes represent the primary abstractions from which applications are built, while methods contain the actual program logic. The main problem of this task is to quickly grasp the purpose and inner structure of a class. To achieve this goal, one must be able to overview multiple methods at once. In this paper, we present microprints, pixel-based representations of methods enriched with semantical information. We present three specialized microprints each dealing with a specific aspect we want to understand of methods: (1) state access, (2) control flow, and (3) invocation relationship.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub recast06 kzVisualization},
  month = sep}

@book{Duca05j,
  author = {St\'ephane Ducasse},
  title = {Squeak: Learn Programming with Robots},
  publisher = {APress},
  year = {2005},
  annote = {book},
  keywords = {stefPub scg-pub kzVulgarisation kzBook},
  note = {ISBN: 1-59059-491-6}}

@misc{Duca05k,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {Squeak: un Smalltalk libre multim\'edia},
  journal = {Linux Pratique},
  volume = {1},
  pages = {18--23},
  year = {2005},
  aeresstastus = {2008},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = mar,
  number = 89}

@inproceedings{Duca06a,
  author = {St\'ephane Ducasse and Tudor G\^irba and Roel Wuyts},
  title = {Object-Oriented Legacy System Trace-based Logic Testing},
  booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
  pages = {35--44},
  publisher = {IEEE Computer Society Press},
  year = {2006},
  misc = {acceptance rate: 27/65 = 42 \%},
  doi = {10.1109/CSMR.2006.37},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06aTestLogtestingCSMR.pdf},
  abstract = {When reengineering legacy systems, it is crucial to assess if the legacy behavior has been preserved or how it changed due to the reengineering effort.	Ideally if a legacy system is covered by tests, running the tests on the new version can identify potential differences or discrepancies. However, writing tests for an unknown and large system is difficult due to the lack of internal knowledge. It is especially difficult to bring the system to an appropriate state. Our solution is based on the acknowledgment that one of the few trustable piece of information available when approaching a legacy system is the running system itself. Our approach reifies the execution traces and uses logic programming to express tests on them. Thereby it eliminates the need to programatically bring the system in a particular state, and handles the test-writer a high-level abstraction mechanism to query the trace. The resulting system, called TESTLOG, was used on several real-world case studies to validate our claims.},
  acceptnum = {27},
  accepttotal = {65},
  annote = {internationalconference},
  keywords = {scg-pub recast06 stefPub kzDynamicInformation},
  medium = {2}}

@article{Duca06b,
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Nathanael Sch{\"a}rli and Roel Wuyts and Andrew P. Black},
  title = {Traits: A Mechanism for fine-grained Reuse},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume = {28},
  pages = {331--388},
  year = {2006},
  impactfactor = {5-Year ISI impact factor (2010) 1.478},
  doi = {10.1145/1119479.1119483},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06bTOPLASTraits.pdf},
  abstract = {Inheritance is well-known and accepted as a mechanism for reuse in object-oriented languages.	Unfortunately, due to the coarse granularity of inheritance, it may be difficult to decompose an application into an optimal class hierarchy that maximizes software reuse. Existing schemes based on single inheritance, multiple inheritance, or mixins, all pose numerous problems for reuse. To overcome these problems we propose traits, pure units of reuse consisting only of methods. We develop a formal model of traits that establishes how traits can be composed, either to form other traits, or to form classes. We also outline an experimental validation in which we apply traits to refactor a non-trivial application into composable units.},
  annote = {internationaljournal},
  cvs = {TraitsTOPLAS2005},
  issn = {0164-0925},
  keywords = {scg-pub stefPub toplas traits schaerli kzTrait},
  month = mar,
  number = {2},
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06bTOPLASTraits.pdf}}

@inproceedings{Duca06c,
  author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn},
  title = {Distribution Map},
  booktitle = {Proceedings of 22nd IEEE International Conference on Software Maintenance},
  pages = {203--212},
  publisher = {IEEE Computer Society},
  year = {2006},
  misc = {acceptance rate: 41/147 = 28\%},
  doi = {10.1109/ICSM.2006.22},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06cDistributionMap.pdf},
  abstract = {Understanding large software systems is a challenging task, and to support it many approaches have been developed. Often, the result of these approaches categorize existing entities into new groups or associates them with mutually exclusive properties. In this paper we present the Distribution Map as a generic technique to visualize and analyze this type of result. Our technique is based on the notion of focus, which shows whether a property is well-encapsulated or cross-cutting, and the notion of spread, which shows whether the property is present in several parts of the system.	We present a basic visualization and complement it with measurements that quantify focus and spread. To validate our technique we show evidence of applying it on the result sets of different analysis approaches. As a conclusion we propose that the Distribution Map technique should belong to any reverse engineering toolkit.},
  acceptnum = {41},
  accepttotal = {147},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub stefPub moose recast07 kzVisualization},
  medium = {2},
  rate = {28\%},
  series = {ICSM'06}}

@inproceedings{Duca06d,
  author = {St\'ephane Ducasse and Tudor G\^irba},
  title = {Using {Smalltalk} as a Reflective Executable Meta-Language},
  booktitle = {International Conference on Model Driven Engineering Languages and Systems (Models/UML 2006)},
  volume = {4199},
  pages = {604--618},
  publisher = {Springer-Verlag},
  year = {2006},
  doi = {10.1007/11880240\_42},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06dMOOSEMODELS2006.pdf},
  abstract = {Object-oriented meta-languages such as MOF or EMOF are often used to specify domain specific languages.	However, these meta-languages lack the ability to describe behavior or operational semantics. Several approaches used a subset of Java mixed with OCL as executable meta-languages. In this paper, we report our experience of using Smalltalk as an executable and integrated meta-language. We validated this approach in incrementally building over the last decade, Moose, a meta-described reengineering environment. The reflective capabilities of Smalltalk support a uniform way of letting the base developer focus on his tasks while at the same time allowing him to meta-describe his domain model. The advantage of our this approach is that the developer uses the same tools and environment},
  address = {Berlin, Germany},
  annote = {internationalconference},
  isbn = {978-3-540-45772-5},
  keywords = {scg-pub girba moose stefPub recast07 norex06 kzMeta},
  medium = {2},
  rate = {28\%},
  series = {LNCS}}

@misc{Duca06e,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {La syntaxe Smalltalk par la pratique},
  journal = {Linux Magazine},
  volume = {1},
  pages = {18--23},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = may,
  number = 83}

@misc{Duca06f,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Seaside: d\'eveloppement d'applications web en Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = sep,
  number = 86}

@misc{Duca06g,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Seaside: d\'evelopper des composants r\'eutilisables},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = nov,
  number = 88}

@article{Duca06h,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Smalltalk: un mod\`ele pur objet},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = dec,
  number = 89}

@article{Duca06i,
  author = {St\'ephane Ducasse and Oscar Nierstrasz and Matthias Rieger},
  title = {On the Effectiveness of Clone Detection by String Matching},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  volume = {18},
  pages = {37--58},
  year = {2006},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/smr.317},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca06iDuplocJSMEPaper.pdf},
  abstract = {Although duplicated code is known to pose severe problems for software maintenance, it is difficult to identify in large systems. Many different techniques have been developed to detect software clones, some of which are very sophisticated, but are also expensive to implement and adapt.	Lightweight techniques based on simple string matching are easy to implement, but how effective are they? We present a simple stringbased approach which we have successfully applied to a number of different languages such COBOL, {Java}, C\+\+, Pascal, Python, Smalltalk, C and PDP-11 assembler. In each case the maximum time to adapt the approach to a new language was less than 45 minutes. In this article we investigate a number of simple variants of string-based clone detection that abstract away from common editing operations, and assess the quality of clone detection for very different case studies. Our results confirm that this inexpensive clone detection technique generally achieves high recall and acceptable precision. Over-zealous normalization of the code before comparison, however, can result in unacceptable numbers of false positives.},
  annote = {internationaljournal},
  cvs = {DuplocJournalPaper},
  keywords = {scg-pub recast06 jb06 stefPub duploc kzDuplication},
  month = jan,
  number = 1}

@article{Duca07a,
  author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
  title = {Seaside: A Flexible Environment for Building Dynamic Web Applications},
  journal = {IEEE Software},
  volume = {24},
  pages = {56--63},
  publisher = {IEEE Computer Society},
  year = {2007},
  impactfactor = {5-year ISI impact factor (2010) 2.551},
  doi = {10.1109/MS.2007.144},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca07a-IEEESoftware-Seaside.pdf},
  abstract = {Nowadays, many complex applications are built with a web browser as their main user interface. However, despite the increasing popularity of the web as an application platform, implementing and maintaining web applications still remains difficult and lags behind conventional desktop application development.	The underlying technologies such as HTTP for the interaction and XHTML/CSS for the presentation were originally built to display and link static documents. Unfortunately, most mainstream frameworks provide only little abstraction over the page-oriented structure imposed by those technologies. Inevitably, the goto-like manner of how pages are linked leads to spaghetti code and hampers reuse. In this article we present Seaside, a web application framework that provides an uniform and pure object-oriented view on web applications.	In this way, Seaside avoids the unwieldily goto-like style. Exploiting the reflective features of Smalltalk, Seaside reintroduces procedure call abstraction in the client-server context. Seaside's key concepts are: (i) a component architecture supporting multiple, simultaneously active control flows, (ii) a programmatic XHTML generation, and (iii) fully supported on-the-fly debugging, code-editing, and recompilation. In this article we discuss these key features of Seaside and explain how they are made possible by the dynamic nature and the reflective capabilities of Smalltalk.},
  address = {Los Alamitos, CA, USA},
  annote = {internationaljournal},
  issn = {0740-7459},
  keywords = {scg-pub seaside kzWeb},
  number = {5}}

@inproceedings{Duca07b,
  author = {St\'ephane Ducasse and Roel Wuyts and Alexandre Bergel and Oscar Nierstrasz},
  title = {User-Changeable Visibility: Resolving Unanticipated Name Clashes in Traits},
  booktitle = {Proceedings of 22nd International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'07)},
  pages = {171--190},
  publisher = {ACM Press},
  year = {2007},
  misc = {Acceptance rate: 33/156=21\%},
  doi = {10.1145/1297027.1297040},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca07b-FreezableTrait.pdf},
  abstract = {A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts.	Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.},
  acceptnum = {33},
  accepttotal = {156},
  address = {New York, NY, USA},
  annote = {internationalconference topconference},
  isbn = {978-1-59593-786-5},
  keywords = {stefPub alexPub scg-pub kzTrait},
  location = {Montreal, Quebec, Canada},
  medium = {2},
  month = oct,
  rate = {21\%}}

@inproceedings{Duca07c,
  author = {St\'ephane Ducasse and Damien Pollet and Mathieu Suen and Hani Abdeen and Ilham Alloui},
  title = {Package Surface Blueprints: Visually Supporting the Understanding of Package Relationships},
  booktitle = {ICSM'07: Proceedings of the IEEE International Conference on Software Maintenance},
  pages = {94--103},
  year = {2007},
  misc = {acceptance rate: 46/214 = 21\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca07cPackageBlueprintICSM2007.pdf},
  abstract = {Large object-oriented applications are structured over large number of packages. Packages are important but complex structural entities that may be difficult to understand since they play different development roles (i.e., class containers, code ownership basic structure, architectural elements...). Maintainers of large applications face the problem of understanding how packages are structured in general and how they relate to each others. In this paper, we present a compact visualization, named Package Surface Blueprint, that qualifies the relationships that a package has with its neighbours. A Package Surface Blueprint represents packages around the notion of package surfaces: groups of relationships according to the packages they refer to. We present two specific views one stressing the references made by a package and another showing the inheritance structure of a package. We applied the visualization on two large case studies: ArgoUML and Squeak.},
  acceptnum = {46},
  accepttotal = {214},
  annote = {internationalconference stefPub},
  keywords = {moose kzCycle kzVisualization},
  rate = {21\%}}

@misc{Duca07o,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {R\'eflexion en Squeak},
  journal = {Linux Magazine},
  volume = {1},
  year = {2007},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub kzVulgarisation},
  month = nov,
  number = 99}

@misc{Duca07p,
  author = {St\'ephane Ducasse and Serge Stinckwich},
  title = {Introspection et m\'eta-manipulations en Squeak},
  journal = {Linux Magazine},
  volume = {1},
  year = {2007},
  annote = {vulgarisation},
  keywords = {pharo-pub lse-pub kzVulgarisation},
  month = apr,
  number = 93}

@misc{Duca07y,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {Smalltalk et design patterns, un couple assorti},
  journal = {Linux Magazine},
  volume = {1},
  pages = {18--23},
  year = {2007},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = mar,
  number = 92}

@misc{Duca07z,
  author = {St\'ephane Ducasse and Hilaire Fernandes},
  title = {Tests unitaires en Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  pages = {18--23},
  year = {2007},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = may,
  number = 94}

@article{Duca08a,
  author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn and Lukas Renggli},
  title = {Meta-Environment and Executable Meta-Language using {Smalltalk}: an Experience Report},
  journal = {Journal of Software and Systems Modeling (SOSYM)},
  volume = {8},
  pages = {5--19},
  publisher = {Springer Verlag},
  year = {2009},
  impactfactor = {Impact Factor (2011) 1.061},
  doi = {10.1007/s10270-008-0081-4},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca08a-Sosym-ExecutableMetaLanguage.pdf},
  abstract = {No abstract},
  annote = {internationaljournal cook-pub remoose1-pub},
  hal-id = {hal-00746255},
  keywords = {stefPub kzMeta},
  month = feb,
  number = {1}}

@inproceedings{Duca08b,
  author = {St\'ephane Ducasse and Tudor G\^irba and Orla Greevy and Michele Lanza and Oscar Nierstrasz},
  title = {Workshop on {FAMIX} and {Moose} in Software Reengineering ({FAMOOSr} 2008)},
  booktitle = {15th Working Conference on Software Maintenance and Reengineering (WCRE 2008)},
  pages = {343--344},
  year = {2008},
  doi = {10.1109/WCRE.2008.51},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca08bFAMOOSr2008.pdf},
  abstract = {The increasing amount of data available about software systems poses new challenges for re- and reverse engineering research, as the proposed approaches need to scale. In this context, concerns about meta-modeling and analysis techniques need to be augmented by technical concerns about how to reuse and how to build upon the efforts of previous research. Moose is an extensive infrastructure for reverse engineering evolved for over 10 years that promotes the reuse of engineering efforts in research. Moose accommodates various types of data modeled in the FAMIX family of meta-models. The goal of this half-day workshop is to strengthen the community of researchers and practitioners who are working in re- and reverse engineering, by providing a forum for building future research starting from Moose and FAMIX as shared infrastructure.},
  annote = {workshop},
  keywords = {scg08 scg-pub greevy girba jb09 hasler08 moose stefPub kzFeature kzDynamicInformation},
  month = oct}

@inproceedings{Duca09a,
  author = {Ducasse, St\'ephane and Pollet, Damien and Bergel, Alexandre and Cassou, Damien},
  title = {Reusing and Composing Tests with Traits},
  booktitle = {TOOLS'09: Proceedings of the 47th International Conference on Objects, Models, Components, Patterns},
  pages = {252--271},
  year = {2009},
  misc = {acceptance rate: 17/67 = 25\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca09a-Tools2009-TraitTests.pdf},
  abstract = {Single inheritance often forces developers to
 duplicate code and logic. This widely recognized
 situation affects both business code and tests. In a
 large and complex application whose classes
 implement many groups of methods (protocols),
 duplication may also follow the application's
 idiosyncrasies, making it difficult to specify,
 maintain, and reuse tests. The research questions we
 faced are (i) how can we reuse test specifications
 across and within complex inheritance hierarchies,
 especially in presence of orthogonal protocols; (ii)
 how can we test interface behavior in a modular way;
 (iii) how far can we reuse and parametrize
 composable tests. In this paper, we compose tests
 out of separately specified behavioral units of
 reuse ---traits. We propose test traits, where: (i)
 specific test cases are composed from independent
 specifications; (ii) executable behavior
 specifications may be reused orthogonally to the
 class hierarchy under test; (iii) test fixtures are
 external to the test specifications, thus are easier
 to specialize. Traits have been successfully applied
 to test two large and critical class libraries in
 Pharo, a new Smalltalk dialect based on Squeak, but
 are applicable to other languages with traits.},
  acceptnum = {17},
  accepttotal = {67},
  address = {Zurich, Switzerland},
  annote = {internationalconference},
  coreranking = {B},
  hal-id = {inria-00403568},
  keywords = {tools09 traits stefPub pharo pharo-pub kzTrait},
  month = jun,
  rate = {24\%}}

@inproceedings{Duca09b,
  author = {Ducasse, St\'ephane and Denker, Marcus and Lienhard, Adrian},
  title = {Evolving a Reflective Language},
  booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
  pages = {82--86},
  publisher = {ACM},
  year = {2009},
  doi = {10.1145/1735935.1735949},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca09b-IWST09-TraitMop.pdf},
  abstract = {Traits are method groups that can be used to compose classes. They do not have a runtime existence and are conceptually folded into the classes that use them. Traits have been implemented in different languages. While implementing them in Smalltalk, our first reflex was to take advantage of the fact that traits are not run-time entities: we optimized the implementation for space and hence shared methods between traits and classes. However, by doing so we broke the introspective API of Smalltalk. This paper illustrates a more general problem seen in all reflective systems: the implementation serves both as a model for execution and as the model that is exposed to the programmer. There is a conflict of interests between the information necessary for execution and the information the programmer is interested in. In addition, as soon as the implementation is exposed via reflection, we are not free to optimize. As the complete implementation is visible reflectively, there is no way to hide the optimizations. Few papers report errors and this is one of them. We report our experience facing the initial API mismatch, which has a significant impact on the system because the language is reflective (i.e., written in itself and causally connected). We present the new introspective API we put in place.},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {hal-00746130},
  isbn = {978-1-60558-899-5},
  keywords = {stefPub internationalworkshop lse-pub pharo pharo-pub kzTrait},
  location = {Brest, France},
  month = {aug},
  series = {IWST'09}}

@article{Duca09c,
  author = {Ducasse, St\'ephane and Pollet, Damien},
  title = {Software Architecture Reconstruction: A Process-Oriented Taxonomy},
  journal = {IEEE Transactions on Software Engineering},
  volume = {35},
  pages = {573-591},
  year = {2009},
  impactfactor = {5-year ISI impact factor (2010) 4.865},
  doi = {10.1109/TSE.2009.19},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca09c-TSE-SOAArchitectureExtraction.pdf},
  abstract = {To maintain and understand large applications, it is crucial to know their
architecture. The first problem is that unlike classes and packages, architecture is not
explicitly represented in the code. The second problem is that successful applications
evolve over time, so their architecture inevitably drifts. Reconstructing the architecture
and checking whether it is still valid is therefore an important aid. While there is a
plethora of approaches and techniques supporting architecture reconstruction, there is no
comprehensive state of the art and it is often difficult to compare the approaches. This
article presents a state of the art in software architecture reconstruction approaches.},
  annote = {internationaljournal},
  hal-id = {inria-00498407},
  keywords = {lse-pub StefPub kzArchi},
  month = jul,
  number = 4}

@techreport{Duca09t,
  author = {St\'ephane Ducasse and Simon Denier and Fran\c{c}oise Balmas and Alexandre Bergel and Jannik Laval and Karine Mordal-Manet and Fabrice Bellingard},
  title = {Visualization of Practices and Metrics (Squale Deliverable 1.2)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca09t-Squale-deliverable12-MetricVisualization.pdf},
  abstract = {Measuring applications is a challenge and one of the goal of the Squale project is to propose a sound quality model. Now presenting the results of such analysis is also a challenge since it is complex to output and present to the user for the following reasons: first a lot of data should be presented and at different audience. Second displaying information is one aspect another one is navigating the information. Finally it is important not to overwhelm the users with too much visualizations. This deliverable presents a state of the art in terms of software visualization approaches that are specifically designed to display metrics. In addition it sets up the context for the application of such visualization to practices.},
  annote = {technicalreport},
  hal-id = {inria-00533618},
  institution = {INRIA},
  keywords = {squale-pub lse-pub deliverable12 kzMetric kzVisualization}}

@techreport{Duca09x,
  author = {St\'ephane Ducasse and Nicolas Anquetil and Marcus Denker and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2009 Activity Report},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca09x-RAWEB-RMOD-2009-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team. A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-00639727},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@book{Duca10a,
  author = {St\'ephane Ducasse and Lukas Renggli and C. David Shaffer and Rick Zaccone and Michael Davies},
  title = {Dynamic Web Development with Seaside},
  pages = {371},
  publisher = {Square Bracket Associates},
  year = {2010},
  url = {http://book.seaside.st/book},
  abstract = {Seaside is the open source framework of choice for developing sophisticated and dynamic web applications. Seaside uses the power of objects to master the web. With Seaside web applications is as simple as building desktop applications. Seaside lets you build highly dynamic and interactive web applications. Seaside supports agile development through interactive debugging and unit testing.	Seaside is based on Smalltalk, a proven and robust language implemented by different vendors. Seaside is now available for all the major Smalltalk including Pharo, Squeak, GNU Smalltalk, Cincom Smalltalk, GemStone Smalltalk, and VA Smalltalk.},
  annote = {book},
  hal-id = {inria-00531503},
  inriareport = {2010},
  isbn = {978-3-9523341-1-9},
  keywords = {skipdoi remoose2-pub pharo-pub pharo kzWeb}}

@misc{Duca10t,
  author = {St\'ephane Ducasse and Alexandre Bergel},
  title = {Exceptions en Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  year = {2008},
  annote = {vulgarisation},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub pharo kzVulgarisation},
  month = nov,
  number = 110}

@techreport{Duca10x,
  author = {St\'ephane Ducasse and Nicolas Anquetil and Marcus Denker and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2010 Activity Report},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca10x-RAWEB-RMOD-2010-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-00639726},
  inriareport = {2010},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@inproceedings{Duca11a,
  author = {St\'ephane Ducasse and Manuel Oriol and Alexandre Bergel},
  title = {Challenges to support automated random testing for dynamically typed languages},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2011)},
  year = {2011},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca11a-IWST11-RandomTesting.pdf},
  abstract = {Automated random testing is a proven way to identify bugs and precondition violations, and this even in well tested libraries.
In the context of statically typed languages, current automated random testing tools heavily take advantage of static method declaration (argument types, thrown exceptions) to constrain input domains while testing and to identify errors. For such reason, automated random testing has not been investigated in the context of dynamically typed languages. In this paper we present the key challenges that have to be addressed to support automated testing in dynamic languages.},
  address = {Edinburgh, Scotland},
  annote = {internationalworkshop},
  hal-id = {inria-00614769},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzChecking}}

@techreport{Duca11b,
  author = {St\'ephane Ducasse and Nicolas Anquetil and Usman Bhatti and Cavalcante Hora, Andre},
  title = {Software Metrics for Package Remodularisation},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca11b-Cutter-deliverable11-SoftwareMetrics.pdf},
  abstract = {There is a plethora of software metrics \cite{Lore94a, Fent96a, Hend96a, Han00a, Lanz06a} and a large amount of research articles.	Still there is a lack for a serious and practically-oriented evaluation of metrics. Often metrics lack the property that the software reengineer or quality expert can easily understand the situation	summarized by the metrics.	In particular, since the exact notion of coupling and cohesion is complex, a particular focus on such point is important. In the first chapter of the present document, we present a list of software metrics, that are commonly used to measure object-oriented programs. In the second chapter we present our proposition for package metrics that capture package aspects such as information hiding and change impact limits.},
  aeres = {COM},
  annote = {technicalreport},
  hal-id = {hal-00646878},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {Coupling Cohesion Packages Modularity Cutter Metric Cohesion Remodularisation StefPub lse-pub kzMetric},
  tagnicolasa = {metric}}

@techreport{Duca11c,
  author = {St\'ephane Ducasse and Nicolas Anquetil and Usman Bhatti and Cavalcante Hora, Andre and Jannik Laval and Tudor Girba},
  title = {{MSE and FAMIX 3.0: an Interexchange Format and Source Code Model Family}},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca11c-Cutter-deliverable22-MSE-FAMIX30.pdf},
  abstract = {Software systems exceeding a certain critical size easily become difficult to maintain and adapt. Requirements change, platforms change and if a system does not evolve properly, its usefulness will decay over time. This document presents MSE a robust, scalable, extensible interexchange format and FAMIX 3.0 a family of metamodels to represent source code.},
  aeres = {COM},
  annote = {technicalreport},
  hal-id = {hal-00646884},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {Software Metrics; Software Modularization; Coupling; Cohesion; Packages; Modularity, Cutter kzMeta},
  numpages = {40},
  tagnicolasa = {other analysis}}

@techreport{Duca11x,
  author = {St\'ephane Ducasse and Nicolas Anquetil and Marcus Denker and Damien Pollet},
  title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2011 Activity Report},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca11x-RAWEB-RMOD-2011-TeamActivityReport.pdf},
  abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
  annote = {technicalreport},
  hal-id = {hal-00667079},
  institution = {INRIA},
  keywords = {rmod raweb lse-pub kzTeamReport},
  tagnicolasa = {ignore}}

@techreport{Duca12a,
  author = {Ducasse, St\'ephane and Petton, Nicolas and Polito, Guillermo and Cassou, Damien},
  title = {Semantics and Security Issues in JavaScript},
  year = {2012},
  abstract = {There is a plethora of research articles describing the deep semantics of JavaScript. Nevertheless, such articles are often difficult to grasp for readers not familiar with formal semantics. In this report, we propose a digest of the semantics of JavaScript centered around security concerns. This document proposes an overview of the JavaScript language and the misleading semantic points in its design. The first part of the document describes the main characteristics of the language itself. The second part presents how those characteristics can lead to problems. It finishes by showing some coding patterns to avoid certain traps and presents some ECMAScript 5 new features.},
  annote = {technicalreport},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {JavaScript Dynamic Language Security Isolation Semantics Web HTTP lse-pub stefPub kzLanguageDesign}}

@techreport{Duca12b,
  author = {Ducasse, St\'ephane and Denker, Marcus and Pollet, Damien},
  title = {Pharo's Vision: Goals, Processes, and Development Effort},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca12b-PharoVision.pdf},
  annote = {techreport},
  institution = {Inria},
  keywords = {Pharo StefPub kzPharo lse-pub},
  hal = {hal-01879346}}

@techreport{Duca12z,
  author = {St\'ephane Ducasse and Nicolas Petton and Guillermo Polito and Damien Cassou},
  title = {Semantics and Security Issues in JavaScript},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca12z-deliverable-7321-FUI12.pdf},
  annote = {technicalreport},
  institution = {Inria Lille-Nord Europe},
  keywords = {kzLanguageDesign stefPub lse-pub},
  month = dec,
  note = {Deliverable Resilience FUI 12: 7.3.2.1 Failles de s\'ecurit\'e en JavaScript / JavaScript security issues}}

@inproceedings{Duca16a,
  author = {Ducasse, St\'ephane and Eliot Miranda and Alain Plantec},
  title = {Pragmas: Literal Messages as Powerful Method Annotations},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  doi = {10.1145/2991041.2991050},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca16a-Pragmas-IWST.pdf},
  address = {Prague, Czech Republic},
  keywords = {stefPub lse-pub kzLanguageDesign},
  hal-id = {hal-01353592},
  month = aug,
  annote = {internationalworkshop}}

@book{Duca17a,
  author = {St\'ephane Ducasse and Dmitri Zagidulin and Nicolai Hess and Dimitris Chloupis --- Originally written by A. Black and S. Ducasse and O. Nierstrasz and D. Pollet with D. Cassou and M. Denker},
  title = {Pharo by Example 5},
  pages = {376},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  abstract = {Pharo by Example, intended for both students and developers, will guide you gently through the Pharo language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
  annote = {book},
  isbn = {978-3-9523341-0-2},
  keywords = {skipdoi kzSmalltalk kzPharo lse-pub}}

@book{Duca17b,
  author = {St\'ephane Ducasse and Damien Pollet},
  title = {Learning Object-Oriented Programming, Design and TDD with Pharo},
  pages = {250},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {book},
  keywords = {skipdoi kzSmalltalk lse-pub kzPharo},
  hal-id = {hal-01612687}}

@booklet{Duca17c,
  author = {St\'ephane Ducasse and Peter Kenny},
  title = {Scraping HTML with XPath},
  pages = {30},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo Technology Collection},
  keywords = {skipdoi kzSmalltalk kzPharo lse-pub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-scrapingbook.pdf},
  hal-id = {hal-01612689}}

@booklet{Duca18c,
  author = {St\'ephane Ducasse},
  title = {A Simple Reflective Object Kernel},
  pages = {40},
  publisher = {Square Bracket Associates},
  year = {2018},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo TextBook Collection},
  keywords = {lse-pub kzVulgarisation},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-ReflectiveCore.pdf},
  hal-id = {hal-01900323}}

@booklet{Duca18d,
  author = {St\'ephane Ducasse and Guillermo Polito},
  title = {Physche: A Little Scheme in Pharo},
  pages = {50},
  publisher = {Square Bracket Associates},
  year = {2018},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo TextBook Collection},
  keywords = {kzSmalltalk lse-pub kzVulgarisation},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-08-28-Physche.pdf},
  hal-id = {hal-01900327}}

@incollection{Duca19a,
  author = {Ducasse, St\'ephane and Rocha, Henrique and Bragagnolo, Santiago and Denker, Marcus and Francomme, Cl\'ement},
  title = {SmartAnvil: Open-Source Tool Suite for Smart Contract Analysis},
  booktitle = {Blockchain and Web 3.0: Social, economic, and technological challenges},
  publisher = {Routledge},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca18a-BookChapter-SmartAnvil.pdf},
  annote = {articlebook},
  abstract = {Smart contracts are new computational units with special properties: they act as classes with aspectual concerns; their memory structure is more complex than mere objects; they are obscure in the sense that once deployed it is difficult to access their internal state; they reside in an append-only chain. There is a need to support the building of new generation tools to help developers. Such support should tackle several important aspects: (1) the static structure of the contract, (2) the object nature of published contracts, and (3) the overall data chain composed of blocks and transactions. In this chapter, we present SmartAnvil an open platform to build software analysis tools around smart contracts. We illustrate the general components and we focus on three important aspects: support for static analysis of Solidity smart contracts, deployed smart contract binary analysis through inspection, and blockchain navigation and querying. SmartAnvil is open-source and supports a bridge to the Moose data and software analysis platform.},
  keywords = {kzEvolution kzBlockchain kzTools lse-pub stefpub},
  hal-id = {hal-01940287}}

@book{Duca19b,
  author = {St\'ephane Ducasse},
  title = {Pharo with Style},
  pages = {46},
  publisher = {Square Bracket Associates},
  year = {2019},
  url = {http://books.pharo.org},
  hal-id = {hal-02299550}}

@mastersthesis{Duca93a,
  author = {St\'ephane Ducasse},
  title = {Protocole meta pour l'expression de relations dans un langage \`a objets},
  year = {1993},
  school = {Laboratoire I3S-Universit\'e de Nice-Sophia Antipolis},
  annote = {dea},
  keywords = {flo kzDependency},
  month = sep,
  note = {Equipe Janus, Supervis\'e par M. Blay-Fornarino et E. Gall\'esio, Team Janus, supervised by M. Blay-Fornarino and E. Gall\'esio}}

@inproceedings{Duca93b,
  author = {St\'ephane Ducasse and Mireille Fornarino},
  title = {Protocol for Managing Dependencies between Objects by controlling Generic Function Invocation},
  booktitle = {OOPSLA '93 International Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming},
  year = {1993},
  annote = {internationalworkshop},
  keywords = {stefPub flo kzReflection kzDependency},
  note = {Technical Report, University of Nice-Sophia Antipolis, I3S Lab, RR-94-62},
  organization = {ACM}}

@inproceedings{Duca94a,
  author = {St\'ephane Ducasse and Mireille Fornarino},
  title = {Protocole pour la gestion des d\'ependances entre objets gr\^ace au contr\^ole des fonctions g\'en\'eriques},
  booktitle = {Actes des Journ\'ees Francophones des Langages Applicatifs (JFLA'94)},
  pages = {239--258},
  year = {1994},
  annote = {nationalconference},
  editor = {Pierre Cointe and Christian Queinnec and Bernard Serpette},
  keywords = {stefPub flo kzDependency}}

@techreport{Duca94b,
  author = {St\'ephane Ducasse and Mireille Fornarino and Anne-Marie Pinna},
  title = {Embedding behavioral relationships between objects using computational relection},
  year = {1994},
  annote = {report notrefereed},
  institution = {Laboratoire I3S},
  keywords = {stefPub flo kzDependency},
  number = {I3S Lab, RR-94-60}}

@inproceedings{Duca95b,
  author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
  title = {A Reflective Model for First Class Dependencies},
  booktitle = {Proceedings of 10th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '95)},
  pages = {265--280},
  publisher = {ACM},
  year = {1995},
  misc = {acceptance rate: 27/167 = 16\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca95bAReflectiveModel.pdf},
  acceptnum = {27},
  accepttotal = {167},
  annote = {internationalconference topconference},
  keywords = {stefPub flo kzReflection kzDependency kzReflection},
  month = oct}

@inproceedings{Duca95c,
  author = {St\'ephane Ducasse},
  title = {Inheritance Mechanism Reification by Means of First Class Object},
  booktitle = {Proceedings of the International IJCAI'95 Workshop on Reflection and Meta-Level Architectures and their Applications in AI},
  pages = {39--49},
  year = {1995},
  annote = {internationalworkshop},
  institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
  keywords = {flo kzDependency},
  note = {RR-95-12}}

@techreport{Duca95d,
  author = {St\'ephane Ducasse and Mireille Fornarino and Anne-Marie Pinna-Dery},
  title = {Control et PAC model},
  year = {1995},
  annote = {report notrefereed},
  institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
  keywords = {stefPub flo kzDependency},
  number = {RR-95-03}}

@techreport{Duca96a,
  author = {St\'ephane Ducasse},
  title = {Reifying Inheritance in a Reflective Language},
  year = {1996},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca96aInhReify.ps.gz},
  annote = {report notrefereed},
  institution = {University of Nice Sophia-Antipolis, Laboratoire I3S},
  keywords = {flo kzDependency},
  note = {I3S Lab, RR-95-28}}

@inproceedings{Duca96b,
  author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
  title = {Object and Dependency Oriented Programming in FLO},
  booktitle = {Proceedings of International Symposium on Methodologies for Intelligent Systems (ISMIS '96)},
  pages = {295--304},
  publisher = {Springer-Verlag},
  year = {1996},
  doi = {10.1007/3-540-61286-6\_154},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca96bDependencyOP.pdf},
  abstract = {The FLO language integrates management of inter-object dependencies into the object oriented paradigms. In this paper, we focus on the use of reactive dependencies (links) in object-oriented knowledge representation. In particular, we present different meta-links (links between links) and show how the FLO links allow one to design some composition relationships.},
  annote = {internationalconference},
  keywords = {flo scg-old scg-pub stefPub kzDependency},
  month = jun,
  number = 1079,
  series = {LNIA (Lectures Notes in Artificial Intelligence)}}

@phdthesis{Duca97a,
  author = {St\'ephane Ducasse},
  title = {Int\'egration r\'eflexive de d\'ependances dans un mod\`ele \`a classes},
  year = {1997},
  school = {Universit\'e de Nice-Sophia Antipolis},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97aPhD.pdf},
  annote = {phdthesis},
  keywords = {stefPub flo kzDependency},
  month = jan,
  note = {Th\`ese de l'Universit\'e de Nice-Sophia Antipolis}}

@inproceedings{Duca97b,
  author = {St\'ephane Ducasse and Tamar Richner},
  title = {Executable Connectors: Towards Reusable Design Elements},
  booktitle = {Proceedings of European Software Engineering Conference and Foundations on Software Engineering (ESEC/FSE'97)},
  volume = {1301},
  pages = {483--500},
  publisher = {Springer-Verlag},
  year = {1997},
  misc = {acceptance rate: 19/197 = 9\%},
  doi = {10.1007/3-540-63531-9\_32},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97bExecutableConnectors.pdf},
  abstract = {The decomposition of a software application into components and connectors at the design stage has been promoted as a way to describe and reason about complex software architectures. There is, however, surprisingly little language support for this decomposition at implementation level. Interaction relationships which are identified at design time are lost as they get spread out into the participating entities at implementation. In this paper, we propose first-class connectors in an object-oriented language as a first step towards making software architecture more explicit at implementation level. Our connectors are run-time entities which control the interaction of components and can express a rich repertoire of interaction relationships. We show how connectors can be reused and how they enhance the reuse of components.},
  acceptnum = {19},
  accepttotal = {197},
  annote = {internationalconference topconference},
  isbn = {978-3-540-63531-4},
  keywords = {scg-pub flo stefPub kzDependency},
  series = {LNCS}}

@inproceedings{Duca97c,
  author = {St\'ephane Ducasse},
  title = {Message Passing Abstractions as Elementary Bricks for Design Pattern Implementation},
  booktitle = {Object-Oriented Technology (ECOOP '97 Workshop Reader)},
  volume = {1357},
  pages = {96--99},
  publisher = {Springer-Verlag},
  year = {1997},
  annote = {internationalworkshop},
  editor = {Jan Bosch and Stuart Mitchell},
  keywords = {scg-pub flo stefPub kzDependency kzReflection},
  month = jun,
  series = {LNCS}}

@inproceedings{Duca97d,
  author = {St\'ephane Ducasse},
  title = {R\'eification de Sch\'emas de Conception: Une Exp\'erience},
  booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'97)},
  pages = {95--110},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97dReificationDP.ps.gz},
  annote = {nationalconference},
  keywords = {scg-pub skip-doi skip-abstract stefPub flo kzDependency}}

@article{Duca97e,
  author = {St\'ephane Ducasse},
  title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
  journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet},
  volume = {3},
  pages = {355--377},
  publisher = {Hermes, Paris},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca97eMessagePassing.pdf},
  annote = {nationaljournal},
  keywords = {scg-pub skip-abstract skip-doi stefPub flo kzReflection},
  number = {4}}

@techreport{Duca97g,
  author = {St\'ephane Ducasse},
  title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
  year = {1997},
  annote = {report notrefereed},
  institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
  keywords = {scg-pub skip-doi skip-pdf skip-abstract jb-none kzReflection},
  note = {Extension version of Duca97e: Des techniques de contr\^ole de l'envoi de messages en Smalltalk},
  number = {97-004}}

@inproceedings{Duca98b,
  author = {St\'ephane Ducasse and Robb Nebbe and Tamar Richner},
  title = {Two Reengineering Patterns: Eliminating Type Checking},
  booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing, 1999},
  publisher = {UVK Universit\"atsverlag Konstanz GmbH},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca98bTwoReengPatterns.pdf},
  abstract = {A reengineering pattern describes how to go from an existing legacy solution to a new refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with design patterns and antipatterns. We then highlight the structure of a reengineering pattern and present two simple, related patterns for type-check elimination.},
  address = {Konstanz, Germany},
  annote = {internationalworkshop},
  editor = {Paul Dyson},
  keywords = {scg-pub skip-doi pattern kzPattern stefPub},
  month = jul}

@inproceedings{Duca98c,
  author = {St\'ephane Ducasse and Manuel G{\"u}nter},
  title = {Coordination of Active Objects by Means of Explicit Connectors},
  booktitle = {Proceedings of the DEXA workshops},
  pages = {572--577},
  publisher = {IEEE Computer Society Press},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca98cExplicitConnectors.pdf},
  abstract = {Although coordination of multiple activities is a fundamental goal of object-oriented concurrent programming languages, there is only limited support for their specification and abstraction at the language level. This leads to a mismatch between conceptional designs, using high-level abstractions, and the implementation, using the low-level coordination constructs. Often coordination is hard-wired into the components they coordinate, which leads to evolution, maintenance and composibility problems. We propose a model called FLO/C that relies on the notion of connectors. A connector is an entity that enforces the coordination of the entities it coordinates. This model supports a clear separation between the coordinated active objects and their coordination.	An active object only defines specific domain information and a connector only defines coordination between a group of active objects (its participants). The coordination is abstractly defined refering to components in terms of the object interface. Coordination and coordinated entities are independant and can evolve separately.	Coordination can be composed and replaced easily.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi flo floc coordination stefPub kzDependency},
  month = aug}

@misc{Duca98z,
  author = {St\'ephane Ducasse and Joachim Weisbrod},
  title = {Report of the {ECOOP}'98 Workshop on Experiences in Object-Oriented Re-Engineering},
  booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
  pages = {72--96},
  publisher = {Springer-Verlag},
  year = {1998},
  annote = {workshopproceedings},
  keywords = {skip-pdf scg-pub skip-abstract skip-doi jb-none stefPub kzPattern},
  number = 1543,
  series = {LNCS}}

@article{Duca99a,
  author = {St\'ephane Ducasse},
  title = {Evaluating Message Passing Control Techniques in {Smalltalk}},
  journal = {Journal of Object-Oriented Programming (JOOP)},
  volume = {12},
  pages = {39--44},
  publisher = {SIGS Press},
  year = {1999},
  impactfactor = {Impact factor 0.306},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca99aMsgPassingControl.pdf},
  abstract = {In a language like Smalltalk in which objects communicate only via message passing, message passing control is a fundamental tool for the analysis of object behavior (trace, spying) or for the definition of new semantics (asynchronous messages, proxy,...). Different techniques exist, from the well known approach based on the specialization of the doesNotUnderstand: method to the exploitation the method lookup algorithm done by the virtual machine. Until now no comparison between these techniques has been made. In this article we compare the different techniques taking into account the reflective aspects used, the scope, the limit and the cost of the control.},
  annote = {internationaljournal},
  keywords = {scg-pub skip-doi stefPub kzReflection},
  month = jun,
  number = {6}}

@inproceedings{Duca99b,
  author = {St\'ephane Ducasse and Matthias Rieger and Serge Demeyer},
  title = {A Language Independent Approach for Detecting Duplicated Code},
  booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
  pages = {109--118},
  publisher = {IEEE Computer Society},
  year = {1999},
  misc = {acceptance rate: 49/100 = 49\%},
  doi = {10.1109/ICSM.1999.792593},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca99bCodeDuplication.pdf},
  abstract = {Code duplication is one of the factors that severely complicates the maintenance and evolution of large software systems. Good tools for detecting duplicated code are scarce because of the large amount of data to be checked, because duplicated code is not known a priori and because especially it requires parsing technology. In this paper we show that is possible to circumvent these complicating factors by applying a language independent and lightweigth approach, i.e. a tool that requires no parsing and a little learning and configuration time, yet is able to detect a significant amount of code duplication. We validate our approach on a number of case studies, involving five different implementation languages and ranging from 256 K up untill 26Mb of source code.},
  acceptnum = {49},
  accepttotal = {100},
  annote = {internationalconference},
  editor = {Hongji Yang and Lee White},
  keywords = {scg-pub toBeChecked duploc stefPub moose kzDuplication},
  month = sep}

@inproceedings{Duca99c,
  author = {St\'ephane Ducasse and Tamar Richner and Robb Nebbe},
  title = {Type-Check Elimination: Two Object-Oriented Reengineering Patterns},
  booktitle = {Proceedings of 6th Working Conference on Reverse Engineering (WCRE'99)},
  pages = {157--168},
  publisher = {IEEE Computer Society},
  year = {1999},
  doi = {10.1109/WCRE.1999.806956},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Duca99cTypeCheckElim.pdf},
  abstract = {In reengineering an object-oriented system we want to benefit from the expertise developed in earlier efforts. It is therefore essential to have a way to communicate expertise at different levels: from knowledge about how to approach a system to be reengineered, to knowledge about improving code by eliminating 'bad' style. In this paper we propose to use a pattern form to communicate knowledge about reengineering. A reengineering pattern connects an observable problem in the code to a reengineering goal: it describes the process of going from the existing legacy solution causing or aggravating the problem to a new refactored solution which meets the reengineering goal. It thus gives a method appropriate for a specific problem, rather than proposing a general methodology, and makes reference to the appropriate tools or techniques for obtaining the refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with related kinds of patterns. We then highlight the form of reengineering patterns and present two simple patterns for type-check elimination.},
  annote = {internationalconference},
  editor = {Fran\c{c}oise Balmas and Mike Blaha and Spencer Rugaber},
  keywords = {olit famoos-papref scg-pub jb99 stefPub kzPattern},
  month = oct}

@inproceedings{Duca99d,
  author = {St\'ephane Ducasse and Matthias Rieger and Georges Golomingi},
  title = {Tool Support for Refactoring Duplicated {OO} Code},
  booktitle = {Proceedings of the ECOOP '99 Workshop on Experiences in Object-Oriented Re-Engineering},
  publisher = {Forschungszentrum Informatik, Karlsruhe},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg99aToolSuppRefacOOCode.pdf},
  abstract = {Code duplication is an important problem in application maintenance. Tools exist that support code duplication detection. However, few of them propose a solution for the problem, i.e.	refactorings. We propose an approach that uses the information given by code duplication detection to guide the refactorings of OO applications.},
  annote = {internationalworkshop},
  editor = {St\'ephane Ducasse and Oliver Ciupke},
  keywords = {olit famoos-papref scg-pub skip-doi jb99 stefPub kzDuplication},
  month = jun,
  note = {FZI-Report 2-6-6/99}}

@inproceedings{Duca99s,
  author = {St\'ephane Ducasse and Michele Lanza and Serge Demeyer},
  title = {Reverse Engineering based on Metrics and Program Visualization},
  booktitle = {Object-Oriented Technology (ECOOP'99 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {1999},
  annote = {internationalworkshop},
  keywords = {scg-pub snf-none skip-pdf jb-skip skip-abstract skip-doi kzVisualization},
  number = {1743},
  series = {LNCS}}

@inproceedings{Dupr17a,
  author = {Thomas Dupriez and Guillermo Polito and St\'ephane Ducasse},
  title = {Analysis and exploration for new generation debuggers},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {5:1--5:6},
  publisher = {ACM},
  year = {2017},
  doi = {10.1145/3139903.3139910},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dupr17a-IWST-NewGenerationDebuggers.pdf},
  annote = {internationalworkshop},
  abstract = {Locating and fixing bugs is a well-known time consuming task. Advanced approaches such as object-centric or back-in-time debuggers have been proposed in the literature, still in many scenarios developers are left alone with primitive tools such as manual breakpoints and execution stepping. In this position paper we explore several advanced on-line debugging techniques such as advanced breakpoints and on-line execution comparison, that could help developers solve complex debugging scenarios. We analyse the challenges and underlying mechanisms required by these techniques. We present some early but promising prototypes we built on the Pharo programming language. We finally identify future research paths by analysing existing research and connecting it to the techniques we presented before.},
  hal-url = {https://hal.archives-ouvertes.fr/hal-01585338},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {5},
  numpages = {6},
  acmid = {3139910},
  address = {New York, NY, USA},
  keywords = {Debugger ; Tool ; Stack ; Breakpoint ; Watchpoint; lse-pub kzInfrastructure},
  hal-id = {hal-01585338}}

@inproceedings{Dupr19a,
  author = {Dupriez, Thomas and Polito, Guillermo and Costiou, Steven and Aranega, Vincent and Ducasse, St\'ephane},
  title = {Sindarin: A Versatile Scripting API for the Pharo Debugger},
  booktitle = {DLS'19, Dynamic Language Symposium},
  year = {2019},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dupr19a-DLS2019-Official.pdf},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02280915v1},
  hal-id = {hal-02280915},
  annote = {internationalconference},
  keywords = {StefPub kzTools}}

@inproceedings{Dure13a,
  author = {Durelli, Rafael S. and Santib{\'a}{\~n}ez, Daniel S.M. and Anquetil, Nicolas and Delamaro, M{\'a}rcio E. and de Camargo, Valter Vieira},
  title = {A systematic review on mining techniques for crosscutting concerns},
  booktitle = {Proceedings of the 28th Annual ACM Symposium on Applied Computing},
  pages = {1080--1087},
  year = {2013},
  misc = {Acceptance rate: 255/1063 = 24\%},
  annote = {internationalconference},
  organization = {ACM},
  tagnicolasa = {other analysis},
  annote = {internationalconference}}

@inproceedings{Dure14a,
  author = {Durelli, Rafael S. and Santib{\'a}{\~n}ez, Daniel S.M. and Marinho, B. and Honda, R. and Delamaro, M{\'a}rcio E. and Anquetil, Nicolas and de Camargo, Valter Vieira},
  title = {A mapping study on architecture-driven modernization},
  booktitle = {Information Reuse and Integration (IRI), 2014 IEEE 15th International Conference on},
  pages = {577-584},
  publisher = {IEEE},
  year = {2014},
  doi = {10.1109/IRI.2014.7051941},
  month = {aug},
  language = {English},
  tagnicolasa = {architecture},
  annote = {internationalconference}}

@article{Etie15a,
  author = {Etien, Anne and Muller, Alexis and Legrand, Thomas and Paige, Richard F.},
  title = {Localized model transformations for building large-scale transformations},
  journal = {Software \& Systems Modeling},
  volume = {14},
  pages = {1189--1213},
  publisher = {Springer},
  year = {2015},
  doi = {10.1007/s10270-013-0379-8},
  issn = {1619-1374},
  hal-id = {hal-01354324},
  annote = {internationaljournal},
  keywords = {Model transformation; Reusable transformation; Transformation chaining},
  language = {English},
  number = {3}}

@techreport{Etie16a,
  author = {Anne Etien},
  title = {{Metamodelisation to support Test and Evolution}},
  year = {2016},
  url = {https://hal.inria.fr/tel-01352817},
  month = jun,
  annote = {habilitation},
  keywords = {software evolution ; Meta Modeling ; Tests ; Evolution logicielle ; metamodelisation ; lse-pub},
  type = {Habilitation {\`a} diriger des recherches},
  pdf = {https://hal.inria.fr/tel-01352817/file/hdr-univlille1.pdf},
  institution = {{Universit{\'e} des Sciences et Technologie de Lille - Lille I}},
  hal-id = {tel-01352817}}

@techreport{Fabr10a,
  author = {Johan Fabry and Andy Kellens and St\'ephane Ducasse},
  title = {AspectMaps: A Scalable Visualization of Join Point Shadows},
  year = {2010},
  annote = {technicalReport notrefereed},
  institution = {University of Chile},
  keywords = {kzVisualization kzAspect},
  month = apr,
  type = {TR/DCC-2010-2}}

@inproceedings{Fabr11a,
  author = {Johan Fabry and Andy Kellens and Simon Denier and St\'ephane Ducasse},
  title = {{AspectMaps}: A Scalable Visualization of Join Point Shadows},
  booktitle = {Proceedings of the 19th International Conference on Program Comprehension},
  pages = {121-130},
  publisher = {IEEE Computer Society Press},
  year = {2011},
  misc = {Acceptance rate: 18/76 = 23\%},
  doi = {http://dx.doi.org/10.1109/ICPC.2011.11},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fabr11a-ICPC2011-AspectMaps.pdf},
  abstract = {When using Aspect-Oriented Programming, it is sometimes difficult to determine at which join point an aspect executes. Similarly, when considering one join point, knowing which aspects will execute there and in what order is non- trivial. This makes it difficult to understand how the application will behave. A number of visualizations have been proposed that attempt to provide support for such program understanding. However, they neither scale up to large code bases nor scale down to understanding what happens at a single join point. In this paper, we present AspectMaps - a visualization that scales in both directions, thanks to a multi-level selective structural zoom. We show how the use of AspectMaps allows for program understanding of code with aspects, revealing both a wealth of information of what can happen at one particular join point as well as allowing to see the ``big picture'' on a larger code base. We demonstrate the usefulness of AspectMaps on an example and present the results of a small user study that shows that AspectMaps outperforms other aspect visualization tools.},
  annote = {internationalconference},
  hal-id = {inria-00614773},
  keywords = {lse-pub plomo raweb2011 pharo kzVisualization kzAspect kzModule},
  rate = {23\%},
  series = {ICPC'11}}

@article{Fabr14a,
  author = {Johan Fabry and Romain Robbes and Marcus Denker},
  title = {DIE: A Domain Specific Aspect Language for IDE Events},
  journal = {Journal of Universal Computer Science},
  volume = {20},
  pages = {135--168},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fabr14a-DIE-JUCS.pdf},
  abstract = {Integrated development environments (IDEs) have become the primary way to develop software. Besides just using the built-in features, it becomes more and more important to be able to extend the IDE with new features and extensions. Plugin architectures exist, but they show weaknesses related to unanticipated extensions and event handling. In this paper, we argue that a more general solution for extending IDEs is needed. We present and discuss a solution, motivated by a set of concrete examples: a domain specific aspect language for IDE events. In it, join points are events of interest that may trigger the advice in which the behavior of the IDE extension is called. We show how this allows for the development of IDE plugins and demonstrate the advantages over traditional publish/subscribe systems.},
  annote = {internationaljournal},
  date = {2014-02-01},
  hal-id = {inria-00936376},
  keywords = {lse-pub plomo2 raweb2014 pharo},
  month = {feb},
  number = {2}}

@article{Fabr14b,
  author = {Johan Fabry and Andy Kellens and Simon Denier and St\'ephane Ducasse},
  title = {AspectMaps: Extending Moose to visualize AOP software},
  journal = {Science of Computer Programming},
  volume = {79},
  pages = {6-22},
  year = {2014},
  doi = {10.1016/j.scico.2012.02.007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fabr14b-Official-SCP-AspectMaps.pdf},
  annote = {internationaljournal},
  hal-id = {hal-01086997},
  issn = {0167-6423},
  keywords = {lse-pub plomo lse-pub stefPub kzVisualization},
  note = {lse-pub stefPub kzVisualization}}

@book{Fabr17a,
  author = {Johan Fabry and St\'ephane Ducasse},
  title = {The Spec UI Framework},
  pages = {84},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {book},
  keywords = {skipdoi kzSmalltalk kzBook lse-pub},
  hal-id = {hal-01612690}}

@inproceedings{Fall11a,
  author = {Jean R\'emi Falleri and Simon Denier and Jannik Laval and Philipe Vismara and St\'ephane Ducasse},
  title = {Efficient Retrieval and Ranking of Undesired Package Cycles in Large Software Systems},
  booktitle = {Proceedings of the 49th International Conference on Objects, Models, Components, Patterns (TOOLS'11)},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fall11a-Tools2011-UndesirableCycles.pdf},
  abstract = {Many design guidelines state that a software system architecture should avoid cycles between its packages. Yet such cycles appear again and again in many programs. We believe that the existing approaches for cycle detection are too coarse to assist the developers to remove cycles from their programs. In this paper, we describe an efficient algorithm that performs a fine-grained analysis of the cycles among the packages of an application. In addition, we define a metric to rank cycles by their level of undesirability, prioritizing the cycles that seems the more undesired by the developers. Our approach is validated on two large and mature software systems in Java and Smalltalk.},
  address = {Zurich, Switzerland},
  annote = {internationalconference},
  hal-id = {inria-00614770},
  keywords = {lse-pub cutter raweb2011 pharo kzCycle kzRemodularisation},
  month = jun}

@misc{Fern05a,
  author = {Hilaire Fernandes and St\'ephane Ducasse},
  title = {Squeak: mon premier programme},
  journal = {Linux Pratique},
  volume = {1},
  pages = {18--23},
  year = {2005},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = oct,
  number = 31}

@misc{Fern06a,
  author = {Hilaire Fernandes and St\'ephane Ducasse},
  title = {Smalltalk: Le pouvoir et la simplicit\'e du tout objet},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = apr,
  number = 82}

@misc{Fern06b,
  author = {Hilaire Fernandes and Serge Stinckwich},
  title = {Environnement de d\'eveloppement Smalltalk},
  journal = {Linux Magazine},
  volume = {1},
  year = {2006},
  annote = {vulgarisation},
  month = jul,
  number = 84}

@inproceedings{Fern07a,
  author = {Hilaire Fernandes and St\'ephane Ducasse and Thibault Caron},
  title = {{Dr Geo II}: Adding Interactivity Planes in Interactive Dynamic Geometry},
  booktitle = {Proceedings of 5th International Conference on Creating, Connecting and Collaborating through Computing (C5 2007)},
  pages = {153--162},
  publisher = {IEEE Computer Society},
  year = {2007},
  doi = {10.1109/C5.2007.12},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fern07a-C5-DrIIInterfactiveMultimodal.pdf},
  abstract = {Interactive geometry environments support the creation and exploitation of interactive geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with: i. the internal cognitive representation of the learner about the geometric domain and ii. the way a geometric sketch is used in a paper-pen environment. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of the interactive geometry environments. We think additional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed DR. GEO II, an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our first results.},
  annote = {internationalconference},
  hal-id = {inria-00531636},
  isbn = {0-7695-2806-6},
  keywords = {stefPub kzTeaching}}

@inproceedings{Fern07b,
  author = {Hilaire Fernandes and St\'ephane Ducasse and Thibault Carron},
  title = {De l'importance des plans d'interaction dans la g\'eom\'etrie interactive},
  booktitle = {Environnements Informatiques pour l'Apprentissage Humain (EIAH 2007)},
  pages = {383--388},
  publisher = {atief, inrp},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fern07b-EIAH-Multimodal.pdf},
  abstract = {Interactive geometry environments support creation and exploitation of geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with the internal cognitive representation of the learner about the geometric domain. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of these environments. We think addi- tional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our results.},
  hal-id = {inria-00531641},
  keywords = {stefPub kzTeaching},
  month = jun}

@misc{Fern07y,
  author = {Hilaire Fernandes and Serge Stinckwich},
  title = {Morphic, les interfaces utilisateurs selon Squeak},
  journal = {Linux Magazine},
  volume = {1},
  year = {2007},
  annote = {vulgarisation},
  keywords = {kzTeaching},
  month = jan,
  number = 90}

@inproceedings{Fern08a,
  author = {Hilaire Fernandes and Thibault Carron and St\'ephane Ducasse},
  title = {iSTOA: Artefacts for mathematical interactive learning execises kzTeaching},
  booktitle = {Proceedings of 6th International Conference on Creating, Connecting and Collaborating through Computing (C5 2008)},
  pages = {65--72},
  publisher = {IEEE Computer Society},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fern08a-C5-istoa-exercises.pdf},
  abstract = {In primary schools, mathematics teachers use support tools to introduce new concepts. The objective of these tools is to reinforce a mental representation of the newly introduced concept. Tools can be physical objects or paper- pen based. We call these tools artefacts. In computer assisted environments, such artefacts are not always clearly present, those environments focus on the nature of the exercises (drills, quiz). To realise environments in closer relation to classroom teaching, we propose to analyse and categorise such artefacts: we used pedagogical literature and we extracted artefacts used in teaching multiplication. We present our infrastructure and a list of artefacts in the multiplication realm.},
  annote = {internationalconference},
  hal-id = {inria-00531649},
  isbn = {0-7695-3115-6},
  keywords = {stefPub kzTeaching}}

@inproceedings{Fern09a,
  author = {Hilaire Fernandes and Thibault Carron and St\'ephane Ducasse},
  title = {Guidage macroscopique de l'apprentissage},
  booktitle = {Environnements Informatiques pour l'Apprentissage Humain (EIAH 2009)},
  publisher = {ATIEF INRP},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Fern09a-EIAH2009-Guidage.pdf},
  abstract = {Les EIAH sont souvent sp\'ecialis\'es dans un domaine bien pr\'ecis. Cela leur permet d'offrir des mod\'elisations fines du domaine et de l'apprenant. L'analyse alors produite \`a partir des traces est didactiquement tr\`es fine et sp\'ecifique au domaine en question. Elle permet de guider l'apprenant en cas de difficult\'e et de lui proposer des activit\'es de soutien. Cependant cette analyse est \'etroitement li\'ee aux domaines didactiques, et diff\'erente d'un domaine \`a un autre. Face \`a la diversit\'e des domaines enseign\'es, comment proposer un mod\`ele tenant compte de cette multitude et permettant une analyse de l'activit\'e de l'\'el\`eve et son guidage ?
Nous proposons une analyse de l'activit\'e de l'\'el\`eve hors du champ didactique pour un guidage que nous nommons macroscopique, par opposition \`a une analyse didactique fine. Le guidage propos\'e est g\'en\'erique mais param\'etr\'e par un r\'eseau notionnel afin d'\^etre transposable \`a diff\'erents domaines d'enseignement.
Notre approche s'appuie sur les r\'eseaux notionnels, les \'etayages p\'edagogiques, les traces d'objets et l'inf\'erence sur celles-ci. Leur utilisation conjointe permet la description du domaine, la mod\'elisation de l'apprenant et son pilotage par l'EIAH. Nous pr\'esentons cette approche dans iSTOA.net.},
  hal-id = {inria-00531658},
  keywords = {stefPub pharo pharo-pub kzTeaching},
  month = jun}

@phdthesis{Fern10a,
  author = {Hilaire Fernandes},
  title = {iStoa, mod\`ele notionnel de guidage macroscopique de l'apprentissage},
  year = {2010},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2010-Fernandes.pdf},
  annote = {PhD},
  asbtract = {Les EIAH sont souvent sp\'ecialis\'es \`a un domaine bien pr\'ecis. Cela leur permet d'offrir des mod\'elisations fines du domaine et de l'apprenant. L'analyse alors produite \`a partir des traces est didactiquement tr\`es fine et sp\'ecifique au domaine en question. Elle permet de guider l'apprenant en cas de difficult\'e et de lui proposer des activit\'es de soutien. Cependant cette analyse est \'etroitement li\'ee aux domaines didactiques, et diff\'erente d'un domaine \`a un autre. Dans la diversit\'e des domaines enseign\'es, comment proposer un mod\`ele tenant compte de cette multitude et permettant une analyse de l'activit\'e de l'\'el\`eve et son guidage ? Nous proposons une analyse de l'activit\'e de l'\'el\`eve hors du champ didactique pour un guidage que nous nommons macroscopique, par opposition \`a une analyse didactique fine. Le guidage propos\'e est param\'etr\'e selon le domaine afin d'\^etre transposable. Notre approche s'appuie sur les r\'eseaux notionnels, les \'etayages p\'edagogiques, les traces d'objets et l'inf\'erence sur celles-ci. Leur utilisation conjointe permet la description du domaine, la mod\'elisation de l'apprenant et son pilotage par l'EIAH. Nous pr\'esentons cette approche implant\'ee dans iSTOA 1.},
  hal-id = {tel-00498599},
  institution = {INRIA},
  keywords = {pharo pharo-pub}}

@inproceedings{Gabs20a,
  author = {Gabsi, Hamdi and Drira, Rim and Hajjami Ben Gh\'ezala, Henda and Ducasse, St\'ephane},
  title = {From Business Process to Cloud Application},
  booktitle = {Proceeding of the 35th Conference of International Business Information Management Association (IBIMA'20)},
  publisher = {IEEE Computer Society Press},
  year = {2020},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gabs20-FromBusinessProcesstoCloudApplication-IBIMA2020.pdf},
  abstract = {Business Process (BP) development can be defined as the process of constructing a workflow application by composing a set of services performing BP's activities. In this respect, Cloud Services (CSs) are being increasingly used in BP development to ensure a high level of performance with a low operating cost. Although large companies may benefit from CSs' advantages, Small and Medium-sized Enterprises (SMEs) and startups are falling behind in cloud usage due to missing Information Technology competence, (IT-competence). The crucial challenge facing SMEs and startups in cloud-based BP development is to effectively address the so-called business and IT alignment issue. It represents the alignment between two different domains; one that entails technical cloud resource requirements and another comprising business-level. Formerly, we present this issue as a discovery challenge of suitable CSs performing abstract BP's activities. To address this challenge, firstly, we introduce the concept of cloud-aware BP by proposing a Domain-Specific Language (DSL) named "BP4Cloud" to enrich BP modeling and cover both business and technical requirements. Secondly, we propose an Activity-Services Matching algorithm that automates the discovery of CSs performing BP's activities.
As a part of the evaluation, we set up by clarifying the specification of BP4Cloud elements through a proof of concept implementation applied on a real BP. Then, we proceed by evaluating the precision and recall of our Activity-Service Matching algorithm.},
  annote = {internationalconference},
  hal-url = {http://hal.inria.fr/inria-02533375},
  hal-id = {inria-00200869},
  keywords = {lse-pub StefPub kzOther},
  location = {Seville, Spain}}

@article{Gael02a,
  author = {Markus Gaelli and Marcus Denker},
  title = {Freie Software im Unterricht: Squeak},
  journal = {bpb Online-Publikation: Freie Software im Unterricht},
  publisher = {bpb: Bundeszentrale f{\"u}r politische Bildung Deutschland},
  year = {2002},
  misc = {gaelli},
  pdf = {http://rmod-files.lille.inria.fr/Team/Vulgarisations/Gael02a-BPB-Squeak.pdf},
  annote = {notrefereed},
  comment = {bpb: Bundeszentrale f{\"u}r politische Bildung Deutschland},
  keywords = {Squeak gaelli fromscgbib marcusdenker},
  month = oct}

@article{Gael04b,
  author = {Markus Gaelli and Marcus Denker},
  title = {Von kleinen und grossen Erfindern --- Squeak: Lernumgebung und Smalltalk-System f{\"u}r Kinder und Erwachsene},
  journal = {c't magazin f\"ur computer technik},
  pages = {216--221},
  publisher = {Heise Verlag},
  year = {2004},
  misc = {gaelli},
  pdf = {http://rmod-files.lille.inria.fr/Team/Vulgarisations/Gael04b-Ct-VonKleinenUndGrossenErfindern.pdf},
  abstract = {Es muss keine staubtrockene Angelegenheit von
 Informatikstudenten sein, dem Computer neue Dinge
 beizubringen. Squeak will Kindern nicht nur den
 Umgang mit dem Rechner naeher bringen, sondern ihnen
 auch als Mittel zur Entdeckung der realen Welt
 dienen. Und fuer Erwachsene stellt es eine
 Smalltalk-Umgebung dar, die auch spielerisch
 erschlossen werden kann.},
  annote = {notrefereed},
  keywords = {squeak smalltalk snf-none gaelli fromscgbib marcusdenker},
  month = may}

@inproceedings{Gael04c,
  author = {Markus Gaelli and Oscar Nierstrasz and St\'ephane Ducasse},
  title = {One-Method Commands: Linking Methods and Their Tests},
  booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gael04c-LinkingMethodsAndTests.pdf},
  abstract = {Although unit testing is essential for programming, current languages only barely support the developer in composing unit tests into new ones or in navigating between unit tests and their corresponding methods under test. We have taken several Smalltalk programs and analyzed the relationships between unit tests and methods under test, and the re- lationships amongst unit tests.	First results indicate that most unit tests can be seen or at least decomposed into commands which focus on single methods, and that large portions of unit tests overlap each other. But these relationships between unit tests and methods under test are not reflected in current languages. We therefore first conceptually extend the meta-model of Smalltalk with one-method commands so that unit tests become both com- posable and navigable. Then we introduce a first lightweight implementation of this meta model using method comments to differentiate between the several test phases of existing XUnit test case methods.},
  annote = {internationalworkshop},
  keywords = {snf05 scg-pub skip-doi gaelli kzChecking},
  month = oct,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gael04cLinkingMethodsAndTests.pdf}}

@techreport{Gens02a,
  author = {Thomas Genssler and Alexander Christoph and Benedikt Schulz and Michael Winter and Chris M. Stich and Christian Zeidler and Peter M\"uller and Andreas Stelter and Oscar Nierstrasz and St\'ephane Ducasse and Gabriela Ar{\'e}valo and Roel Wuyts and Peng Liang and Bastiaan Sch\"onhage and Reinier van den Born},
  title = {PECOS in a Nutshell},
  publisher = {The Pecos Consortium},
  year = {2002},
  abstract = {This Handbook presents the PECOS approach for developing field device software. It has been written for the developer who wants to apply the method in a realistic setting. By following this tutorial the reader will get a good understanding of PECOS and will learn how to use PECOS to develop software for embedded real-time systems.},
  annote = {techreport},
  institution = {University of Bern},
  keywords = {skip-doi	pecos arevalo stefPub kzModule kzLanguageDesign},
  month = sep}

@inproceedings{Girb04b,
  author = {Tudor G\^irba and St\'ephane Ducasse and Michele Lanza},
  title = {{Yesterday's} {Weather}: Guiding Early Reverse Engineering Efforts by Summarizing the Evolution of Changes},
  booktitle = {Proceedings of 20th IEEE International Conference on Software Maintenance (ICSM'04)},
  pages = {40--49},
  publisher = {IEEE Computer Society},
  year = {2004},
  misc = {acceptance rate: 38/122 = 31\%},
  doi = {10.1109/ICSM.2004.1357788},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb04b-ICSM04-YesterdayWeather.pdf},
  abstract = {Knowing where to start reverse engineering a large software system, when no information other than the system`s source code itself is available, is a daunting task. Having the history of the code (i.e., the versions) could be of help if this would not imply analyzing a huge amount of data. In this paper we present an approach for identifying candidate classes for reverse engineering and reengineering efforts. Our solution is based on summarizing the changes in the evolution of object-oriented software systems by defining history measurements. Our approach, named Yesterday`s Weather, is an analysis based on the retrospective empirical observation that classes which changed the most in the recent past also suffer important changes in the near future. We apply this approach on two case studies and show how we can obtain an overview of the evolution of a system and pinpoint its classes that might change in the next versions.},
  acceptnum = {38},
  accepttotal = {122},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub evolution metrics hismo stefPub moose recast05 jb05 kzHistory},
  location = {Illinois, USA},
  month = sep,
  pdf-second = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb04bYesterdayWeather.pdf}}

@inproceedings{Girb04d,
  author = {Tudor G\^irba and St\'ephane Ducasse and Radu Marinescu and Daniel Ra\c{t}iu},
  title = {Identifying Entities That Change Together},
  booktitle = {Ninth IEEE Workshop on Empirical Studies of Software Maintenance},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb04dEntitiesChangeTogether.pdf},
  abstract = {Software system need to change over time to cope
 with the new requirements. Furthermore, due to
 design decisions, the new requirements happen to
 crosscut the system's structure. Understanding how
 changes appear in the system can reveal hidden
 dependencies between different parts of the system.
 We propose to group entities that change together
 according to a logical expression that specifies the
 change condition. Furthermore, we can group entities
 at different levels of abstraction (i.e., method,
 class, package). Our approach is based on an
 explicit history meta model that centers around the
 notion of history and which enables the definition
 of historical measurements which summarize the
 changes. We apply our approach on two large case
 studies and show how we can identify groups of
 related entities and detect bad smells.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi evolution van metrics smell hismo stefPub recast05 girba jb05 moose kzHistory}}

@inproceedings{Girb05a,
  author = {Tudor G\^irba and Michele Lanza and St\'ephane Ducasse},
  title = {Characterizing the Evolution of Class Hierarchies},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering},
  pages = {2--11},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 33/81 = 41 \%},
  doi = {10.1109/CSMR.2005.15},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb05aHierarchiesEvolution.pdf},
  abstract = {Analyzing historical information can show how a
 software system evolved into its current state,
 which parts of the system are stable and which have
 changed more. However, historical analysis implies
 processing a vast amount of information making the
 interpretation of the results difficult. To address
 this issue, we introduce the notion of the history
 of source code artifacts as a first class entity and
 define measurements which summarize the evolution of
 such entities. We use these measurements to define
 rules by which to detect different characteristics
 of the evolution of class hierarchies. Furthermore,
 we discuss the results we obtained by visualizing
 them using a polymetric view. We apply our approach
 on two large open source case studies and classify
 their class hierarchies based on their history.},
  acceptnum = {33},
  accepttotal = {81},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub evolution visualization metrics van recast05 girba stefPub moose kzVisualization kzHistory},
  rate = {41\%},
  series = {CSMR'05}}

@inproceedings{Girb05b,
  author = {Tudor G\^irba and Jean-Marie Favre and St\'ephane Ducasse},
  title = {Using Meta-Model Transformation to Model Software Evolution},
  booktitle = {Proceedings of 2nd International Workshop on Meta-Models and Schemas for Reverse Engineering (ATEM 2004)},
  pages = {57--64},
  year = {2004},
  doi = {10.1016/j.entcs.2005.07.005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb05bMetaModelTransATEM2004.pdf},
  abstract = {Understanding how software systems evolve is useful
 from different perspectives: reverse engineering,
 empirical studies etc.. For an effective
 understanding we need an explicit meta-model. We
 introduce Hismo, a meta-model which is centered
 around the notion of history and we show how we can
 obtain it from a snapshot meta-model. Based on our
 experience in developing the Hismo reverse
 engineering system, we show how we can transform a
 snapshot meta-model in a history metamodel.},
  annote = {internationalworkshop},
  keywords = {scg-pub evolution meta-modeling hismo van moose recast05 jointERCIM girba stefPub jb05 kzMeta kzHistory}}

@inproceedings{Girb05c,
  author = {Tudor G\^irba and Adrian Kuhn and Mauricio Seeberger and St\'ephane Ducasse},
  title = {How Developers Drive Software Evolution},
  booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2005)},
  pages = {113--122},
  publisher = {IEEE Computer Society Press},
  year = {2005},
  misc = {acceptance rate: 13/54 = 24\%},
  doi = {10.1109/IWPSE.2005.21},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb05cOwnershipMap.pdf},
  abstract = {As systems evolve their structure change in ways not
 expected upfront. As time goes by, the knowledge of
 the developers becomes more and more critical for
 the process of understanding the system. That is,
 when we want to understand a certain issue of the
 system we ask the knowledgeable developers. Yet, in
 large systems, not every developer is knowledgeable
 in all the details of the system. Thus, we would
 want to know which developer is knowledgeable in the
 issue at hand. In this paper we make use of the
 mapping between the changes and the author
 identifiers (e.g., user names) provided by
 versioning repositories. We first define a
 measurement for the notion of code ownership. We use
 this measurement to define the Ownership Map
 visualization to understand when and how different
 developers interacted in which way and in which part
 of the system. We report the results we obtained on
 several large systems.},
  acceptnum = {13},
  accepttotal = {54},
  annote = {internationalworkshop},
  keywords = {scg-pub evolution visualization authors stefPub recast06 moose chronia kzHistory kzVisualization},
  location = {Lisbon, Portugal},
  rate = {24\%}}

@article{Girb06a,
  author = {Tudor G\^irba and St\'ephane Ducasse},
  title = {Modeling History to Analyze Software Evolution},
  journal = {Journal of Software Maintenance: Research and Practice (JSME)},
  volume = {18},
  pages = {207--236},
  publisher = {John Wiley and Sons, Ltd.},
  year = {2006},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb06aHismo.pdf},
  abstract = {The histories of software systems hold useful
 information when reasoning about the systems at hand
 or when reasoning about general laws of software
 evolution. Over the past 30 years more and more
 research has been spent on understanding software
 evolution. However, the approaches developed so far
 do not rely on an explicit meta-model, and thus,
 they make it difficult to reuse or compare their
 results. We argue that there is a need for an
 explicit meta-model for software evolution analysis.
 We present a survey of the evolution analyses and
 deduce a set of requirements that an evolution
 meta-model should have. We define, Hismo, a
 meta-model in which history is modeled as an
 explicit entity. Hismo adds a time layer on top of
 structural information, and provides a common
 infrastructure for expressing and combining
 evolution analyses and structural analyses. We
 validate the usefulness of our a meta-model by
 presenting how different analyses are expressed on
 it.},
  annote = {internationaljournal},
  keywords = {hasler07 scg-pub skip-doi recast06 stefPub mooseCincom moose kzMeta kzHistory meta-modeling hismo evolution}}

@inproceedings{Girb07a,
  author = {Tudor G\^irba and St\'ephane Ducasse and {A}drian {K}uhn and Radu Marinescu and Daniel Ra\c{t}iu},
  title = {Using Concept Analysis to Detect Co-Change Patterns},
  booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2007)},
  pages = {83--89},
  publisher = {ACM Press},
  year = {2007},
  doi = {10.1145/1294948.1294970},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Girb07aCoChangePatterns.pdf},
  abstract = {Software systems need to change over time to cope
 with new requirements, and due to design decisions,
 the changes happen to crosscut the system's
 structure. Understanding how changes appear in the
 system can reveal hidden dependencies between
 different entities of the system. We propose the
 usage of concept analysis to identify groups of
 entities that change in the same way and in the same
 time. We apply our approach at different levels of
 abstraction (i.e., method, class, package) and we
 detect fine grained changes (i.e., statements were
 added in a class, but no method was added there).
 Concept analysis is a technique that identifies
 entities that have the same properties, but it
 requires manual inspection due to the large number
 of candidates it detects. We propose a heuristic
 that dramatically eliminate the false positives. We
 apply our approach on two case studies and we show
 how we can identify hidden dependencies and detect
 bad smells.},
  annote = {internationalworkshop},
  isbn = {978-1-59593-722-3},
  keywords = {scg07 scg-pub evolution fca girba jb08 metrics moose norex07 stefPub kzHistory},
  medium = {2}}

@incollection{Girb13a,
  author = {Tudor G\^irba},
  title = {Glamour},
  booktitle = {Deep Into Pharo},
  pages = {191--207},
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@inproceedings{Godo14a,
  author = {Lucas Godoy and Damien Cassou and St\'ephane Ducasse},
  title = {Tracking dependencies between code changes: An incremental approach},
  booktitle = {IWST'14: Proceedings of the	International Workshop on Smalltalk Technologies 2014},
  year = {2014},
  abstract = {Merging a change often leads to the question of knowing what are the dependencies to other changes that should be merged too to obtain a working system. This question also arises with code history trackers -- Code history trackers are tools that react to what the developer do by creating first-class objects that represent the change made to the system. In this paper, we evaluate the capacity of different code history trackers to represent, also as first-class objects, the dependencies between those changes. We also present a representation for dependencies that works with the event model of \emph{Epicea}, a fine-grained and incremental code history tracker.},
  annote = {internationalworkshop},
  keywords = {lse-pub pharo stefPub kzInfrastructure}}

@misc{Gonz04a,
  author = {Sebastian Gonzales and Wolgang Demeuter and Pascal Costanza and St\'ephane Ducasse and Richard Gabriel and Theo D'hondt},
  title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
  booktitle = {Object-Oriented Technology (ECOOP'04 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Gonz04a-oolepje04-report.pdf},
  abstract = {This report covers the activities of the 2nd
 workshop on "Object-Oriented Language Engineering
 for the Post-Java Era". We describe the motivation
 that led to the organisation of a second edition of
 the workshop. Relevant organisational aspects are
 mentioned. The main part of the report consists of a
 summary of Dave Thomas's invited talk, and a recount
 of the presentations by the authors of position
 papers. Comments given along the way by the
 participants are included. Finally, some pointers to
 related work and events are given.},
  annote = {workshopproceedings},
  keywords = {scg-pub skip-doi jb04 stefPub recast04 kzEditor},
  series = {LNCS}}

@inproceedings{Gonz09a,
  author = {Gonz\'{a}lez, Sebasti\'{a}n and Denker, Marcus and Mens, Kim},
  title = {Transactional contexts: harnessing the power of context-oriented reflection},
  booktitle = {COP '09: International Workshop on Context-Oriented Programming},
  pages = {1--6},
  publisher = {ACM},
  year = {2009},
  doi = {10.1145/1562112.1562115},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gonz09a-COP09-Context.pdf},
  abstract = {The emerging field of context-oriented programming
 gives a predominant role to the execution context of
 applications, and advocates the use of dedicated
 mechanisms to allow the elegant expression of
 behavioural adaptations to such context. With
 suitable reflective facilities, language semantics
 can be adapted to context by reusing the same
 context-oriented mechanisms that allow base-level
 adaptability. This kind of meta-level adaptability,
 in which the computation model itself becomes
 adaptable to context, gives rise to context-oriented
 computational reflection. To explore this idea, we
 set out to implement a simple software transactional
 memory system that exploits meta-level adaptability
 by regarding transactions as contexts, and adapting
 fundamental system behaviour to such transactional
 contexts. The implementation is succinct and
 non-intrusive, giving us an indication of the power
 lying at the crossroads of context-oriented
 programming and computational reflection.},
  address = {New York, NY, USA},
  isbn = {978-1-60558-538-3},
  keywords = {cop-lit gonzales ambience fromscgbib},
  location = {Genova, Italy}}

@inproceedings{Govi15a,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{Reverse Engineering Tool Requirements for Real Time Embedded Systems}},
  booktitle = {{Seminar on Advanced Techniques \& Tools for Software Evolution (SATToSE'15)}},
  year = {2015},
  url = {https://hal.inria.fr/hal-01187532},
  hal-url = {https://hal.inria.fr/hal-01187532},
  address = {Mons, Belgium},
  annote = {internationalworkshop},
  note = {Short paper},
  inria = {RMOD},
  month = jul,
  keywords = {reverse engineering tool},
  tagnicolasa = {other},
  hal-id = {hal-01187532}}

@inproceedings{Govi15b,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{Measuring the progress of an Industrial Reverse Engineering Process}},
  booktitle = {{BENEVOL'15: 14th BElgian-NEtherlands software
 eVOLution seminar}},
  year = {2015},
  url = {https://hal.archives-ouvertes.fr/hal-01353203},
  address = {Lille, France},
  annote = {internationalworkshop},
  month = dec,
  keywords = {reverse engineering ; software process ; lse-pub},
  tagnicolasa = {metric},
  hal-id = {hal-01353203}}

@inproceedings{Govi16a,
  author = {Govin, Brice and Anquetil, Nicolas and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{Clustering Techniques for Conceptual Cluster}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  url = {https://hal.archives-ouvertes.fr/hal-01353205v1},
  doi = {10.1145/2991041.2991052},
  address = {Prague, Czech Republic},
  annote = {internationalworkshop},
  month = aug,
  keywords = {pharo-pub ; lse-pub ; clustering ; conceptual clusters ; industrial project ; architecture migration ; pharo},
  tagnicolasa = {other},
  hal-id = {hal-01353205}}

@inproceedings{Govi16b,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St\'ephane},
  title = {{How Can We Help Software Rearchitecting Efforts ? Study of an Industrial Case}},
  booktitle = {{Proceedings of the International Conference on Software Maintenance and Evolution, (Industrial Track)}},
  year = {2016},
  url = {https://hal.archives-ouvertes.fr/hal-01451242v1},
  address = {Raleigh, USA},
  annote = {internationalconference},
  inria = {RMOD},
  month = oct,
  tagnicolasa = {architecture},
  keywords = {lse-pub ; tool-supported process ; migration ; industrial case},
  hal-id = {hal-01451242}}

@inproceedings{Govi17a,
  author = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Ducasse, St\'ephane and Monegier Du Sorbier, Arnaud},
  title = {{Managing an Industrial Software Rearchitecting Project With Source Code Labelling}},
  booktitle = {{Complex Systems Design \& Management conference  (CSD\&M)}},
  year = {2017},
  url = {https://hal.inria.fr/hal-02095200},
  tagnicolasa = {other tools},
  annote = {internationalworkshop},
  address = {Paris, France},
  month = dec,
  hal-id = {hal-02095200}}

@phdthesis{Govi18a,
  author = {Brice Govin},
  title = {Support \`a la r\'enovation d'une architecture logicielle patrimoniale : Un cas r\'eel chez Thales Air Systems},
  year = {2018},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2018-GovinBrice.pdf},
  keywords = {lse-pub},
  month = jun,
  abstract = {Les entreprises accordent \'enorm\'ement d'importance \`a identifier des d\'emarches automatis\'ees et r\'eplicables pour r\'esoudre leurs probl\`emes. Ce constat s'applique aussi aux d\'emarches de r\'enovation d'architecture logicielle. Au sein d'une grande entreprise, nous avons int\'egr\'e l'\'equipe charg\'ee de r\'ealiser la r\'enovation de l'architecture d'un logiciel. Nous avons \'etudi\'e la d\'emarche informelle suivie par cette \'equipe afin d'en proposer une g\'en\'eralisation et des outils facilitant son automatisation et sa r\'eplication \`a d'autres projets. La plupart des solutions propos\'ees dans la litt\'erature ne peuvent s'appliquer \`a ce projet, du fait de leur caract\`ere manuel, de leurs contraintes particuli\`eres ou de leur manque d'application sur des cas r\'eels. Toutefois, nous avons propos\'e une nouvelle d\'emarche structur\'ee qui se base sur une adaptation d'une technique existante et sur la d\'emarche r\'ealis\'ee par l'entreprise. Enfin, pour r\'epondre au besoin d'automatisation, nous avons d\'efini ce que nous appelons des op\'erateurs. Ils se basent sur les activit\'es que nous avons identifi\'ees dans le travail des ing\'enieurs de l'entreprise. Nous avons montr\'e que ces op\'erateurs permettraient de r\'epliquer enti\`erement notre d\'emarche structur\'ee autorisant ainsi son application efficace sur d'autres projets.},
  hal-id = {tel-01881319},
  hal = {http://hal.inria.fr/tel-01881319}}

@inproceedings{Gree05a,
  author = {Orla Greevy and St\'ephane Ducasse},
  title = {Correlating Features and Code Using A Compact Two-Sided Trace Analysis Approach},
  booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
  pages = {314--323},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 33/81 = 41\%},
  doi = {10.1109/CSMR.2005.21},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree05aTraceScraperCSMR2005Features.pdf},
  abstract = {Software developers are constantly required to
 modify and adapt features of an application in
 response to changing requirements. The problem is
 that just by reading the source code, it is
 difficult to determine how classes and methods
 contribute to the runtime behavior of features.
 Moreover, dependencies between system features are
 not obvious, consequently software maintenance
 operations often result in unintended side effects.
 To tackle these problems, we propose a compact
 feature-driven approach (\ie summarized trace
 information) based on dynamic analysis to
 characterize features and computational units of an
 application. We extract execution traces to achieve
 an explicit mapping between features and classes
 using two complementary perspectives. We apply our
 approach to two case studies and we report our
 findings.},
  acceptnum = {33},
  accepttotal = {81},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  cvs = {TraceScraperRevEng},
  keywords = {scg-pub kzDynamicInformation recast05 stefPub Feature Feature-Traces Dynamic Analysis Evolution moose},
  location = {Manchester, United Kingdom},
  rate = {41\%}}

@inproceedings{Gree05b,
  author = {Orla Greevy and St\'ephane Ducasse},
  title = {Characterizing the Functional Roles of Classes and Methods by Analyzing Feature Traces},
  booktitle = {Proceedings of WOOR 2005 (6th International Workshop on Object-Oriented Reengineering)},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree05bTraceScraperWOOR2005.pdf},
  abstract = {Software developers are often faced with the task of
 maintaining or extending large and complex
 applications, with which they are unfamiliar.
 Typically change requests and bug reports are
 expressed in terms of system features. Much of the
 maintenance effort is spent trying to identify which
 classes and methods provide functionality to
 individual features. To tackle this problem, we
 propose an approach based on dynamic analysis that
 exploits the relationship between features and
 software entities. Our definition of a feature is a
 unit of observable behavior of a software system. We
 apply our approach to a large open source
 application and identify key classes and methods
 which provide functionality to individual features.},
  annote = {internationalworkshop},
  cvs = {TraceScraperWOOR2005},
  keywords = {scg-pub skip-doi greevy jb06 MISSINGPAGENUMBERS stefPub Feature Feature-Traces Dynamic Analysis Evolution moose recast05 kzDynamicInformation},
  month = jul}

@inproceedings{Gree05c,
  author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
  title = {Analyzing Feature Traces to Incorporate the Semantics of Change in Software Evolution Analysis},
  booktitle = {Proceedings of 21st IEEE International Conference on Software Maintenance (ICSM'05)},
  pages = {347--356},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 55/180 = 31\%},
  doi = {10.1109/ICSM.2005.22},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree05cTraceScraperICSM2005.pdf},
  abstract = {Many of the approaches that analyze software
 evolution consider a static perspective of a system.
 Static analysis approaches focus on the evolution of
 static software entities such as packages, classes
 and methods. Without knowledge of the roles software
 entities play in system features, it is difficult to
 interpret the motivation behind changes and
 extensions in the code. To tackle this problem, we
 propose an approach to software evolution analysis
 that exploits the relationships between features and
 software entities. Our definition of a feature is a
 unit of observable behavior of a software system. We
 define history measurements that summarize the
 evolution of software entities from a feature
 perspective. We show how we use our feature
 perspective of software evolution to interpret
 modifications and extensions to the code. We apply
 our approach on two case studies and discuss our
 findings.},
  acceptnum = {55},
  accepttotal = {180},
  address = {Los Alamitos},
  annote = {internationalconference},
  keywords = {scg-pub stefPub Features Feature-Traces Dynamic-Analysis Evolution history moose recast06 listic kzDynamicInformation},
  month = sep,
  rate = {31\%}}

@article{Gree06b,
  author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
  title = {Analyzing Software Evolution through Feature Views},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
  volume = {18},
  pages = {425--456},
  year = {2006},
  impactfactor = {5 Year ISI impact factor (2010) 1.523},
  doi = {10.1002/smr.340},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree06bTraceScraperJSME-SCG.pdf},
  abstract = {Features encapsulate the domain knowledge of a
 software system and thus are valuable sources of
 information for a reverse engineer. When analyzing
 the evolution of a system, we need to know how and
 which features were modified to recover both the
 change intention and its extent, namely which source
 artifacts are affected. Typically, the
 implementation of a feature crosscuts a number of
 source artifacts. To obtain a mapping between
 features to the source artifacts, we exercise the
 features and capture their execution traces. However
 this results in large traces that are difficult to
 interpret. To tackle this issue we compact the
 traces into simple sets of source artifacts that
 participate in a feature's runtime behavior. We
 refer to these compacted traces as feature views.
 Within a feature view, we partition the source
 artifacts into disjoint sets of characterized
 software entities. The characterization defines the
 level of participation of a source entity in the
 features. We then analyze the features over several
 versions of a system and we plot their evolution to
 reveal how and hich features were affected by
 changes in the code. We show the usefulness of our
 approach by applying it to a case study where we
 address the problem of merging parallel development
 tracks of the same system.},
  annote = {internationaljournal},
  keywords = {scg-pub recast07 stefPub girba dynamic-analysis feature evolution moose kzDynamicInformation},
  number = {6}}

@inproceedings{Gree07a,
  author = {Orla Greevy and Tudor G\^irba and St\'ephane Ducasse},
  title = {How Developers Develop Features},
  booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR 2007)},
  pages = {256--274},
  publisher = {IEEE Computer Society},
  year = {2007},
  misc = {Acceptance rate: 38/132=29\%},
  doi = {10.1109/CSMR.2007.27},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gree07aDevelopersDevelopFeatures.pdf},
  abstract = {Software systems are typically developed by teams of
 developers, with responsibilities for different
 parts of the code. Knowledge of how the developers
 collaborate, and how their responsibilities are
 distributed over the software artifacts is a
 valuable source of information when reverse
 engineering a system. Determining which developers
 are responsible for which software artifacts (\eg
 packages or classes) is just one perspective. In
 this paper we complement the static perspective with
 the dynamic perspective of a system in terms of its
 features. We want to extract information about which
 developers are responsible for which features. To
 achieve these two perspectives, we correlate
 developer responsibilities both with a structural
 view of the system and with a feature view. We
 identify which developers are responsible for which
 features, and whether the responsibilities
 correspond with structural source code artifacts or
 with features. We apply our technique to two
 software projects developed by two teams of students
 as part of their course work, and to one large open
 source project.},
  acceptnum = {38},
  accepttotal = {132},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  cvs = {TraceScraperCSMR2007},
  isbn = {0-7695-2802-3},
  issn = {1534-5351},
  keywords = {scg-pub greevy stefPub moose authors features evolution dynamic-analysis girba kzDynamicInformation},
  medium = {2},
  rate = {29\%}}

@article{Gybe06a,
  author = {Kris Gybels and Roel Wuyts and St\'ephane Ducasse and Maja D'Hondt},
  title = {Inter-Language Reflection --- A Conceptual Model and Its Implementation},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {32},
  pages = {109--124},
  publisher = {Elsevier},
  year = {2006},
  impactfactor = {5 Year ISI impact factor (2009) 0.619},
  doi = {10.1016/j.cl.2005.10.003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Gybe06aSymbioticReflectionESUGJournal.pdf},
  abstract = {Meta programming is the act of reasoning about a
 computational system. For example, a program in
 Prolog can reason about a program written in
 Smalltalk. Reflection is a more powerful form of
 meta programming where the same language is used to
 reason about, and act upon, itself in a causally
 connected way. Thus on the one hand we have meta
 programming that allows different languages or
 paradigms to be used, but without causal connection,
 while on the other hand we have reflection that
 offers causal connection but only for a single
 language. This paper combines both and presents
 inter-language reflection that allows one language
 to reason about and change in a causally connected
 way another language and vice versa. The fundamental
 aspects of inter-language reflection and the
 language symbiosis used therein, are discussed.
 Moreover the implementation of two symbiotic
 reflective languages is discussed: Agora/Java and
 SOUL/Smalltalk.},
  annote = {internationaljournal},
  keywords = {stefPub kzReflection},
  month = jul,
  number = {2-3}}

@inproceedings{Hald07b,
  author = {Niklaus Haldimann and Marcus Denker and Oscar Nierstrasz},
  title = {Practical, Pluggable Types},
  booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
  pages = {183--204},
  publisher = {ACM Digital Library},
  year = {2007},
  doi = {10.1145/1352678.1352690},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hald07b-ICDL07-Typeplug.pdf},
  abstract = {Most languages fall into one of two camps: either
 they adopt a unique, static type system, or they
 abandon static type-checks for run-time checks.
 Pluggable types blur this division by (i) making
 static type systems optional, and (ii) supporting a
 choice of type systems for reasoning about different
 kinds of static properties. Dynamic languages can
 then benefit from static-checking without
 sacrificing dynamic features or committing to a
 unique, static type system. But the overhead of
 adopting pluggable types can be very high,
 especially if all existing code must be decorated
 with type annotations before any type-checking can
 be performed. We propose a practical and pragmatic
 approach to introduce pluggable type systems to
 dynamic languages. First of all, only annotated code
 is type-checked. Second, limited type inference is
 performed on unannotated code to reduce the number
 of reported errors. Finally, external annotations
 can be used to type third-party code. We present
 Typeplug, a Smalltalk implementation of our
 framework, and report on experience applying the
 framework to three different pluggable type
 systems.},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {scg-pub reflectivity marcusdenker fromscgbib kzLanguageDesign},
  medium = {2}}

@article{Hald09a,
  author = {Niklaus Haldimann and Marcus Denker and Oscar Nierstrasz},
  title = {Practical, Pluggable Types for a Dynamic Language},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {35},
  pages = {48--64},
  publisher = {Elsevier},
  year = {2009},
  impactfactor = {Impact factor (2010) 0.421},
  doi = {10.1016/j.cl.2008.06.003},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hald08a-COMLAN-Typeplug.pdf},
  abstract = {Most languages fall into one of two camps: either
 they adopt a unique, static type system, or they
 abandon static type-checks for run-time checks.
 Pluggable types blur this division by (i) making
 static type systems optional, and (ii) supporting a
 choice of type systems for reasoning about different
 kinds of static properties. Dynamic languages can
 then benefit from static-checking without
 sacrificing dynamic features or committing to a
 unique, static type system. But the overhead of
 adopting pluggable types can be very high,
 especially if all existing code must be decorated
 with type annotations before any type-checking can
 be performed. We propose a practical and pragmatic
 approach to introduce pluggable type systems to
 dynamic languages. First of all, only annotated code
 is type-checked. Second, limited type inference is
 performed on unannotated code to reduce the number
 of reported errors. Finally, external annotations
 can be used to type third-party code. We present
 Typeplug, a Smalltalk implementation of our
 framework, and report on experience applying the
 framework to three different pluggable type
 systems.},
  annote = {internationaljournal},
  keywords = {scg09 scg-pub jb08 snf08 reflectivity marcusdenker fromscgbib},
  medium = {2},
  month = apr,
  number = {1}}

@incollection{Hart13a,
  author = {Norbert Hartl and Christian Denker and Marcus Denker},
  title = {Kapitel 2: Technische Aspekte},
  booktitle = {Mobile Apps - Rechtsfragen und rechtliche Rahmenbedingungen},
  pages = {9-24},
  publisher = {De Gruyter},
  year = {2013},
  annote = {articlebook},
  editor = {Christian Solmecke and Juergen Taeger and Thorsten Feldmann},
  hal-id = {hal-00865116},
  isbn = {978-3-11-030503-6},
  keywords = {lse-pub},
  month = {aug}}

@inproceedings{Haup07a,
  author = {Michael Haupt and Robert Hirschfeld and Marcus Denker},
  title = {Type feedback for bytecode interpreters},
  booktitle = {Proceedings of the Second Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS'2007), ECOOP Workshop},
  pages = {17--22},
  publisher = {TU Berlin},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Haup07a-ICOOLPS07-PIC.pdf},
  abstract = {This position paper proposes the exploitation of
 type feedback mechanisms, or more precisely,
 polymorphic inline caches, for purely interpreting
 implementations of object-oriented programming
 languages. Using Squeak's virtual machine as an
 example, polymorphic inline caches are discussed as
 an alternative to global caching. An implementation
 proposal for polymorphic inline caches in the Squeak
 virtual machine is presented, and possible future
 applications for online optimization are outlined.},
  annote = {internationalworkshop},
  issn = {1436-9915},
  keywords = {scg07 scg-pub skip-doi jb08 snf07 fromscgbib marcusdenker},
  medium = {2},
  month = jul}

@incollection{Henr13a,
  author = {St\'ephane Ducasse and Dale Henrichs and Martinez Peck, Mariano and Jannik Laval},
  title = {Managing Projects with Metacello},
  booktitle = {Deep Into Pharo},
  pages = 42,
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@inproceedings{Hern19a,
  author = {Hern\`andez Phillips, Carolina and Guillermo Polito and Luc Fabresse and  St\'ephane Ducasse and Noury Bouraqadi and Pablo Tesone},
  title = {Challenges in Debugging Bootstraps of Reflective Kernels},
  booktitle = {{IWST19 - International workshop on Smalltalk Technologies}},
  year = {2019},
  hal-id = {hal-02297710},
  annote = {internationalworkshop},
  pdf = {https://hal.archives-ouvertes.fr/hal-02297710/file/challengesInBootstrappingReflectiveKernels-corrected.pdf},
  keywords = {IoT ; bootstrap ; language kernels}}

@inproceedings{Hofe06a,
  author = {Christoph Hofer and Marcus Denker and St\'ephane Ducasse},
  title = {Design and Implementation of a Backward-In-Time Debugger},
  booktitle = {Proceedings of NODE'06},
  volume = {P-88},
  pages = {17--32},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hofe06a-NODE06-Unstuck.pdf},
  abstract = {Traditional debugging and stepping execution trace
 are well-accepted techniques to understand deep
 internals about a program. However in many cases
 navigating the stack trace is not enough to find
 bugs, since the cause of a bug is often not in the
 stack trace anymore and old state is lost, so out of
 reach from the debugger. In this paper, we present
 the design and implementation of a backward-in-time
 debugger for a dynamic language, i.e, a debugger
 that allows one to navigate back the history of the
 application. We present the design and
 implementation of a backward-in-time debugger called
 Unstuck and show our solution to key implementation
 challenges.},
  annote = {internationalconference},
  keywords = {skip-doi scg-pub stefPub jb07 fb06 snf06 fromscgbib marcusdenker kzDynamicInformation kzTools},
  medium = {2},
  month = sep,
  organization = {Gesellschaft f{\"u}r Informatik (GI)},
  series = {Lecture Notes in Informatics}}

@inproceedings{Hora12a,
  author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Muhammad Bhatti and Cesar Couto and Marco T\'ulio Valente and Julio Martins},
  title = {BugMaps: A Tool for the Visual Exploration and Analysis of Bugs},
  booktitle = {Proceedings of the 16th European Conference on Software Maintenance and Reengineering (CSMR'12) - Tool Demonstration Track},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora12a-Official-CSMR2012Tools-BugMaps.pdf},
  abstract = {To harness the complexity of big legacy software, software engineering tools need more and more information on these systems. This information may come from analysis of the source code, study of execution traces, computing of metrics, etc. One source of information received less attention than source code: the bugs on the system. Little is known about the evolutionary behavior, lifetime, distribution, and stability of bugs. In this paper, we propose to consider bugs as first class entities and a useful source of information that can answer such topics. Such analysis is inherently complex, because bugs are intangible, invisible, and difficult to be traced. Therefore, our tool extracts information about bugs from bug tracking systems, link this information to other software artifacts, and explore interactive visualizations of bugs that we call bug maps.},
  annote = {tooldemo},
  hal-id = {hal-00668397},
  keywords = {moose lse-pub raweb2012 kzVisualization},
  tagnicolasa = {other analysis}}

@inproceedings{Hora12b,
  author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Simon Allier},
  title = {Domain Specific Warnings: Are They Any Better?},
  booktitle = {Proceedings of the 28th IEEE International Conference on Software Maintenance (ICSM'12)},
  year = {2012},
  misc = {acceptance rate: 46/181 = 25\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora12b-ICSM2012-DedicatedRules.pdf},
  abstract = {Tools to detect coding standard violations in source code are commonly used to improve code quality. One of their original goals is to prevent bugs, yet, a high number of false positives is generated by the rules of these tools, i.e., most warnings do not indicate real bugs. There are empirical evidences supporting the intuition that the rules enforced by such tools do not prevent the introduction of bugs in software. This may occur because the rules are too generic and do not focus on domain specific problems of the software under analysis. We underwent an investigation of rules created for a specific domain based on expert opinion to understand if such rules are worthwhile enforcing in the context of defect prevention. In this paper, we performed a systematic study to investigate the relation between generic and domain specific warnings and observed defects. From our experiment on a real case, long term evolution, software, we have found that domain specific rules provide better defect prevention than generic ones.},
  annote = {topconference internationalconference},
  hal-id = {hal-00848830},
  keywords = {moose lse-pub raweb2012 kzChecking},
  rate = {25\%},
  tagnicolasa = {other analysis}}

@inproceedings{Hora13a,
  author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {Mining System Specific Rules from Change Patterns},
  booktitle = {Proceedings of the 20th Working Conference on Reverse Engineering (WCRE'13)},
  year = {2013},
  misc = {Acceptance rate: 38/97 = 39\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora13a-MinedRules-WCRE13.pdf},
  abstract = {A significant percentage of warnings reported by tools to detect coding standard violations are false positives. Thus, there are some works dedicated to provide better rules by mining them from source code history, analyzing bug-fixes or changes between system releases. However, software evolves over time, and during development not only bugs are fixed, but also features are added, and code is refactored. In such cases, changes must be consistently applied in source code to avoid maintenance problems. In this paper, we propose to extract system specific rules by mining systematic changes over source code history, i.e., not just from bug-fixes or system releases, to ensure that changes are consistently applied over source code. We focus on structural changes done to support API modification or evolution with the goal of providing better rules to developers. Also, rules are mined from predefined rule patterns that ensure their quality. In order to assess the precision of such specific rules to detect real violations, we compare them with generic rules provided by tools to detect coding standard violations on four real world systems covering two programming languages. The results show that specific rules are more precise in identifying real violations in source code than generic ones, and thus can complement them.},
  annote = {internationalconference},
  hal-id = {hal-00854861},
  keywords = {moose lse-pub cutter kzChecking},
  tagnicolasa = {other analysis}}

@inproceedings{Hora14a,
  author = {Andre Hora and Anne Etien and Nicolas Anquetil and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {APIEvolutionMiner: Keeping API Evolution under Control},
  booktitle = {Proceedings of the Software Evolution Week (CSMR-WCRE'14)},
  year = {2014},
  misc = {acceptance rate: 27/86 = 31\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora14a-CSMR-WCRE-APIEvolutionMiner.pdf},
  abstract = {During software evolution, source code is constantly refactored. In real-world migrations, many methods in the newer version are not present in the old version (e.g., 60\% of the methods in Eclipse 2.0 were not in version 1.0). This requires changes to be consistently applied to reflect the new API and avoid further maintenance problems. In this paper, we propose a tool to extract rules by monitoring API changes applied in source code during system evolution. In this process, changes are mined at revision level in code history. Our tool focuses on mining invocation changes to keep track of how they are evolving. We also provide three case studies in order to evaluate the tool.},
  annote = {internationalconference},
  hal-id = {hal-00991722},
  keywords = {moose lse-pub cutter kzChecking},
  tagnicolasa = {other analysis}}

@phdthesis{Hora14b,
  author = {Andre Cavalcante Hora},
  title = {Assessing and Improving Rules to Support Software Evolution},
  year = {2014},
  school = {University Lille 1 - Sciences et Technologies - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2014-Hora.pdf},
  abstract = {Software systems evolve by adding new features, fixing bugs or refactoring existing source code. During this process, some problems may occur (e.g., backward-incompatibility, missing or unclear method deprecation) causing evolving systems and their clients to be inconsistent or to fail, decreasing code quality. As nowadays software systems are frequently part of bigger ecosystems, such problems are even harder to handle because the impact may be large and unknown.One solution to deal with such maintainability problems is the usage of rules to ensure consistency. These rules may be created by experts or extracted from source code repositories, which are commonly evaluated in small-scale case studies. We argue that existing approaches lack of: (i) a deep understanding of the benefits provided by expert-based rules, (ii) a better use of source code repositories to extract history-based rules, and (iii) a large-scale analysis of the impact of source code evolution on the actual clients.In this thesis we propose to analyze and improve rules to better support developers keeping track of source code evolution. We cover three aspects. The benefits provided by expert-based rules: we report on an investigation of rules created based on expert opinion to understand whether they are worthwhile to be adopted given the cost to produce them. The improvement of history-based rules: we propose two solutions to extract better rules from source code history. The impact of source code evolution on a software ecosystem: we undergo an investigation, in a large-scale ecosystem, on the awareness of the client systems about source code evolution.We evaluated the proposed approaches qualitatively and quantitatively in real-world case studies, and, in many cases, with the help of experts on the system under analysis. The results we obtained demonstrate the usefulness of our approaches.},
  hal-id = {tel-01087860},
  keywords = {lse-pub},
  month = {nov}}

@inproceedings{Hora15a,
  author = {Andr\'e Hora and Romain Robbes and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {How Do Developers React to API Evolution? The Pharo Ecosystem Case},
  booktitle = {Proceedings of the 31st IEEE International Conference on Software Maintenance},
  year = {2015},
  misc = {acceptance rate: 32/148 = 22\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora15a-icsme-api-evolution.pdf},
  hal-id = {hal-01185736},
  keywords = {lse-pub},
  tagnicolasa = {other analysis},
  annote = {topconference}}

@article{Hora15b,
  author = {Andr\'e Hora and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {Automatic Detection of System-Specific Conventions Unknown to Developers},
  journal = {Journal of Systems and Software},
  year = {2015},
  doi = {10.1016/j.jss.2015.08.007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Hora15b-JSS-detection-specific-conventions.pdf},
  hal-id = {hal-01185837},
  keywords = {lse-pub kzEvolution},
  tagnicolasa = {other analysis},
  annote = {internationaljournal}}

@inproceedings{Hora15c,
  author = {Hora, Andre and Valente, Marco Tulio},
  title = {apiwave: Keeping track of api popularity and migration},
  booktitle = {2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  pages = {321--323},
  year = {2015},
  organization = {IEEE}}

@inproceedings{Hora16b,
  author = {Cavalcante Hora, Andr{\'e} and Tulio Valente, Marco and Robbes, Romain and Anquetil, Nicolas},
  title = {{When should internal interfaces be promoted to public?}},
  booktitle = {{FSE 2016 Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering }},
  year = {2016},
  url = {https://hal.inria.fr/hal-01417888},
  doi = {10.1145/2950290.2950306},
  address = {Seattle, United States},
  keywords = {lse-pub kzEvolution},
  month = nov,
  hal-id = {hal-01417888},
  annote = {internationalconference},
  tagnicolasa = {other analysis},
  inria = {RMOD}}

@article{Hora18a,
  author = {Hora, Andr{\'e} and Robbes, Romain and Tulio Valente, Marco and Anquetil, Nicolas and Etien, Anne and Ducasse, St\'ephane},
  title = {{How do Developers React to API Evolution? a Large-Scale Empirical Study}},
  journal = {{Software Quality Journal}},
  volume = {26},
  pages = {161-191},
  publisher = {{Springer Verlag}},
  year = {2018},
  url = {https://hal.inria.fr/hal-01417930},
  doi = {10.1007/s11219-016-9344-4},
  issue = {1},
  keywords = {lse-pub kzEvolution},
  month = mar,
  pdf = {https://hal.inria.fr/hal-01417930/file/2017-sqj.pdf},
  hal-id = {hal-01417930},
  tagnicolasa = {other analysis}}

@inproceedings{Kale17a,
  author = {Sophie Kaleba and Cl\'ement B\'era and Alexandre Bergel and St\'ephane Ducasse},
  title = {A detailed VM profiler for the Cog VM},
  booktitle = {International Workshop on Smalltalk Technology {IWST'17}},
  year = {2017},
  url = {https://hal.inria.fr/hal-01585754},
  annote = {internationalworkshop},
  abstract = {Code profiling enables a user to know where in an application or function the execution time is spent. The Pharo ecosystem offers several code profilers. However, most of the publicly available profilers (MessageTally, Spy, GadgetPro-filer) largely ignore the activity carried out by the virtual machine , thus incurring inaccuracy in the gathered information and missing important information, such as the Just-in-time compiler activity. This paper describes the motivations and the latest improvements carried out in VMProfiler, a code execution pro-filer hooked into the virtual machine, that performs its analysis by monitoring the virtual machine execution. These improvements address some limitations related to assessing the activity of native functions (resulting from a Just-in-time compiler operation): as of now, VMProfiler provides more detailed profiling reports, showing for native code functions in which bytecode range the execution time is spent.},
  address = {Maribor, Slovenia},
  month = sep,
  keywords = {lse-pub kzInfrastructure},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kale17a-IWST-VMProfiler.pdf},
  hal-id = {hal-01585754}}

@inproceedings{Kale18a,
  author = {Sophie Kaleba and Cl\'ement B\'era and St\'ephane Ducasse},
  title = {Assessing primitives performance on multi-stage execution},
  booktitle = {International Workshop on Smalltalk Technology {IWST'18}},
  year = {2018},
  url = {https://hal.archives-ouvertes.fr/hal-01874947},
  annote = {internationalworkshop},
  abstract = {Virtual machines, besides the interpreter and just-in-time compiler optimization facilities, also include a set of primitive operations that the client language can use. Some of these are essential and cannot be performed in any other way. Others are optional: they can be expressed in the client language but are often implemented in the virtual machine to improve performance when the just-in-time compiler is unable to do so (start-up performance, speculative optimizations not implemented or not mature enough, etc.). In a hybrid runtime, where code is executed by an interpreter and a just-in-time compiler, the implementor can choose to implement optional primitives in the client language , in the virtual machine implementation language (typically C or C++), or on top of the just-in-time compiler back-end. This raises the question of the maintenance and performance trade-offs of the different alternatives. As a case study, we implemented the String comparison optional primitive in each case. This paper describes the different implementations , discusses the maintenance cost of each of them and evaluates for different string sizes the execution time in Cog, a Smalltalk virtual machine.},
  keywords = {kzInfrastructure lse-pub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kabe18a-VMStringOptimisation.pdf}}

@inproceedings{Kale18b,
  author = {Sophie Kaleba and Cl\'ement B\'era and Eliot Miranda},
  title = {Garbage Collection Evaluation Infrastructure for the Cog VM},
  booktitle = {Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems Workshop, ICOOOLPS'18},
  year = {2018},
  url = {https://hal.archives-ouvertes.fr/hal-01874946},
  annote = {internationalworkshop},
  abstract = {One of the next steps to improve Cog, the default vir- tual machine for multiple programming languages in the Smalltalk family, such as Pharo, Squeak and Newspeak, is to decrease garbage collection pause times. Refer- ence garbage collection algorithm implementations and a benchmarking infrastructure are required to evaluate the performance of a new algorithm and compare it. Cog features a Mark-Compact algorithm, used in production, to which we added a Mark-Sweep algorithm, providing two reference algorithms. Benchmarks are built using two different approaches. Firstly, we turned code from memory intensive deployed applications into benchmarks to simulate real-world applications. Secondly, we built a configurable benchmark which simulates an application with different heap properties to be able to stress specific aspects of the memory management. We then evaluated the two reference algorithms on the infrastructure built to obtain reference benchmark results.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kale18b-GC-IWST.pdf}}

@inproceedings{Kuhn05a,
  author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
  title = {Enriching Reverse Engineering with Semantic Clustering},
  booktitle = {Proceedings of 12th Working Conference on Reverse Engineering (WCRE'05)},
  pages = {113--122},
  publisher = {IEEE Computer Society Press},
  year = {2005},
  misc = {acceptance rate: 21/58 = 36 \%},
  doi = {10.1109/WCRE.2005.16},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kuhn05aSemanticClustering.pdf},
  abstract = {Understanding a software system by just analyzing the structure of the system reveals only half of the picture, since the structure tells us only how the code is working but not what the code is about. What the code is about can be found in the semantics of the source code: names of identifiers, comments etc. In this paper, we analyze how these terms are spread over the source artifacts using Latent Semantic Indexing, an information retrieval technique. We use the assumption that parts of the system that use similar terms are related. We cluster artifacts that use similar terms, and we reveal the most relevant terms for the computed clusters. Our approach works at the level of the source code which makes it language independent. Nevertheless, we correlated the semantics with structural information and we applied it at different levels of abstraction (e.g. classes, methods). We applied our approach on three large case studies and we report the results we obtained.},
  acceptnum = {21},
  accepttotal = {58},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub semantic clustering lsi stefPub girba recast06 hapax moose kzVisualization kzRemodularisation},
  location = {Pittsburgh, PA},
  month = nov,
  rate = {36\%}}

@article{Kuhn07a,
  author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
  title = {Semantic Clustering: Identifying Topics in Source Code},
  journal = {Information and Software Technology},
  volume = {49},
  pages = {230--243},
  publisher = {Butterworth-Heinemann},
  year = {2007},
  impactfactor = {ISI impact factor (2010) 1.821},
  doi = {10.1016/j.infsof.2006.10.017},
  pdf = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf},
  abstract = {Many of the existing approaches in Software
 Comprehension focus on program program structure or
 external documentation. However, by analyzing formal
 information the informal semantics contained in the
 vocabulary of source code are overlooked. To
 understand software as a whole, we need to enrich
 software analysis with the developer knowledge
 hidden in the code naming. This paper proposes the
 use of information retrieval to exploit linguistic
 information found in source code, such as identifier
 names and comments. We introduce Semantic
 Clustering, a technique based on Latent Semantic
 Indexing and clustering to group source artifacts
 that use similar vocabulary. We call these groups
 semantic clusters and we interpret them as
 linguistic topics that reveal the intention of the
 code. We compare the topics to each other, identify
 links between them, provide automatically retrieved
 labels, and use a visualization to illustrate how
 they are distributed over the system. Our approach
 is language independent as it works at the level of
 identifier names. To validate our approach we
 applied it on several case studies, two of which we
 present in this paper.},
  address = {Newton, MA, USA},
  annote = {internationaljournal},
  issn = {0950-5849},
  keywords = {moose scg-pub recast07 girba stefPub kzRemodularisation},
  month = mar,
  number = {3}}

@techreport{Kuhn10m,
  author = {Adrian Kuhn and David Erni and Marcus Denker},
  title = {Empowering Collections with Swarm Behavior},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Kuhn10a-ArXiv-SwarmBehavior.pdf},
  abstract = {Often, when modelling a system there are properties and operations that
	 are related to a group of objects rather than to a single object. In this paper we extend
	 Java with Swarm Behavior, a new composition operator that associates behavior with
	 a collection of instances. The lookup resolution of swarm behavior is based on the element
	 type of a collection and is thus orthogonal to the collection hierarchy.},
  annote = {technicalReport notrefereed},
  institution = {Arxiv},
  keywords = {lse-pub marcusdenker},
  month = jul,
  number = {arXiv:1007.0159}}

@incollection{Kurs13a,
  author = {Jan Kur\v{s} and Guillaume Larcheveque and Lukas Renggli and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {{PetitParser}: Building Modular Parsers},
  booktitle = {Deep Into Pharo},
  pages = 36,
  publisher = {Square Bracket Associates},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Kurs13a-PetitParser.pdf},
  isbn = {978-3-9523341-6-4},
  keywords = {skip-abstract skip-doi scg-pub scg13 snf-asa1 jb14 kursjan},
  medium = {2},
  month = sep,
  peerreview = {no}}

@inproceedings{Lanz01a,
  author = {Michele Lanza and St\'ephane Ducasse and Lukas Steiger},
  title = {Understanding Software Evolution using a Flexible Query Engine},
  booktitle = {Proceedings of the Workshop on Formal Foundations of Software Evolution},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz01aQueryEngine.pdf},
  abstract = {One of the main problems which arises in the field
 of software evolution is the sheer amount of
 information to be dealt with. Compared to reverse
 engineering where the main goal is the main
 understanding of one single system. In the field of
 software evolution this information is multiplied by
 the number of versions of the system one wants to
 understand. To counter this problem we have come up
 with a flexible query engine which can perform
 queries on the different versions of a system. In
 this paper we give an outlook on our current work in
 the field of software evolution and focus
 particularly on the concepts behind the query engine
 we have built.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub moose kzVisualization kzHistory}}

@inproceedings{Lanz01b,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {A {Categorization} of {Classes} based on the {Visualization} of their {Internal} {Structure}: the {Class} {Blueprint}},
  booktitle = {Proceedings of 16th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '01)},
  pages = {300--311},
  publisher = {ACM Press},
  year = {2001},
  misc = {acceptance rate: 27/145 = 18\%},
  doi = {10.1145/504282.504304},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz01bClassBlueprint.pdf},
  abstract = {The reengineering and reverse engineering of
 software systems is gaining importance in software
 industry, because the accelerated turnover in
 software companies creates legacy systems in a
 shorter period of time. Especially understanding
 classes is a key activity in object-oriented
 programming, since classes represent the primary
 abstractions from which applications are built. The
 main problem of this task is to quickly grasp the
 purpose of a class and its inner structure. To help
 the reverse engineers in their first contact with a
 foreign system, we propose a categorization of
 classes based on the visualization of their internal
 structure. The contributions of this paper are a
 novel categorization of classes and a visualization
 of the classes which we call the class blueprint. We
 have validated the categorization on several case
 studies, two of which we present here.},
  acceptnum = {27},
  accepttotal = {145},
  annote = {internationalconference topconference},
  keywords = {scg-pub stefPub moose kzVisualization}}

@inproceedings{Lanz01d,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {The Class Blueprint: A Visualization of the Internal Structure of Classes},
  booktitle = {Workshop Proceedings of OOPSLA 2001},
  year = {2001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz01dClassBlueprint.pdf},
  abstract = {Understanding classes is a key activity in
 object-oriented programming, since classes represent
 the primary abstractions from which applications are
 built. The main problem of this task is to quickly
 grasp the purpose and inner structure of a class. In
 this paper we discuss the class blueprint, a
 visualization of the inner structure of classes.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub moose kzVisualization}}

@inproceedings{Lanz02a,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {Understanding Software Evolution Using a Combination of Software Visualization and Software Metrics},
  booktitle = {Proceedings of Langages et Mod\`eles \`a Objets (LMO'02)},
  pages = {135--149},
  publisher = {Lavoisier},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz02aEvolutionMatrix.pdf},
  abstract = {Coping with huge amounts of data is one of the major
 problems in the context of software evolution.
 Current approaches reduce this complexity by
 filtering out irrelevant information. In this paper
 we propose an approach based on a combination of
 software visualization and software metrics, as
 software visualization is apt for complexity
 reduction and metrics introduce the possibility to
 qualify evolution. We discuss a simple and effective
 way to visualize the evolution of software systems
 which helps to recover the evolution of object
 oriented software systems. In addition we define a
 vocabulary that qualifies some specific situations
 that occurs when considering system evolution.},
  address = {Paris},
  annote = {nationalconference},
  keywords = {scg-pub skip-doi stefPub moose kzVisualization kzMetric kzHistory}}

@inproceedings{Lanz02b,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {Beyond Language Independent Object-Oriented Metrics: Model Independent Metrics},
  booktitle = {Proceedings of the 6th International Workshop on Quantitative Approaches in Object-Oriented Software Engineering},
  pages = {77--84},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz02bModelIndependentMetrics.pdf},
  abstract = {Software Metrics have become essential in software
 engineering for several reasons, among which quality
 assessment and reengineering. In the context of the
 European Esprit Project FAMOOS, whose main goal was
 to provide methodologies for the reengineering of
 large industrial software systems, we have developed
 the Moose Reengineering Environment, based on the
 language independent FAMIX metamodel. Moose includes
 a metrics engine which supports language independent
 metrics, since coping with software written in
 different implementation languages was one of the
 project's main constraints. Our current research is
 pushing us towards the development and
 implementation of a metametamodel, which would
 include our metamodel and allow for several
 extension in different research directions, among
 which concept analysis, knowledge management and
 software evolution. In this article we want to
 present our current and future work for the
 transition from language independent to domain
 independent metrics.},
  annote = {internationalworkshop},
  editor = {Fernando Brito e Abreu and Mario Piattini and Geert Poels and Houari A. Sahraoui},
  isbn = {84-699-8696-1},
  keywords = {scg-pub skip-doi stefPub moose kzMetric kzMeta}}

@article{Lanz03d,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {Polymetric Views---A Lightweight Visual Approach to Reverse Engineering},
  journal = {Transactions on Software Engineering (TSE)},
  volume = {29},
  pages = {782--795},
  publisher = {IEEE Computer Society},
  year = {2003},
  impactfactor = {5-Year ISI impact factor (2010) 4.865},
  doi = {10.1109/TSE.2003.1232284},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz03dTSEPolymetric.pdf},
  abstract = {Reverse engineering software systems has become a
 major concern in software industry because of their
 sheer size and complexity. This problem needs to be
 tackled, since the systems in question are of
 considerable worth to their owners an d maintainers.
 In this article we present the concept of a
 polymetric view, a lightweight software
 visualization technique enriched with software
 metrics information. Polymetric views help to
 understand the structure and detect problems of a
 software system in the initial phases of a reverse
 engineering process. We discuss the benefits and
 limits of several predefined polymetric views we
 have implemented in our tool CodeCrawler. Moreover,
 based on clusters of different polymetric views we
 have developed a methodology which supports and
 guides a software engineer in the first phases of a
 reverse engineering of a large software system. We
 have refined this methodology by repeatedly applying
 it on industrial systems, and illustrate it by
 applying a selection of polymetric views to a case
 study.},
  annote = {internationaljournal},
  keywords = {scg-pub recast04 stefPub moose kzVisualization},
  month = sep,
  number = {9}}

@inproceedings{Lanz05a,
  author = {Michele Lanza and St\'ephane Ducasse and Harald Gall and Martin Pinzger},
  title = {CodeCrawler --- An Information Visualization Tool for Program Comprehension},
  booktitle = {Proceedings of ICSE 2005 (27th IEEE International Conference on Software Engineering)},
  pages = {672--673},
  publisher = {ACM Press},
  year = {2005},
  annote = {tooldemo},
  keywords = {stefPub moose kzVisualization}}

@incollection{Lanz05b,
  author = {Michele Lanza and St\'ephane Ducasse},
  title = {CodeCrawler --- An Extensible and Language Independent 2D and 3D Software Visualization Tool},
  booktitle = {Tools for Software Maintenance and Reengineering},
  pages = {74--94},
  publisher = {Franco Angeli},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lanz05bCCBookChapter.pdf},
  abstract = {CodeCrawler is an extensible and language
 independent software visualization tool. It has been
 validated in several industrial case studies over
 the past years. CodeCrawler enables the fast
 exploration of new visualization ideas. It
 implements and visualizes polymetric views,
 visualizations of software enriched with information
 such as software metrics and other source code
 semantics. It provides a rich set of views that can
 be customized using a large set of metrics. While
 CodeCrawler is mainly targeted at visualizing
 object-oriented software, in its latest
 implementation it has become a general information
 visualization tool.},
  address = {Milano},
  annote = {articlebook},
  isbn = {88-464-6396-X},
  keywords = {scg-pub skip-doi stefPub recast05 moose kzVisualization kzTools},
  series = {RCOST / Software Technology Series}}

@inproceedings{Laut09a,
  author = {Juan Lautaro Fern\'andez and Santiago Robles and Andr\'es Fortier and St\'ephane Ducasse and Gustavo Rossi and Silvia Gordillo},
  title = {Meteoroid Towards a real MVC for the Web},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
  publisher = {ACM Digital Library},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Laut09a-IWST09-Meteroid.pdf},
  abstract = {Web development has moved from simple static pages to complex web applications, some of them
resembling desktop ones. In most of these applications the web browser acts as thin-client (or a view) of the
model that sits on the server. Despite the technological evolution of the web, there is still no standard
mechanism to send data or events from the server to the client without an explicit request from the later,
thus forcing the web browser to constantly poll the server for updates. To solve this problem a set of
techniques under the name of Comet were proposed, allowing to send information from the server to the web
browser without an explicit client request. In this paper we introduce Meteoroid, a Comet approach to make
live Seaside applications. Our framework exploits the Model-View-Controller (MVC) paradigm for building
 simple yet scalable web applications, requiring very little programming effort.},
  annote = {internationalworkshop},
  keywords = {stefPub kzWeb},
  location = {Brest, France},
  x-pays = {AR}}

@inproceedings{Lava08a,
  author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
  title = {Assessing the Quality of your Software with MoQam},
  booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava08a-Famoosr2008-MoQam.pdf},
  annote = {internationalworkshop},
  hal-id = {inria-00498482},
  keywords = {moose lse-pub stefPub kzMetric}}

@inproceedings{Lava09a,
  author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
  title = {Matrice de d\'ependances enrichie},
  booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO 2009)},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09a-LMO2009-DSM.pdf},
  abstract = {Les matrices de d\'ependance (DSM - Dependency Structure Matrix), d\'evelopp\'ees dans le cadre de l'optimisation de processus, ont fait leurs preuves pour identifier les d\'ependances logicielles entre des packages ou des sous-syst\`e\-mes. Il existe plusieurs algorithmes pour structurer une matrice de fa\c con \`a ce qu'elle refl\`ete l'architecture des \'el\'ements analys\'es et mette en \'evidence des cycles entre les sous-sys\-t\`e\-mes. Cependant, les impl\'ementations de matrices de d\'ependance existantes manquent d'informations importantes pour apporter une r\'eelle aide au travail de r\'eing\'enierie. Par exemple, le poids des relations qui posent probl\`eme ainsi que leur type ne sont pas clairement pr\'esent\'es. Ou encore, des cycles ind\'ependants sont fusionn\'es. Il est \'egalement difficile d'obtenir une visualisation centr\'ee sur un package.	Dans ce papier, nous am\'eliorons les matrices de d\'ependance en ajoutant des informations sur (i) le type de r\'ef\'erences, (ii) le nombre d'entit\'es r\'ef\'eren\c cantes, (iii) le nombre d'entit\'es r\'ef\'erenc\'ees. Nous	distinguons \'egalement les cycles ind\'ependants. Ce travail a \'et\'e impl\'ement\'e dans l'environnement de r\'eing\'enierie open-source \emph{Moose}. Il a \'et\'e appliqu\'e \`a des \'etudes de cas complexes comme le framework \emph{Morphic UI} contenu dans les environnements Smalltalk open-source \emph{Squeak} et	\emph{Pharo}. Les r\'esultats obtenus ont \'et\'e appliqu\'es dans l'environnement de programmation \emph{Pharo} et ont men\'e \`a des am\'eliorations.},
  address = {Nancy, France},
  annote = {nationalconference},
  hal-id = {inria-00498463},
  keywords = {moose lse-pub pharo pharo-pub kzCycle kzRemodularisation}}

@inproceedings{Lava09b,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Andy Kellens},
  title = {Supporting Incremental Changes in Large System Models},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies},
  pages = {1--7},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09b-IWST09-incrementalChange.pdf},
  abstract = {When reengineering large systems, software developers would like to assess and compare the impact of multiple change scenarios without actually performing these changes. A change can be effected by applying a tool to the source code, or by a manual refactoring. In addition, tools run over a model are costly to redevelop. It raises an interesting challenge for tools implementors: how to support modification of large source code models to enable comparison of multiple versions. One naive approach is to copy the entire model after each modification. However, such an approach is too expensive in memory and execution time. In this paper we explore different implementations that source code metamodels support multiple versions of a system. We propose a solution based on dynamic binding of entities between multiple versions, providing good access performance while minimizing memory consumption.},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {inria-00498492},
  keywords = {moose lse-pub pharo pharo-pub kzMeta},
  series = {IWST'09}}

@inproceedings{Lava09c,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Alexandre Bergel},
  title = {Identifying cycle causes with Enriched Dependency Structural Matrix},
  booktitle = {WCRE '09: Proceedings of the 2009 16th Working Conference on Reverse Engineering},
  year = {2009},
  misc = {Acceptance rate: 20/79 = 25\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09c-WCRE2009-eDSM.pdf},
  abstract = {Dependency Structure Matrix (DSM) has been successfully applied to identify software
 dependencies among packages and subsystems. A number of algorithms were proposed to compute the
 matrix so that it highlights patterns and problematic dependencies between subsystems. However,
 existing DSM implementations often miss important information to fully support reengineering
 effort. For example, they do not clearly qualify and quantify problematic relationships,
 information which is crucial to support remediation tasks.
In this paper we present enriched DSM (eDSM) where cells are enriched with contextual information
 about (i) the type of dependencies (inheritance, class reference . . . ), (ii) the proportion of
 referencing entities, (iii) the proportion of referenced entities. We distinguish independent
 cycles and stress potentially simple fixes for cycles using coloring information. This work is
 language independent and has been implemented on top of the Moose reengineering environment. It has
 been applied to non-trivial case studies among which ArgoUML, and Morphic the UI framework
 available in two open-source Smalltalks, Squeak and Pharo. Solution to problems identified by eDSM
 have been performed and retrofitted in Pharo main distribution.},
  address = {Lille, France},
  annote = {internationalconference},
  hal-id = {inria-00498446},
  keywords = {moose lse-pub pharo pharo-pub kzVisualization kzCycle},
  rate = {25\%}}

@inproceedings{Lava09d,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
  title = {Identifying cycle causes with CycleTable},
  booktitle = {FAMOOSr 2009: 3rd Workshop on FAMIX and MOOSE in Software Reengineering},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava09d-Famoosr2009-CycleTable.pdf},
  abstract = {No abstract},
  address = {Brest, France},
  annote = {internationalworkshop},
  hal-id = {inria-00498495},
  keywords = {moose lse-pub pharo pharo-pub kzCycle}}

@misc{Lava10a,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Optimisation d'applications en Pharo},
  journal = {Linux Magazine},
  volume = {1},
  year = {2010},
  annote = {vulgarisation},
  hal-id = {hal-00746241},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub kzVulgarisation},
  month = jan,
  number = 123}

@article{Lava10b,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Jean-R\'emy Falleri},
  title = {Supporting Simultaneous Versions for Software Evolution Assessment},
  journal = {Journal of Science of Computer Programming (SCP)},
  volume = {76},
  pages = {1177-1193},
  year = {2011},
  impactfactor = {5-year impact factor (2012) 0.903},
  doi = {10.1016/j.scico.2010.11.014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava10a-Official-SCP-Orion.pdf},
  abstract = {When reengineering software systems, maintainers should be able to assess and compare multiple change scenarios for a given goal, so as to choose the most pertinent one. Because they implicitly consider one single working copy, revision control systems do not scale up well to perform simultaneous analyses of multiple versions of systems. We designed Orion, an interactive prototyping tool for reengineering, to simulate changes and compare their impact on multiple versions of software source code models. Our approach offers an interactive simulation of changes, reuses existing assessment tools, and has the ability to hold multiple and branching versions simultaneously in memory. Specifically, we devise an infrastructure which optimizes memory usage of multiple versions for large models. This infrastructure uses an extension of the FAMIX source code meta-model but it is not limited to source code analysis tools since it can be applied to models in general. In this paper, we validate our approach by running benchmarks on memory usage and computation time of model queries on large models. Our benchmarks show that the Orion approach scales up well in terms of memory usage, while the current implementation could be optimized to lower its computation time. We also report on two large case studies on which we applied Orion.},
  annote = {internationaljournal},
  hal-id = {inria-00531500},
  inriareport = {2010},
  keywords = {lse-pub moose rawed2010 pharo pharo-pub kzMeta kzCycle kzRemodularisation},
  month = may,
  number = {12}}

@misc{Lava10c,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Pharo: un nouveau Smalltalk open source},
  journal = {Linux Magazine},
  volume = {1},
  year = {2010},
  annote = {vulgarisation},
  hal-id = {hal-00746242},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub raweb2010 kzVulgarisation},
  month = sep,
  number = 130}

@misc{Lava10d,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Package et gestion de versions en Pharo},
  journal = {Linux Magazine},
  volume = {1},
  year = {2010},
  annote = {vulgarisation},
  hal-id = {hal-00746243},
  inriareport = {2010},
  keywords = {pharo-pub lse-pub raweb2010 kzVulgarisation},
  month = nov,
  number = 132}

@inproceedings{Lava10e,
  author = {Jannik Laval and Nicolas Anquetil and St\'ephane Ducasse},
  title = {OZONE: Package Layered Structure Identification in presence of Cycles},
  booktitle = {Proceedings of the 9th edition of the Workshop BElgian-NEtherlands software eVOLution seminar (BENEVOL'10)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava10e-Benevol2010-Layers.pdf},
  abstract = {Packages are complex entities and it can be difficult to understand them as they play different roles (e.g., core package, UI class container, tests package . . . ). In particular, package interdependencies make difficult their management (substitution, evolutions, deprecation). Understanding whether a package has high or low impact on the system is another valuable piece of information. In addition, package organization represents the backbone of large software system. It is is usually agreed that packages should form layered structures. However, identifying such layered structure is difficult since packages are often in cycles. Several approaches propose to recover software structure or to visualize classes or files organization. Only few approaches provide layered organization and in particular take cycle into account. In this paper, we propose an approach which provides (i) a strategy to highlight dependencies which break Acyclic Dependency Principle and (ii) an organization of package (even in presence of cycles) in multiple layers. While our approach can be run automatically, it also supports human inputs and constraints. We validate our approach with a preliminary study on the structure of the Moose software analysis platform: it shows promising results.},
  annote = {internationalworkshop},
  inriareport = {2010},
  keywords = {moose lse-pub raweb2010 pharo pharo-pub kzCycle kzRemodularisation},
  tagnicolasa = {architecture}}

@phdthesis{Lava11b,
  author = {Jannik Laval},
  title = {Package Dependencies Analysis and Remediation in Object-Oriented Systems},
  year = {2011},
  school = {Universit\'e de Lille},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2011-Laval.pdf},
  abstract = {Software evolves over time with the modification, addition and removal of new classes, methods, functions, dependencies. A consequence is that behavior may not be placed in the right packages and the software modularization is broken. A good organization of classes into identifiable and collaborating packages eases the understanding, maintenance, test and evolution of software systems. We argue that maintainers lack tool support for understanding the concrete organization and for structuring packages within their context.
Our claim is that the maintenance of large software modularizations needs approaches that help (i) understanding the structure at package level and assessing its quality; (ii) identifying modularity problems; and (iii) take decisions and verify the impact of these decisions.
In this thesis, we propose ECOO, an approach to help reengineers identify and understand structural problems in software architectures and to support the remodularization activity. It concerns the three following research fields:
- Understanding package dependency problems. We propose visualizations to highlight cyclic dependencies problems at package level.
- Proposing dependencies to be changed for remodularization. The approach proposes dependencies to break to make the system more modular.
- Analyzing impact of change. The approach proposes a change impact analysis to try modifications before applying them on the real system.
The approaches presented in this thesis have been qualitatively and quantitatively validated and results have been taken into account in the reengineering of analyzed systems. The results we obtained demonstrate the usefulness of our approach.},
  hal-id = {tel-00601546},
  institution = {INRIA},
  keywords = {lse-pub raweb2011 pharo pharo-pub}}

@article{Lava12b,
  author = {Jannik Laval and Jean-R\'{e}my Falleri and Philippe Vismara and St\'ephane Ducasse},
  title = {Efficient Retrieval and Ranking of Undesired Package Cycles in Large Software Systems},
  journal = {Journal of Object Technology},
  volume = {11},
  pages = {1-24},
  year = {2012},
  url = {http://www.jot.fm/contents/issue\_2012\_04/article4.html},
  doi = {10.5381/jot.2012.11.1.a4},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava12b-JOT-Ranking.pdf},
  annote = {internationaljournal},
  hal-id = {hal-00692569},
  issn = {1660-1769},
  keywords = {lse-pub moose kzRemodularization stefPub},
  month = apr,
  number = {1}}

@article{Lava13a,
  author = {Jannik Laval and Nicolas Anquetil and Usman Bhatti and St\'ephane Ducasse},
  title = {oZone: Layer identification in the presence of cyclic dependencies},
  journal = {Science of Computer Programming},
  volume = {78},
  pages = {1055--1072},
  year = {2013},
  impactfactor = {Impact Factor (2013) 0.548},
  doi = {10.1016/j.scico.2012.08.001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava13a-Official-OzoneLayer-SCO.pdf},
  annote = {internationaljournal},
  hal-id = {hal-00732655},
  keywords = {lse-pub moose kzRemodularization stefPub},
  number = {8},
  tagnicolasa = {architecture}}

@incollection{Lava14a,
  author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
  title = {Visualisations pour la remodularisation \`a large \'echelle des syst\`emes \`a objets},
  booktitle = {Evolution et R\'enovation des Syst\`emes Logiciels},
  publisher = {Herm\`es},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava14a-Chapitresvisu.pdf},
  annote = {articlebook},
  ean13 = {9782746245549},
  keywords = {lse-pub cutter raweb2012 kzVisualization kzCycle}}

@article{Lava14b,
  author = {Jannik Laval and St\'ephane Ducasse},
  title = {Resolving cyclic dependencies between packages with Enriched Dependency Structural Matrix},
  journal = {Software: Practice and Experience},
  volume = {44},
  pages = {235-257},
  year = {2014},
  doi = {10.1002/spe.2164},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lava14b-Official-SoftwarePracticeExperience-ResolvingCyclicDependencies.pdf},
  annote = {internationaljournal},
  hal-id = {hal-00748120},
  keywords = {moose cutter kzCycle}}

@inproceedings{Lece18a,
  author = {Lecerf, Jason and Brant, John and Goubier, Thierry and Ducasse, St\'ephane},
  title = {A Reflexive and Automated Approach to Syntactic Pattern Matching in Code Transformations},
  booktitle = {IEEE International Conference on Software Maintenance and Evolution (ICSME'18)},
  year = {2018},
  doi = {10.1109/ICSME.2018.00052},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lece18a-ICSME-ReflectiveParsing.pdf},
  annote = {internationalconference topconference},
  abstract = {Empowering software engineers often requires to let them write code transformations. However existing automated or tool-supported approaches force developers to have a detailed knowledge of the internal representation of the underlying tool. While this knowledge is time consuming to master, the syntax of the language, on the other hand, is already well known to developers and can serve as a strong foundation for pattern matching. Pattern languages with metavariables (that is variables holding abstract syntax subtrees once the pattern has been matched) have been used to help programmers define program transformations at the language syntax level. The question raised is then the engineering cost of metavariable support. Our contribution is to show that, with a GLR parser, such patterns with metavariables can be supported by using a form of runtime reflexivity on the parser internal structures. This approach allows one to directly implement such patterns on any parser generated by a parser generation framework, without asking the pattern writer to learn the AST structure and node types. As a use case for that approach we describe the implementation built on top of the SmaCC (Smalltalk Compiler Compiler) GLR parser generator framework. This approach has been used in production for source code transformations on a large scale. We will express perspectives to adapt this approach to other types of parsing technologies.},
  hal-url = {https://hal.archives-ouvertes.fr/hal-01851857},
  address = {Madrid, Spain},
  month = sep,
  keywords = {StefPub kzEvolution kzTools parser generation ; GLR parsing ; syntactic patterns ; pattern matching ; code templates lse-pub},
  hal-id = {hal-01851857}}

@article{Ledo00a,
  author = {Ledoux, Thomas and Bouraqadi-Saadani, Noury},
  title = {Adaptability in mobile agent systems using reflection},
  journal = {ECOOP 2000, Workshop on Reflection and Metalevel Architectures},
  year = {2000}}

@inproceedings{Lent15a,
  author = {Skip Lentz, Mart\'in Dias and Damien Cassou},
  title = {Griotte: Improving Code Review with Fine-Grained IDE Events},
  booktitle = {{BENEVOL'15: 14th BElgian-NEtherlands software
 eVOLution seminar}},
  year = {2015},
  pdf = {http://rmod.lille.inria.fr/archives/workshops/Lent15a-BENEVOL15-GriotteCodeReview.pdf},
  abstract = {Code review is a difficult process because: (1) developers often create tangled commits, (2) a change may be scattered across many different parts of a project, (3) many changes are shadowed, (4) commit messages can be inaccurate or wrong. This  work aims to propose a solution to these problems by  exploiting the information provided by fine-grained IDE events. To put this solution in practice, we will develop a code review tool named Griotte in the Pharo IDE.},
  address = {Lille, France},
  annote = {internationalworkshop},
  keywords = {code review fine-grained IDE events Epicea Griotte Pharo}}

@incollection{Lesk13a,
  author = {Max Leske and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {Files with FileSystem},
  booktitle = {Deep Into Pharo},
  pages = 15,
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@techreport{Leth97a,
  author = {Timothy C. Lethbridge and Nicolas Anquetil},
  title = {Architecture of a Source Code Exploration Tool: A Software Engineering Case Study},
  year = {1997},
  institution = {University of Ottawa},
  month = jul,
  note = {Computer Science Technical Report of University of Ottawa},
  tagnicolasa = {other analysis}}

@inproceedings{Lian02a,
  author = {Peng Liang and Gabriela Ar{\'e}valo and St\'ephane Ducasse and Michele Lanza and Nathanael Sch{\"a}rli and Roel Wuyts and Oscar Nierstrasz},
  title = {Applying RMA for Scheduling Field Device Components},
  booktitle = {ECOOP 2002 Workshop Reader},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lian02aPecosRMA.pdf},
  abstract = {PECOS is a collaborative project between industrial and research partners that seeks to enable component-based technology for a class of embedded systems known as "field devices". Results so far include a component model for field devices and a composition language for specifying connections between software components. Here we investigate the application of Rate Monotonic Analysis (RMA) to the
 problem of generating real-time schedules for compositions of field device components.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi pecos stefPub arevalo schaerli kzComponent}}

@inproceedings{Lien05a,
  author = {Adrian Lienhard and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
  title = {Identifying Traits with Formal Concept Analysis},
  booktitle = {Proceedings of 20th Conference on Automated Software Engineering (ASE'05)},
  pages = {66--75},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 28/291 = 9\%},
  doi = {10.1145/1101908.1101921},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien05aIdentifyingTraits.pdf},
  abstract = {Traits are basically mixins or interfaces but with
 method bodies. In languages that support traits,
 classes are composed out of traits. There are two
 main advantages with traits. Firstly, decomposing
 existing classes into traits from which they can be
 recomposed improves the factoring of hierarchies.
 Secondly it increases the library reuse potential by
 providing more reusable traits. Identifying traits
 and decomposing class hierarchies into traits is
 therefore an important and challenging task to
 facilitate maintainability and evolution. In this
 paper we present how we use Formal Concept Analysis
 to identify traits in inheritance hierarchies. Our
 approach is two-staged: first we identify within a
 hierarchy maximal groups of methods that have a set
 of classes in common, second we cluster cohesive
 groups of methods based on method invocations as
 potential traits. We applied our approach on two
 significant hierarchies and compare our results with
 the manual refactorization of the same code which
 was done by the authors of traits.},
  acceptnum = {28},
  accepttotal = {291},
  annote = {internationalconference topconference},
  cvs = {ConAnASE05Traits},
  keywords = {scg-pub snf05 recast06 stefPub moose arevalo jb06 listic kzRemodularisation kzTrait},
  medium = {2},
  month = nov,
  rate = {9\%}}

@inproceedings{Lien06a,
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {Capturing How Objects Flow At Runtime},
  booktitle = {Proceedings International Workshop on Program Comprehension through Dynamic Analysis (PCODA'06)},
  pages = {39--43},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien06aCapturingHowObjectsFlowPCODA06.pdf http://www.lore.ua.ac.be/Events/PCODA2006/pcoda2006proceedings.pdf},
  abstract = {Most of today's dynamic analysis approaches are
 based on method traces. However, in the case of
 object-orientation understanding program execution
 by analyzing method traces is complicated because
 the behavior of a program depends on the sharing and
 the transfer of object references (aliasing). We
 argue that trace-based dynamic analysis is at a too
 low level of abstraction for object-oriented
 systems. We propose a new approach that captures the
 life cycle of objects by explicitly taking into
 account object aliasing and how aliases propagate
 during the execution of the program. In this paper,
 we present in detail our new meta-model and discuss
 future tracks opened by it.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi stefPub girba object-flow dynamic-analysis kzVisualization kzDynamicInformation},
  medium = {2}}

@inproceedings{Lien07c,
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
  title = {Object Flow Analysis --- Taking an Object-Centric View on Dynamic Analysis},
  booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL'07)},
  pages = {121--140},
  publisher = {ACM Digital Library},
  year = {2007},
  doi = {10.1145/1352678.1352686},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien07c-ObjectFlowAnalysis.pdf},
  abstract = {To extract abstract views of the behavior of an
 object-oriented system for reverse engineering, a
 body of research exists that analyzes a system's
 runtime execution. Those approaches primarily
 analyze the control flow by tracing method execution
 events. However, they do not capture information
 flows. We address this problem by proposing a novel
 dynamic analysis technique named Object Flow
 Analysis, which complements method execution tracing
 with an accurate analysis of the runtime flow of
 objects. To exemplify the usefulness of our analysis
 we present a visual approach that allows a system
 engineer to study classes and components in terms of
 how they exchange objects at runtime. We illustrate
 and validate our approach on two case studies.},
  address = {New York, NY, USA},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {scg-pub girba moose object-flow dynamic-analysis kzReference kzDynamicInformation},
  location = {Lugano, Switzerland},
  medium = {2}}

@article{Lien08c,
  author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
  title = {Taking an Object-Centric View on Dynamic Information with Object Flow Analysis},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {35},
  pages = {63--79},
  publisher = {Elsevier},
  year = {2009},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2008.05.006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Lien08cObjectFlowAnalysis.pdf},
  abstract = {A large body of research analyzes the runtime
 execution of a system to extract abstract behavioral
 views. Those approaches primarily analyze control
 flow by tracing method execution events or they
 analyze object graphs of heap snapshots. However,
 they do not capture how objects are passed through
 the system at runtime. We refer to the exchange of
 objects as the object flow, and we claim that object
 flow is necessary to analyze if we are to understand
 the runtime of an object-oriented application. We
 propose and detail Object Flow Analysis, a novel
 dynamic analysis technique that takes this new
 information into account. To evaluate its
 usefulness, we present a visual approach that allows
 a developer to study classes and components in terms
 of how they exchange objects at runtime. We
 illustrate our approach on three case studies.},
  annote = {internationaljournal},
  keywords = {scg-pub girba moose object-flow dynamic-analysis remoose kzReference kzVisualization},
  number = {1}}

@inproceedings{Loew07a,
  author = {Martin von L\"owis and Marcus Denker and Oscar Nierstrasz},
  title = {Context-Oriented Programming: Beyond Layers},
  booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
  pages = {143--156},
  publisher = {ACM Digital Library},
  year = {2007},
  doi = {10.1145/1352678.1352688},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Loew07a-ICDL07-PyContext.pdf},
  abstract = {While many software systems today have to be aware
 of the context in which they are executing, there is
 still little support for structuring a program with
 respect to context. A first step towards better
 context-orientation was the introduction of method
 layers. This paper proposes two additional language
 concepts, namely the implicit activation of method
 layers, and the introduction of dynamic variables},
  annote = {internationalconference},
  isbn = {978-1-60558-084-5},
  keywords = {scg07 scg-pub jb08 snf08 fromscgbib marcusdenker},
  medium = {2}}

@booklet{Lore17a,
  author = {Esteban Lorenzano and St\'ephane Ducasse and Johan Fabry and Norbert Hartl},
  title = {Voyage: Persisting Objects in Document Databases},
  pages = {46},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo Technology Collection},
  keywords = {skipdoi kzSmalltalk lse-pub kzPharo kzVulgarisation},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-voyage.pdf},
  hal-id = {hal-01612823}}

@inproceedings{Maff13a,
  author = {Cristiano Maffort and Marco T\'ulio Valente and Mariza Bigonha and Andre Hora and Nicolas Anquetil and Jonata Menezes},
  title = {Mining Architectural Patterns Using Association Rules},
  booktitle = {Proceedings of the 25th International Conference on Software Engineering and Knowledge Engineering (SEKE'13)},
  year = {2013},
  misc = {Acceptance rate: 72/259 = 28\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Maff13a-ArchitecturalPatterns-SEKE13.pdf},
  abstract = {Software systems usually follow many programming rules prescribed in an architectural model. However, developers frequently violate these rules, introducing architectural drifts in the source code. In this paper, we present a data mining approach for architecture conformance based on a combination of static and historical software analysis. For this purpose, the proposed approach relies on data mining techniques to extract structural and historical architectural patterns. In addition, we propose a methodology that uses the extracted patterns to detect both absences and divergences in source-code based architectures. We applied the proposed approach in an industrial strength system. As a result we detected 137 architectural violations, with an overall precision of 41.02%.},
  annote = {internationalconference},
  hal-id = {hal-00854851},
  inriareport = {2013},
  keywords = {lse-pub},
  tagnicolasa = {architecture}}

@inproceedings{Maff13b,
  author = {Cristiano Maffort and Marco T\'ulio Valente and Nicolas Anquetil and Andre Hora and Mariza Bigonha},
  title = {Heuristics for Discovering Architectural Violations},
  booktitle = {Proceedings of the 20th Working Conference on Reverse Engineering (WCRE'13)},
  year = {2013},
  misc = {Acceptance rate: 38/97 = 39\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Maff13b-HeuristicsArchitecturalViolations-WCRE13.pdf},
  abstract = {Software architecture conformance is a key software quality control activity that aims to reveal the progressive gap normally observed between concrete and planned software architectures. In this paper, we present ArchLint, a lightweight approach for architecture conformance based on a combination of static and historical source code analysis. For this purpose, ArchLint relies on four heuristics for detecting both absences and divergences in source code based architectures. We applied ArchLint in an industrial-strength system and as a result we detected 119 architectural violations, with an overall precision of 46.7\% and a recall of 96.2\%, for divergences. We also evaluated ArchLint with four open-source systems, used in an independent study on reflexion models. In this second study, ArchLint achieved precision results ranging from 57.1\% to 89.4\%.},
  annote = {internationalconference},
  hal-id = {hal-00854871},
  inriareport = {2013},
  keywords = {lse-pub},
  tagnicolasa = {architecture}}

@article{Maff16a,
  author = {Cristiano Maffort and Marco T\'ulio Valente and Ricardo Terra and Mariza Bigonha and Nicolas Anquetil and Andre Hora},
  title = {Mining Architectural Violations from Version History},
  journal = {Empirical Software Engineering},
  volume = {21},
  pages = {854--895},
  year = {2016},
  impactfactor = {Impact Factor (2013) 1.640},
  doi = {10.1007/s10664-014-9348-2},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Maff14a-ArchitecturalViolations-EMSE.pdf},
  annote = {internationaljournal},
  editor = {Springer},
  hal-id = {hal-01075642},
  issn = {1382-3256},
  keywords = {lse-pub},
  number = {3},
  numpages = {40},
  tagnicolasa = {architecture},
  month = {jan}}

@inproceedings{Manj02a,
  author = {Manjarr\'es, Angeles and Suny\'e, Gerson and Pollet, Damien and Pickin, Simon and J\'ez\'equel, Jean-Marc},
  title = {AI Analysis Patterns as UML Meta-model Constructs},
  booktitle = {International Conference on Software Engineering and Knowledge Engineering (SEKE)},
  pages = {237--238},
  year = {2002},
  pdf = {http://www.irisa.fr/triskell/publis/2002/Manjarres02a.pdf},
  annote = {internationalconference},
  editor = {ACM},
  month = {jul}}

@inproceedings{Manj02b,
  author = {Manjarr\'es, Angeles and Pickin, Simon and Suny\'e, Gerson and Pollet, Damien and J\'ez\'equel, Jean-Marc},
  title = {OO Analysis Patterns as UML Metalevel Collaborations},
  booktitle = {SGAI International Conference on Knowledge Based Systems and Applied Artificial Intelligence: Research and Development in Intelligent Systems XIX (ES2002)},
  publisher = {Springer Verlag},
  year = {2002},
  annote = {internationalconference},
  month = {dec},
  series = {BCS Conference Series}}

@inproceedings{Mar17a,
  author = {Matteo Marra and Elisa Gonzalez Boix and Steven Costiou and Micka\"el Kerboeuf and Alain Plantec and Guillermo Polito and St\'ephane Ducasse},
  title = {Debugging Cyber-Physical Systems with Pharo},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {8:1--8:10},
  publisher = {ACM},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01585349},
  doi = {10.1145/3139903.3139913},
  annote = {internationalworkshop},
  abstract = {Cyber-Physical Systems (CPS) integrate sensors and actua-tors to collect data and control entities in the physical world. Debugging CPS systems is hard due to the time-sensitive nature of a distributed applications combined with the lack of control on the surrounding physical environment. This makes bugs in CPS systems hard to reproduce and thus to fix. In this context, on-line debugging techniques are helpful because the debugger is connected to the device when an exception or crash occurs. This paper reports on our experiences on applying two different on-line debugging techniques for a CPS system: remote debugging using the Pharo remote debugger and our IDRA debugger. In contrast to traditional remote debug-ging, IDRA allows to on-line debug an application locally in another client machine by reproducing the runtime context where the bug manifested. Our qualitative evaluation shows that IDRA provides almost the same interaction capabilities than Pharo's remote debugger and is less intrusive when performing hot-modifications. Our benchmarks also show that IDRA is significantly faster than the Pharo remote debugger, although it increases the amount of data transferred over the network.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {8},
  numpages = {10},
  address = {New York, NY, USA},
  keywords = {Cyber-Physical Systems ; software tools ; debugging; lse-pub kzInfrastructure},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mar17a-IWST-DebuggingIoT.pdf},
  hal-id = {hal-01585349}}

@booklet{Mari17a,
  author = {E. Maringolo and N. Pratt and R. Withney},
  title = {Object-Relational Persistence with Glorp},
  pages = {70},
  publisher = {Square Bracket Associates},
  year = {2017},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo Technology Collection},
  keywords = {skipdoi kzSmalltalk lse-pub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-09-02-Glorp.pdf},
  hal-id = {hal-01612821}}

@inproceedings{Marr15a,
  author = {Marr, Stefan and Seaton, Chris and Ducasse, St\'ephane},
  title = {Zero-Overhead Metaprogramming: Reflection and Metaobject Protocols Fast and without Compromises},
  booktitle = {PLDI - Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  publisher = {ACM},
  year = {2015},
  doi = {10.1145/2737924.2737963},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15a-PLDI15-ZeroOverheadMetaprogramming.pdf},
  abstract = {Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques. For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.},
  numpages = {10},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15a-PLDI15-ZeroOverheadMetaprogramming.pdf},
  series = {PLDI '15},
  annote = {topconference},
  keywords = {lse-pub kzLanguageDesign kzClutter stefPub},
  hal-id = {hal-01141135},
  inria = {RMOD},
  keywords = {lse-pub kzLanguageDesign kzClutter stefPub},
  month = {jun}}

@inproceedings{Marr15b,
  author = {Marr, Stefan and Ducasse, St\'ephane},
  title = {Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters},
  booktitle = {OOPSLA'2015},
  publisher = {ACM},
  year = {2015},
  doi = {10.1145/2814270.2814275},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15b-Official-Oopsla15-TracingVSPartial.pdf},
  abstract = {Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs.
This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object- oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.},
  numpages = {10},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr15b-Official-Oopsla15-TracingVSPartial.pdf},
  series = {OOPSLA'15},
  annote = {topconference},
  keywords = {lse-pub kzLanguageDesign stefPub},
  hal-id = {hal-01205345},
  keywords = {lse-pub kzLanguageDesign stefPub},
  month = {jun}}

@article{Marr18a,
  author = {Marra, Matteo and Polito, Guillermo and Gonzalez Boix, Elisa},
  title = {{Out-Of-Place debugging: a debugging architecture to reduce debugging interference}},
  journal = {{The Art, Science, and Engineering of Programming}},
  volume = {3},
  publisher = {{aosa, Inc.}},
  year = {2018},
  url = {https://hal.inria.fr/hal-01952790},
  doi = {10.22152/programming-journal.org/2019/3/3},
  abstract = {Context Recent studies show that developers spend most of their programming time testing, verifying and debugging software. As applications become more and more complex, developers demand more advanced debugging support to ease the software development process. Inquiry Since the 70's many debugging solutions have been introduced. Amongst them, online debuggers provide good insight on the conditions that led to a bug, allowing inspection and interaction with the variables of the program. However, most of the online debugging solutions introduce debugging interference to the execution of the program, i.e. pauses, latency, and evaluation of code containing side-effects. Approach This paper investigates a novel debugging technique called out-of-place debugging. The goal is to minimize the debugging interference characteristic of online debugging while allowing online remote capabilities. An out-of-place debugger transfers the program execution and application state from the debugged application to the debugger application, each running in a different process. Knowledge On the one hand, out-of-place debugging allows developers to debug applications remotely, overcoming the need of physical access to the machine where the debugged application is running. On the other hand, debugging happens locally on the remote machine avoiding latency. That makes it suitable to be deployed on a distributed system and handle the debugging of several processes running in parallel. Grounding We implemented a concrete out-of-place debugger for the Pharo Smalltalk programming language. We show that our approach is practical by running several benchmarks, comparing our approach with a classic remote online debugger. We show that our prototype debugger outperforms a traditional remote debugger by 1000 times in several scenarios. Moreover, we show that the presence of our debugger does not impact the overall performance of an application. Importance This work combines remote debugging with the debugging experience of a local online debug-ger. Out-of-place debugging is the first online debugging technique that can minimize debugging interference while debugging a remote application. Yet, it still keeps the benefits of online debugging (e.g., step-by-step execution). This makes the technique suitable for modern applications which are increasingly parallel, distributed and reactive to streams of data from various sources like sensors, UI, network, etc.},
  number = {2},
  month = nov,
  keywords = {debugging tools ; online debugging ; remote debugging ; distributed systems; lse-pub; pharo},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr18a-Programming18-OutOfPlaceDebugging.pdf},
  hal-id = {hal-01952790}}

@inproceedings{Mart10a,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Visualizing Objects and Memory Usage},
  booktitle = {Smalltalks 2010},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart10a-Smalltalks2010-VisualizingUnusedObjects.pdf},
  abstract = {Most of the current garbage collector implementations work by reachability. This means they only take care of the objects that nobody else points to. As a consequence, there are objects which are not really used but are not garbage collected because they are still referenced. Such unused but reachable objects create memory leaks. This is a problem because applications use much more memory than what is actually needed. In addition, they may get slower and crash. It is important to understand which parts of the system are instantiated but also which are used or unused. There is a plethora of work on runtime information or class instantiation visualizations but none of them show whether instances are actually used. Such information is important to identify memory leaks.
In this paper, we present some visualizations that show used/unused objects in object-oriented applications. For this, we use Distribution Map which is a visualization showing spread and focus of properties across systems. We extend Distribution Maps to represent the way classes are used or not, since we distinguish between a class that just has instances from one that has used instances. To identify unused objects, we modified the Pharo Virtual Machine.},
  address = {Concepci\'on del Uruguay, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00531510},
  inriareport = {2010},
  keywords = {moose stefPub lse-pub marcusdenker pharo pharo-pub kzVisualization kzClutter}}

@inproceedings{Mart10b,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Experiments with a Fast Object Swapper},
  booktitle = {Smalltalks 2010},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart10b-Smalltalks2010-Swapper-ImageSegments.pdf},
  abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running. Graph exporting and swapping are two important object graph operations. Exporting refers to copying the graph to some other memory so that it can be loaded by another system. Swapping refers to moving the graph to a secondary memory (e.g., a hard disk) to temporary release part of the primary memory.
While exporting and swapping are achieved in different ways, each of them faces a common and central problem which is the speed of the approach in presence of large object graphs. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with extremely common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph. This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present most of the general problems of object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk. However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
  address = {Concepci\'on del Uruguay, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00531565},
  inriareport = {2010},
  keywords = {stefPub lse-pub marcusdenker pharo pharo-pub kzClutter}}

@inproceedings{Mart11a,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Efficient Proxies in {Smalltalk}},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'11)},
  year = {2011},
  doi = {10.1145/2166929.2166937},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart11a-IWST11-Ghost.pdf},
  abstract = {A proxy object is a surrogate or placeholder that controls access to another target object.	Proxy objects are a widely used solution for different scenarios such as remote method invocation, future objects, behavioral reflection, object databases, inter-languages communications and bindings, access control, lazy or parallel evaluation, security, among others. Most proxy implementations support proxies for regular objects but they are unable to create proxies for classes or methods. Proxies can be complex to install, have a significant overhead, be limited to certain type of classes, etc. Moreover, most proxy implementations are not stratified at all and there is no separation between proxies and handlers. In this paper, we present Ghost, a uniform, light-weight and stratified general purpose proxy model and its Smalltalk implementation.Ghost supports proxies for classes or methods. When a proxy takes the place of a class it intercepts both, messages received by the class and lookup of methods for messages received by instances. Similarly, if a proxy takes the place of a method, then the method execution is intercepted too.},
  address = {Edinburgh, Scotland},
  annote = {internationalworkshop},
  hal-id = {inria-00614720},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzLanguageDesign kzClutter}}

@inproceedings{Mart11b,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Problems and Challenges when Building a Manager for Unused Objects},
  booktitle = {Proceedings of Smalltalks 2011 International Workshop},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart11b-Smalltalks2011-UOM.pdf},
  abstract = {Large object-oriented applications may occupy hundreds of megabytes or even gigabytes of memory. During program execution, a large graph of objects is created and constantly changed.
Most object runtimes support some kind of automatic memory management based on garbage collectors (GC) whose idea is the automatic destruction of unreferenced objects. However, there are referenced objects which are not used for a long period of time or that are used just once. These are not garbage-collected because they are still reachable and might be used in the future. Due to these unused objects, applications use much more resources than they actually need.
In this paper we present the challenges and possible approaches towards an unused object manager for Pharo. The goal is to use less memory by swapping out the unused objects to secondary memory and only leaving in primary memory only those objects which are needed and used. When one of the unused objects is needed, it is brought back into primary memory.},
  address = {Bernal, Buenos Aires, Argentina},
  annote = {internationalworkshop},
  hal-id = {inria-00635793},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter}}

@article{Mart11c,
  author = {Martinez Peck, Mariano and Noury Bouraqadi and St\'ephane Ducasse and Luc Fabresse},
  title = {Object Swapping Challenges: an Evaluation of {ImageSegment}},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {38},
  pages = {1--15},
  publisher = {Elsevier},
  year = {2011},
  impactfactor = {Impact factor (2010) 0.541},
  doi = {10.1016/j.cl.2011.10.001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart11c-COMLAN-ObjectSwapping.pdf},
  abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running.
Graph exporting and swapping are two important object graph operations.
Exporting refers to copying the graph to some other memory so that it can be loaded by another system.
Swapping refers to moving the graph to a secondary memory (for example, a hard disk) to temporary release part of the primary memory (for example, RAM).
Exporting and swapping are achieved in different ways and the speed in presence of large object graphs is critical. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with	common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph.	This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present all general problems to our knowledge about object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk.
However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
  annote = {internationaljournal},
  hal-id = {hal-00646897},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter},
  month = {nov},
  number = {1}}

@phdthesis{Mart12d,
  author = {Martinez Peck, Mariano},
  title = {Application-Level Virtual Memory for Object-Oriented Systems},
  year = {2012},
  school = {Ecole des Mines de Douai - France \& Universit\'{e} Lille 1 - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2012-Martinez-Peck.pdf},
  abstract = {During the execution of object-oriented applications, several millions of objects are created, used and then collected if they are not referenced. Problems appear when objects are unused but cannot be garbage-collected because they are still referenced from other objects. This is an issue because those objects waste primary memory and applications use more primary memory than what they actually need. We claim that relying on operating systems (OS) virtual memory is not always enough since it is completely transparent to applications. The OS cannot take into account the domain and structure of applications. At the same time, applications have no easy way to control nor influence memory management.
In this dissertation, we present Marea, an efficient application-level virtual memory for object-oriented programming languages. Its main goal is to offer the programmer a novel solution to handle application- level memory. Developers can instruct our system to release primary memory by swapping out unused yet referenced objects to secondary memory.
Marea is designed to: 1) save as much memory as possible i.e., the memory used by its infrastructure is minimal compared to the amount of memory released by swapping out unused objects, 2) minimize the runtime overhead i.e., the swapping process is fast enough to avoid slowing down primary computations of applications, and 3) allow the programmer to control or influence the objects to swap.
Besides describing the model and the algorithms behind Marea, we also present our implementation in the Pharo programming language. Our approach has been qualitatively and quantitatively validated. Our experiments and benchmarks on real-world applications show that Marea can reduce the memory footprint between 25\% and 40\%.},
  annote = {PhD},
  hal-id = {tel-00764991},
  institution = {INRIA},
  keywords = {lse-pub pharo pharo-pub},
  month = oct,
  hal-url = {http://hal.inria.fr/tel-00764991}}

@article{Mart13a,
  author = {Martinez Peck, Mariano	and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
  title = {Marea: An Efficient Application-Level Object Graph Swapper},
  journal = {Journal of Object Technology},
  volume = {12},
  pages = {2:1-30},
  year = {2013},
  doi = {10.5381/jot.2013.12.1.a2},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart12c-JOT-Marea.pdf},
  abstract = {Abstract During the execution of object-oriented
 applications, several millions of objects are
 created, used and then collected if they are not
 referenced. Problems appear when objects are unused
 but cannot be garbage-collected because they are
 still referenced from other objects. This is an
 issue because those objects waste primary memory and
 applications use more primary memory than they
 actually need. We claim that relying on the
 operating system's (OS) virtual memory is not always
 enough since it cannot take into account the domain
 and structure of applications. At the same time,
 applications have no easy way to parametrize nor
 cooperate with memory management. In this paper, we
 present Marea, an efficient application-level object
 graph swapper for object-oriented programming
 languages. Its main goal is to offer the programmer
 a novel solution to handle application-level memory.
 Developers can instruct our system to release
 primary memory by swapping out unused yet referenced
 objects to secondary memory. Our approach has been
 qualitatively and quantitatively validated. Our
 experiments and benchmarks on real-world
 applications show that Marea can reduce the memory
 footprint between 23\% and 36\%.},
  annote = {internationaljournal},
  hal-id = {hal-00781129},
  keywords = {pharo-pub lse-pub kzClutter pharo},
  month = {jan},
  number = {1}}

@article{Mart14z,
  author = {Martinez Peck, Mariano	and Noury Bouraqadi and Luc Fabresse and Marcus Denker and Camille Teruel},
  title = {Ghost: A Uniform and General-Purpose Proxy Implementation},
  journal = {Journal of Object Technology},
  volume = {98},
  pages = {339-359},
  year = {2015},
  doi = {10.1016/j.scico.2014.05.015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mart14z-Ghost-Final.pdf},
  abstract = {A proxy object is a surrogate or placeholder that controls access to another target object. Proxy objects are a widely used solution for different scenarios such as remote method invocation, future objects, behavioral reflection, object databases, inter-languages communications and bindings, access control, lazy or parallel evaluation, security, among others. Most proxy implementations support proxies for regular objects but are unable to create proxies for objects with an important role in the runtime infrastructure such as classes or methods. Proxies can be complex to install, they can have a significant overhead, they can be limited to certain kind of classes, etc. Moreover, proxy implementations are often not stratified and they do not have a clear separation between proxies (the objects intercepting messages) and handlers (the objects handling interceptions). In this paper, we present Ghost: a uniform and general-purpose proxy implementation for the Pharo programming language. Ghost provides low memory consuming proxies for regular objects as well as for classes and methods.
When a proxy takes the place of a class, it intercepts both the messages received by the class and the lookup of methods for messages received by its instances. Similarly, if a proxy takes the place of a method, then the method execution is intercepted too.},
  annote = {internationaljournal},
  hal-id = {hal-01081236},
  issue = {3},
  keywords = {pharo-pub lse-pub kzDesign pharo}}

@inproceedings{Mend13,
  author = {David Mendez Acuna and Rubby Casallas and Anne Etien},
  title = {On the customization of model management systems for file-centric IDEs},
  booktitle = {Proceedings of the International Workshop on Domain Specific Modeling},
  year = {2013},
  annote = {internationalworkshop}}

@inproceedings{Mens05a,
  author = {Tom Mens and Michel Wermelinger and St\'ephane Ducasse and Serge Demeyer and Robert Hirschfeld and Mehdi Jazayeri},
  title = {Challenges in Software Evolution},
  booktitle = {Proceedings of the International Workshop on Principles of Software Evolution (IWPSE 2005)},
  pages = {123--131},
  publisher = {IEEE Computer Society},
  year = {2005},
  misc = {acceptance rate: 13/54 = 24\%},
  acceptnum = {13},
  accepttotal = {54},
  annote = {internationalworkshop},
  keywords = {stefPub scgPub kzPattern},
  rate = {24\%}}

@inproceedings{Milo16a,
  author = {Milojkovi\'c, Nevena and B\'era, Cl\'ement and Ghafari, Mohammad and Nierstrasz, Oscar},
  title = {{Inferring Types by Mining Class Usage Frequency from Inline Caches}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  doi = {10.1145/2991041.2991047},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Milo16a-IWST-DynamicTypeInference.pdf},
  address = {Prague, Czech Republic},
  hal-id = {hal-01357071},
  keywords = {lse-pub},
  month = aug,
  annote = {internationalworkshop}}

@article{Milo18a,
  author = {Milojkovi{\'c}, Nevena and B{\'e}ra, Cl{\'e}ment and Ghafari, Mohammad and Nierstrasz, Oscar},
  title = {{Mining inline cache data to order inferred types in dynamic languages}},
  journal = {{Science of Computer Programming}},
  volume = {161},
  pages = {105-121},
  publisher = {{Elsevier}},
  year = {2018},
  url = {https://hal.inria.fr/hal-01666541},
  doi = {10.1016/j.scico.2017.11.003},
  abstract = {The lack of static type information in dynamically-typed languages often poses obstacles for developers. Type inference algorithms can help, but inferring precise type information requires complex algorithms that are often slow. A simple approach that considers only the locally used interface of variables can identify potential classes for variables, but popular interfaces can generate a large number of false positives. We propose an approach called inline-cache type inference (ICTI) to augment the precision of fast and simple type inference algorithms. ICTI uses type information available in the inline caches during multiple software runs, to provide a ranked list of possible classes that most likely represent a variable's type. We evaluate ICTI through a proof-of-concept that we implement in Pharo Smalltalk. The analysis of the top-n+2 inferred types (where n is the number of recorded run-time types for a variable) for 5486 variables from four different software systems shows that ICTI produces promising results for about 75% of the variables. For more than 90% of variables, the correct run-time type is present among first six inferred types. Our ordering shows a twofold improvement when compared with the unordered basic approach, i.e., for a significant number of variables for which the basic approach offered ambiguous results, ICTI was able to promote the correct type to the top of the list.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Milo18a-SICP-InlineCache.pdf},
  month = sep,
  keywords = {inline caches ; type inference ; dynamically-typed languages; lse-pub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Milo18a-SICP-InlineCache.pdf},
  hal-id = {hal-01666541}}

@inproceedings{Minj05a,
  author = {Florian Minjat and Alexandre Bergel and Pierre Cointe and St\'ephane Ducasse},
  title = {Mise en symbiose des traits et des classboxes : Application \`a l'expression des collaborations},
  booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'05)},
  volume = {11},
  pages = {33--46},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Minj05a-TraitClassbox.pdf},
  abstract = {The trait model is complementary to class
 inheritance and allows collections of methods to be
 reused by several classes. The classbox model allows
 a collection of classes to be locally extended with
 variables and/or methods addition. This paper
 describes a symbiosis of these two models: classes
 can be locally extended by using a trait. It is
 illustrated by an efficient implementation of the
 collaboration model where a collaboration is
 represented by a classbox and a role by a trait.},
  address = {Bern, Switzerland},
  annote = {nationalconference},
  keywords = {traits classbox scg-pub skip-doi scg stefPub alexPub noWorkshop kzTrait kzClassbox}}

@inproceedings{Mira15a,
  author = {Miranda, Eliot and B{\'e}ra, Cl{\'e}ment},
  title = {A Partial Read Barrier for Efficient Support of Live Object-oriented Programming},
  booktitle = {International Symposium on Memory Management (ISMM '15)},
  pages = {93-104},
  year = {2015},
  url = {https://hal.inria.fr/hal-01152610},
  doi = {10.1145/2754169.2754186},
  annote = {topconference},
  address = {Portland, United States},
  keywords = {lse-pub},
  month = jun,
  pdf = {https://hal.inria.fr/hal-01152610/file/partialReadBarrier.pdf},
  hal-id = {hal-01152610}}

@inproceedings{Miss19a,
  author = {Misse-Chanabier, Pierre and Aranega, Vincent and Polito, Guillermo and Ducasse, St\'ephane},
  title = {Illicium A modular transpilation toolchain from Pharo to C},
  booktitle = {International workshop of Smalltalk Technologies},
  year = {2019},
  address = {K{\"o}ln, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {kzVM lse-pub},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02297860/file/final_submission.pdf},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Miss19a-IWST-Transpilation.pdf},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02297860},
  hal-id = {hal-02297860}}

@inproceedings{Mord09a,
  author = {Karine Mordal-Manet and Fran\c{c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
  title = {The Squale Model -- A Practice-based Industrial Quality Model},
  booktitle = {Proceedings of the 25th IEEE International Conference on Software Maintenance (ICSM'09)},
  pages = {94--103},
  year = {2009},
  misc = {(short paper) acceptance rate: 35(+29)/162: 21(40)\% for short papers},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord09a-ICSM2009-SqualeModel.pdf},
  abstract = {ISO 9126 promotes a three-level model of quality (factors, criteria, and metrics) which allows one to assess quality at the top level of factors and criteria. However, it is difficult to use this model as a tool to increase software quality. In the Squale model, we add practices as an intermediate level between metrics and criteria. Practices abstract away from raw information (metrics, tool reports, audits) and provide technical guidelines to respect. Moreover, practice marks are adjusted using formulae to suit company development habits or exigences: for example bad marks are stressed to point to places which need more attention. The Squale model has been developed and validated over the last couple of years in an industrial setting with Air France-KLM and PSA Peugeot-Citroen.},
  address = {Edmonton, Canada},
  annote = {internationalconference},
  hal = {inria-00637364},
  keywords = {moose kzMetric},
  rate = {40\%}}

@techreport{Mord09b,
  author = {Karine Mordal-Manet and Fran\c{c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
  title = {The Squale Model -- A \emph{Practice-}based Industrial Quality Model},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Mord09b-TechReport-Squale.pdf},
  abstract = {ISO 9126 promotes a three-level model of quality (factors, criteria, and metrics) which allows one to assess quality at the top level of factors and criteria. However, it is dif- ficult to use this model as a tool to increase software quality. In the Squale model, we propose the adjunction of practices as an intermediate level between metrics and criteria. Practices abstract from raw information at the source (metrics, tool reports, audits) to provide the developer with technical guidelines to respect. Moreover, practice marks can be adjusted using formulae to suit company development habits or exigences: for example bad marks can be stressed to point to places which need the most attention. Dashboards allow one to spot faulty practices and find the source elements responsible for the bad marks. The Squale model has been developed and validated over the last couple of years in an industrial setting with Air France-KML and PSA Peugeot-Citroen. Over 100 projects with a total of more than seven millions lines of code have been assessed and steered using Squale.},
  annote = {technicalReport stefPub},
  hal = {inria-00637363},
  institution = {INRIA Lille Nord Europe},
  keywords = {squale-pub lse-pub kzMetric}}

@inproceedings{Mord11a,
  author = {Karine Mordal-Manet and Jannik Laval and St\'ephane Ducasse and Nicolas Anquetil and Fran\c{c}oise Balmas and Fabrice Bellingard and Laurent Bouhier and Philippe Vaillergues and Thomas J. McCabe},
  title = {An empirical model for continuous and weighted metric aggregation},
  booktitle = {Proceedings of the 15th European Conference on Software Maintenance and Reengineering (CSMR'11)},
  pages = {141--150},
  year = {2011},
  misc = {acceptance rate: 29/82 = 35\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord11a-CSMR2011-Squale.pdf},
  abstract = {It is now understood that software metrics alone are not enough to characterize software quality. To cope with this problem, most of advanced and/or industrially validated quality models aggregate software metrics: for example, cyclomatic complexity is combined with test coverage to stress the fact that it is more important to cover complex methods than accessors. Yet, aggregating and weighting metrics to produce quality indexes is a difficult task. Indeed certain weighting approaches may lead to abnormal situations where a developer increasing the quality of a software component sees the overall quality degrade. Finally, mapping combinations of metric values to quality indexes may be a problem when using thresholds. In this paper, we present the problems we faced when designing the Squale quality model, then we present an empirical solution based on weighted aggregations and on continuous functions. The solution has been termed the Squale quality model and validated over 4 years with two large multinational companies: Air France-KLM and PSA Peugeot-Citroen.},
  address = {Oldenburg, Germany},
  annote = {internationalconference},
  hal = {inria-00637367},
  keywords = {moose lse-pub squale raweb2011 kzMetric},
  tagnicolasa = {metric}}

@article{Mord13a,
  author = {Karine Mordal{-}Manet and Nicolas Anquetil and Jannik Laval and Alexander Serebrenik and Bogdan Vasilescu and St\'ephane Ducasse},
  title = {Software quality metrics aggregation in industry},
  journal = {Journal of Software: Evolution and Process},
  volume = {25},
  pages = {1117--1135},
  year = {2013},
  impactfactor = {Impact Factor (2013) 0.442},
  doi = {10.1002/smr.1558},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord12b-Official-JSoft-MetricAggregation.pdf},
  aeresstatus = {aeres13},
  annote = {internationaljournal},
  number = {10},
  tagnicolasa = {metric}}

@incollection{Mord14a,
  author = {Karine Mordal and Jannik Laval and St\'ephane Ducasse},
  title = {Mod\`eles de mesure de la qualit\'e des logiciels},
  booktitle = {Evolution et R\'enovation des Syst\`emes Logiciels},
  publisher = {Herm\`es},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mord14a-Chapitrequalite.pdf},
  annote = {articlebook},
  ean13 = {9782746245549},
  inriareport = {2014},
  keywords = {moose lse-pub kzMetric}}

@inproceedings{Moug03a,
  author = {Philippe Mougin and St\'ephane Ducasse},
  title = {{OOPAL}: Integrating Array Programming in Object-Oriented Programming},
  booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
  pages = {65--77},
  year = {2003},
  misc = {acceptance rate: 26/142 = 18\%},
  doi = {10.1145/949305.949312},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Moug03aOOPALOOPSLA.pdf},
  abstract = {Array programming shines in its ability to express
 computations at a high-level of abstraction,
 allowing one to manipulate and query whole sets of
 data at once. This paper presents the OPA model that
 enhances object-oriented programming with array
 programming features. The goal of OPA is to
 determine a minimum set of modifications that must
 be made to the traditional object model in order to
 take advantage of the possibilities of array
 programming. It is based on a minimal extension of
 method invocation and the definition of a kernel of
 methods implementing fundamental array programming
 operations. The OPA model presents a generalization
 of traditional message passing in the sense that a
 message can be send to an entire set of objects. The
 model is validated in FS, a new scripting language.},
  acceptnum = {26},
  accepttotal = {142},
  annote = {internationalconference topconference},
  keywords = {snf04 scg-pub jb04 stefPub kzMessaging kzLanguageDesign},
  month = oct}

@misc{Mull05c,
  author = {Muller, Pierre-Alain and Fleurey, Franck and Vojtisek, Didier and Drey, Zo\'e and Pollet, Damien and Fondement, Fr\'ed\'eric and Studer, Philippe and J\'ez\'equel, Jean-Marc},
  title = {On Executable Meta-Languages applied to Model Transformations},
  year = {2005},
  address = {Montego Bay, Jamaica},
  annote = {internationalworkshop},
  howpublished = {Model Transformations In Practice Workshop},
  month = {oct}}

@phdthesis{Nadd17a,
  author = {Naddeo, Marco},
  title = {{A Modular Approach to Object Initialization for Pharo}},
  year = {2017},
  school = {{Dipartimento di Informatica, Universit{\`a} degli Studi di Torino ; Inria Lille Nord Europe - Laboratoire CRIStAL - Universit{\'e} de Lille}},
  url = {https://hal.inria.fr/tel-01651738},
  abstract = {Code modularity is important for code reuse. Language designers mainly focused on method code modularity. On the contrary, initialization code modularity has usually been neglected. The initialization code of many class-based object-oriented languages becomes cumbersome in different situations: for example, when some fields have multiple initialization options (e.g., a rectangle can be positioned by providing Cartesian or polar coordinates), have optional initialization (e.g., a rectangle can be positioned in the origin (0,0) if no other coordinates are provided), or have superclass initialization (e.g., a colored rectangle must redefine all the constructors of its rectangle superclass to add the notion of color). In such cases, the number of constructors increases exponentially in the size of the initialization options, since the initialization approach lacks modularity. We propose a novel approach to field initialization, inspired by the prototypical language Magda. This approach is based on easy-to-compose initialization modules, which result to be smaller compared to classical constructors. Moreover, their number grows linearly in the size of the initialization options. We apply such approach to Pharo, a dynamically-typed object-oriented programming language inspired by Smalltalk. The adaptation to Pharo of Magda's initialization approach implies solving some new challenges related to moving from a statically typed context to a dynamically typed one.},
  month = nov,
  keywords = {Object-oriented programming ; Dynamic typing ; Modularity ; Reuse ; Instance variables ; Initialization ; Constructor ; Variables d'instances ; R{\'e}utilisation ; Modularit{\'e} ; Programmation orient{\'e} objet ; Smalltalk-Pharo ; Typage dynamique ; Initialisation ; Constructeur ; lse-pub},
  type = {Theses},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2017-Naddeo.pdf},
  hal-id = {tel-01651738}}

@inproceedings{Nier02a,
  author = {Oscar Nierstrasz and Gabriela Ar{\'e}valo and St\'ephane Ducasse and Roel Wuyts and Andrew Black and Peter M{\"u}ller and Christian Zeidler and Thomas Genssler and Reinier van den Born},
  title = {A Component Model for Field Devices},
  booktitle = {Proceedings First International IFIP/ACM Working Conference on Component Deployment},
  pages = {200--209},
  publisher = {ACM},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier02aPecosModel.pdf},
  abstract = {Component-based software development is becoming
 mainstream for conventional applications. However,
 components can be difficult to deploy in embedded
 systems because of non-functional requirements.
 Pecos is a collaborative project between industrial
 and research partners that seeks to enable
 component-based technology for a class of embedded
 systems known as field devices. In this paper we
 introduce a component model for field devices that
 captures a range of non-functional properties and
 constraints. We report on the current status of
 Pecos, including the Pecos composition language,
 language mappings to {Java} and C\+\+, and industrial
 case studies.},
  address = {Berlin, Germany},
  annote = {internationalconference},
  keywords = {scg-pub skip-doi jb02 pecos stefPub arevalo kzComponent},
  month = jun}

@article{Nier04c,
  author = {Oscar Nierstrasz and St\'ephane Ducasse},
  title = {Moose--a Language-Independent Reengineering Environment},
  journal = {European Research Consortium for Informatics and Mathematics (ERCIM) News},
  volume = {58},
  pages = {24--25},
  year = {2004},
  url = {http://www.ercim.org/publication/Ercim\_News/enw58/nierstrasz.html},
  abstract = {Aging software systems are difficult and expensive
 to maintain. Moose is a language-independent
 environment that supports a wide range of tools to
 visualise, analyse and manipulate complex software
 systems.},
  annote = {notrefereed},
  keywords = {scg-pub skip-doi jb04 stefPub recast04 moose kzMoose kzTools},
  month = jul}

@inproceedings{Nier04d,
  author = {Oscar Nierstrasz and Marcus Denker},
  title = {Supporting Software Change in the Programming Language},
  booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
  year = {2004},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier04d-RDL04-Change.pdf},
  abstract = {In this paper we briefly review various kinds of
 software changes and the issues that arise from
 them. As a consequence, we propose research into
 programming languages with explicit support for
 representing first-class changes, and for
 manipulating and merging multiple viewpoints of
 evolving software systems.},
  annote = {internationalworkshop},
  keywords = {snf05 scg-pub skip-doi fromscgbib marcusdenker},
  month = oct}

@inproceedings{Nier05b,
  author = {Oscar Nierstrasz and Alexandre Bergel and Marcus Denker and St\'ephane Ducasse and Markus Gaelli and Roel Wuyts},
  title = {On the Revival of Dynamic Languages},
  booktitle = {Proceedings of Software Composition 2005},
  volume = {3628},
  pages = {1--13},
  publisher = {LNCS 3628},
  year = {2005},
  doi = {10.1007/11550679\_1},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05b-SC05-Revival.pdf},
  abstract = {The programming languages of today are stuck in a
 deep rut that has developed over the past 50 years.
 Although we are faced with new challenges posed by
 enormous advances in hardware and internet
 technology, we continue to struggle with
 old-fashioned languages based on rigid, static,
 closed-world file-based views of programming. We
 argue the need for a new class of dynamic languages
 that support a view of programming as constant
 evolution of living and open software models. Such
 languages would require features such as dynamic
 first-class namespaces, explicit meta-models,
 optional, pluggable type systems, and incremental
 compilation of running software systems.},
  annote = {invited},
  editor = {Thomas Gschwind and Uwe A{\ss}mann},
  isbn = {3-540-28748-5},
  keywords = {scg-pub kzLanguageDesign},
  note = {Invited paper}}

@inproceedings{Nier05c,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Tudor G\^irba},
  title = {The Story of {Moose}: an Agile Reengineering Environment},
  booktitle = {Proceedings of the European Software Engineering Conference},
  pages = {1--10},
  publisher = {ACM Press},
  year = {2005},
  doi = {10.1145/1095430.1081707},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05cStoryOfMoose.pdf},
  abstract = {Moose is a language-independent environment for
 reverse- and re-engineering complex software
 systems. Moose provides a set of services including
 a common meta-model, metrics evaluation and
 visualization, a model repository, and generic GUI
 support for querying, browsing and grouping. The
 development effort invested in Moose has paid off in
 precisely those research activities that benefit
 from applying a combination of complementary
 techniques. We describe how Moose has evolved over
 the years, we draw a number of lessons learned from
 our experience, and we outline the present and
 future of Moose.},
  address = {New York NY},
  annote = {invited},
  editor = {Michel Wermelinger and Harald Gall},
  isbn = {1-59593-014-0},
  keywords = {girba stefPub recast06 scg-pub moose kzMoose kzTools},
  note = {Invited paper},
  series = {ESEC/FSE'05}}

@inproceedings{Nier05d,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
  title = {Object-oriented Reengineering Patterns --- an Overview},
  booktitle = {Proceedings of Generative Programming and Component Engineering (GPCE 2005)},
  pages = {1--9},
  publisher = {LNCS 3676},
  year = {2005},
  doi = {10.1007/11561347\_1},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05dReengineeringPatterns.pdf},
  abstract = {Successful software systems must be prepared to
 evolve or they will die. Although object-oriented
 software systems are built to last, over time they
 degrade as much as any legacy software system. As a
 consequence, one must invest in reengineering
 efforts to keep further development costs down. Even
 though software systems and their business contexts
 may differ in countless ways, the techniques one
 uses to understand, analyze and transform these
 systems tend to be very similar. As a consequence,
 one may identify various reengineering patterns that
 capture best practice in reverse- and re-engineering
 object-oriented legacy systems. We present a brief
 outline of a large collection of these patterns that
 have been mined over several years of experience
 with object-oriented legacy systems, and we indicate
 how some of these patterns can be supported by
 appropriate tools.},
  annote = {invited},
  editor = {Robert Gl\"uck, Michael Lowry},
  isbn = {3-540-29138-5},
  keywords = {stefPub recast06 scg-pub jb06 kzPattern},
  note = {Invited paper}}

@techreport{Nier05e,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
  title = {Flattening {Traits}},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05eFlatteningTraitsTR.pdf},
  abstract = {Traits are fine-grained components that can be used
 to compose classes, while avoiding many of the
 problems of multiple inheritance and mixin-based
 approaches. Since most implementations of traits
 have focused on dynamically-typed languages, the
 question naturally arises, how can one best
 introduce traits to statically-typed languages, like
 {Java} and C#? In this paper we argue that the
 flattening property of traits should be used as a
 guiding principle for any attempt to add traits to
 statically-typed languages. This property
 essentially states that, semantically, traits can be
 compiled away. We demonstrate how this principle
 applies to FTJ, a conservative extension to
 Featherweight {Java}.},
  address = {Universit\"at Bern, Switzerland},
  institution = {Institut f\"ur Informatik},
  keywords = {scg-pub skip-doi scg-rotor traits jb06 snf05 jot stefPub kzTrait},
  month = apr,
  number = {IAM-05-005},
  type = {Technical Report}}

@article{Nier05f,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
  title = {Objektorientierte Re-Engineering-Muster: ein \"{U}berblick},
  journal = {ObjektSpektrum},
  volume = {2005},
  pages = {46--51},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05fOORM.pdf},
  abstract = {Erfolgreiche Softwaresysteme m\"ussen so konzipiert
 sein, dass sie sich weiterentwickeln k\"onnen ---
 ansonsten gehen sie ein. Obwohl objektorientierte
 Softwaresysteme auf eine lange Lebensda\"ur
 ausgerichtet sind, veralten sie \"uber die Jahre
 genauso wie jedes andere Legacy-Softwaresystem. Um
 die weiteren Entwicklungskosten niedrig zu halten,
 m\"ussen daher Investitionen im Bereich \
 Re-Engineering get\"atigt werden. Softwaresysteme
 und der Gesch\"aftskontext, in dem sie eingesetzt
 werden, unterscheiden sich in vielen Punkten ---
 dennoch \"ahneln sich Techniken, sie zu verstehen,
 zu analysieren und zu transformieren. Folglich
 lassen sich verschiedene Re-Engineering-Muster
 identifizieren, die bew\"ahrte Vorgehensweisen beim
 Reverse- und Re-Engineering objektorientierter
 Legacy-Systeme beinhalten. Dieser Artikel stellt
 einen kleinen Ausschnitt aus einer gr\"on Sammlung
 dieser Muster vor, die auf der mehrj\"ahrigen
 Erfahrung mit objektorientierten Legacy-Systemen
 basieren. Dar\"uber hinaus werden Hinweise gegeben,
 wie einige dieser Muster durch geeignete Werkzeuge
 unterst\"utzt werden k\"onnen.},
  annote = {invited},
  keywords = {stefPub recast06 scg-pub skip-doi kzPattern},
  note = {German translation of ``Object-oriented Reengineering Patterns --- an Overview'' (GPCE 05)},
  number = {6}}

@techreport{Nier05g,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Stefan Reichhart and Nathanael Sch\"arli},
  title = {Adding {Traits} to (Statically Typed) Languages},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier05gTraitsCSharp.pdf},
  abstract = {Traits offer a fine-grained mechanism for composing
 classes in object-oriented languages from reusable
 components, while avoiding the fragility problems
 introduced by multiple inheritance and mixins.
 Although traits were developed in the context of
 dynamically typed languages, they would also offer
 clear benefits for statically typed languages like
 Java and C\#. This report summarizes the issues
 raised when integrating traits into such languages.
 We examine traits in the context of the statically
 typed languages FeatherweightJava, C\# and C\+\+.},
  address = {Universit\"at Bern, Switzerland},
  institution = {Institut f\"ur Informatik},
  keywords = {scg-pub skip-doi scg-rotor traits stefPub kzTrait},
  month = dec,
  number = {IAM-05-006},
  type = {Technical Report}}

@article{Nier06a,
  author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
  title = {Flattening {Traits}},
  journal = {Journal of Object Technology},
  volume = {5},
  pages = {129--148},
  year = {2006},
  misc = {May-June},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier06aFlatteningTraits.pdf},
  abstract = {Traits are fine-grained components that can be used
 to compose classes, while avoiding many of the
 problems of multiple inheritance and mixin-based
 approaches. Since most implementations of traits
 have focused on dynamically-typed languages, the
 question naturally arises, how can one best
 introduce traits to statically-typed languages, like
 {Java} and C#? In this paper we argue that the
 flattening property of traits should be used as a
 guiding principle for any attempt to add traits to
 statically-typed languages. This property
 essentially states that, semantically, traits can be
 compiled away. We demonstrate how this principle
 applies to FTJ, a conservative extension to
 Featherweight {Java}.},
  annote = {internationaljournal},
  cached = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier06aFlatteningTraits.pdf},
  keywords = {scg-pub skip-doi scg-rotor traits jot stefPub kzTrait},
  medium = {2},
  month = may,
  number = {4}}

@inproceedings{Nier06b,
  author = {Oscar Nierstrasz and Marcus Denker and Tudor G{\^\i}rba and Adrian Lienhard},
  title = {Analyzing, Capturing and Taming Software Change},
  booktitle = {Proceedings of the Workshop on Revival of Dynamic Languages (co-located with ECOOP'06)},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier06b-RDL06-ACTSC.pdf},
  abstract = {Software systems need to continuously change to
 remain useful. Change appears in several forms and
 needs to be accommodated at different levels. We
 propose ChangeBoxes as a mechanism to encapsulate,
 manage, analyze and exploit changes to software
 systems. Our thesis is that only by making change
 explicit and manipulable can we enable the software
 developer to manage software change more effectively
 than is currently possible. Furthermore we argue
 that we need new insights into assessing the impact
 of changes and we need to provide new tools and
 techniques to manage them. We report on the results
 of some initial prototyping efforts, and we outline
 a series of research activities that we have started
 to explore the potential of ChangeBoxes.},
  annote = {internationalworkshop},
  keywords = {girba snf06 scg-pub skip-doi jb06 fb06 fromscgbib marcusdenker},
  medium = {2},
  month = jul}

@techreport{Nier08a,
  author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Kuhn and Adrian Lienhard and David R{\"o}thlisberger},
  title = {Self-aware, Evolving Eternal Systems},
  year = {2008},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Nier08a-TechReport-SelfAwareEternal.pdf},
  abstract = {Few real software systems are built completely from
 scratch nowadays. Instead, systems are built
 iteratively and incrementally, while integrating and
 interacting with components from many other systems.
 These systems also last longer than their developers
 might imagine --- they are, in effect, eternal.
 Nevertheless the platforms, tools and environments
 we use to develop software are still largely based
 on an outmoded model that presupposes that software
 systems are closed and will not significantly evolve
 after deployment. We claim that in order to enable
 effective and graceful evolution of eternal systems,
 we must make them self-aware. A self-aware eternal
 system supports evolution by: (i) providing
 explicit, first-class models of software artifacts,
 change and history at the level of the platform,
 (ii) continuously analysing static and dynamic
 evolution to track emergent properties, and (iii)
 closing the gap between the domain model and the
 developers' view of the evolving system. We outline
 our vision of self-aware eternal systems and
 identify the research challenges to realizing this
 vision.},
  annote = {report notrefereed},
  institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
  keywords = {scg-pub jb08 snf08 skip-doi girba roethlisberger fromscgbib marcusdenker},
  number = {IAM-08-001},
  type = {Technical Report}}

@incollection{Nier08b,
  author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Lienhard and David R\"othlisberger},
  title = {Change-Enabled Software Systems},
  booktitle = {Challenges for Software-Intensive Systems and New Computing Paradigms},
  volume = {5380},
  pages = {64-79},
  publisher = {Springer-Verlag},
  year = {2008},
  doi = {10.1007/978-3-540-89437-7\_3},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier08b-bookchapter-ChangeEnabledSoftware.pdf},
  abstract = {Few real software systems are built completely from
 scratch nowadays. Instead, systems are built
 iteratively and incrementally, while integrating and
 interacting with components from many other systems.
 Adaptation, reconfiguration and evolution are
 normal, ongoing processes throughout the lifecycle
 of a software system. Nevertheless the platforms,
 tools and environments we use to develop software
 are still largely based on an outmoded model that
 presupposes that software systems are closed and
 will not significantly evolve after deployment. We
 claim that in order to enable effective and graceful
 evolution of modern software systems, we must make
 these systems more amenable to change by (i)
 providing explicit, first-class models of software
 artifacts, change, and history at the level of the
 platform, (ii) continuously analysing static and
 dynamic evolution to track emergent properties, and
 (iii) closing the gap between the domain model and
 the developers' view of the evolving system. We
 outline our vision of dynamic, evolving software
 systems and identify the research challenges to
 realizing this vision.},
  editor = {Martin Wirsing and Jean-Pierre Ban\^atre and Matthias H\"olzl},
  isbn = {978-3-540-89436-0},
  keywords = {scg08 scg-pub snf09 jb09 hasler09 girba cop-lit roethlisberger marcusdenker fromscgbib},
  medium = {2},
  series = {LNCS}}

@incollection{Nier09a,
  author = {Oscar Nierstrasz and Marcus Denker and Lukas Renggli},
  title = {Model-Centric, Context-Aware Software Adaptation},
  booktitle = {Software Engineering for Self-Adaptive Systems},
  volume = {5525},
  pages = {128-145},
  publisher = {Springer-Verlag},
  year = {2009},
  doi = {10.1007/978-3-642-02161-9\_7},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier09a-bookchapter-ModelCentric.pdf},
  abstract = {Software must be constantly adapted to changing
 requirements. The time scale, abstraction level and
 granularity of adaptations may vary from short-term,
 fine-grained adaptation to long-term, coarse-grained
 evolution. Fine-grained, dynamic and
 context-dependent adaptations can be particularly
 difficult to realize in long-lived, large-scale
 software systems. We argue that, in order to
 effectively and efficiently deploy such changes,
 adaptive applications must be built on an
 infrastructure that is not just model-driven, but is
 both model-centric and context-aware. Specifically,
 this means that high-level, causally-connected
 models of the application and the software
 infrastructure itself should be available at
 run-time, and that changes may need to be scoped to
 the run-time execution context. We first review the
 dimensions of software adaptation and evolution, and
 then we show how model-centric design can address
 the adaptation needs of a variety of applications
 that span these dimensions. We demonstrate through
 concrete examples how model-centric and
 context-aware designs work at the level of
 application interface, programming language and
 runtime. We then propose a research agenda for a
 model-centric development environment that supports
 dynamic software adaptation and evolution.},
  editor = {Betty H.C. Cheng and Rogerio de Lemos and Holger Giese and Paola Inverardi and Jeff Magee},
  keywords = {scg09 scg-pub diesel helvetia reflectivity snf09 jb09 fromscgbib marcusdenker},
  medium = {2},
  series = {LNCS}}

@incollection{Nier13a,
  author = {Oscar Nierstrasz and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {Regular Expressions in Pharo},
  booktitle = {Deep Into Pharo},
  pages = 21,
  publisher = {Square Bracket Associates},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier13aRegEx.pdf},
  isbn = {978-3-9523341-6-4},
  keywords = {jb14 snf-none scg-pub scg13 skip-doi missing-abstract},
  medium = {2},
  month = sep,
  peerreview = {no}}

@incollection{Nier13b,
  author = {Oscar Nierstrasz and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {Versioning Your Code with Monticello},
  booktitle = {Deep Into Pharo},
  pages = 27,
  publisher = {Square Bracket Associates},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Nier13bMonticello.pdf},
  isbn = {978-3-9523341-6-4},
  keywords = {jb14 snf-none scg-pub scg13 skip-doi missing-abstract},
  medium = {2},
  month = sep,
  peerreview = {no}}

@article{Oliv08a,
  author = {de Oliveira, Tito Marcelo Almeida and de Miranda, Marcia Mazo Santos and Papa, Marcos Antonio and Figueiredo, Rejane and Santos, Rildo and Anquetil, Nicolas and Silva, Wander},
  title = {Perception on software maintenance: a case study with information technology managers},
  journal = {International Conference on Information Systems and Technology Management},
  volume = {5},
  year = {2008},
  annote = {internationalconference},
  number = {2008},
  tagnicolasa = {other analysis}}

@inproceedings{Ouma15a,
  author = {Hayatou Oumarou and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Kolyang Dina Taiwe},
  title = {Identifying the Exact Fixing Actions of Static Rule Violation},
  booktitle = {Proceedings of the 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER'15)},
  year = {2015},
  misc = {acceptance rate: 46/144 = 32\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Haya15a-Saner-FixingActionOfStaticRule.pdf},
  acceptnum = {46},
  accepttotal = {144},
  address = {Montreal, Canada},
  hal-id = {hal-01185795},
  aeresstatus = {aeres15},
  annote = {internationalconference},
  keywords = {moose lse-pub raweb2015 pharo},
  abstract = {We study good programming practices expressed in rules and detected by static analysis checkers such as PMD or FindBugs. To understand how violations to these rules are corrected and whether this can be automated, we need to identify in the source code where they appear and how they were fixed. This presents some similarities with research on understanding software bugs, their causes, their fixes, and how they could be avoided. The traditional method to identify how a bug or a rule violation were fixed consists in finding the commit that contains this fix and identifying what was changed in this commit. If the commit is small, all the lines changed are ascribed to the fixing of the rule violation or the bug. However, commits are not always atomic, and several fixes and even enhancements can be mixed in a single one (a large commit). In this case, it is impossible to detect which modifications contribute to which fix. In this paper, we are proposing a method that identifies precisely the modifications that are related to the correction of a rule violation. The same method could be applied to bug fixes, providing there is a test illustrating this bug. We validate our solution on a real world system and actual rules.},
  tagnicolasa = {other analysis},
  x-country = {CM}}

@inproceedings{Ouma16a,
  author = {Hayatou Oumarou and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Kolyang Dina Taiwe},
  title = {Identifying the Exact Bug Fixing Actions},
  booktitle = {2016 7th International Workshop on Empirical Software Engineering in Practice (IWESEP)},
  pages = {51-56},
  year = {2016},
  url = {doi.ieeecomputersociety.org/10.1109/IWESEP.2016.13},
  doi = {10.1109/IWESEP.2016.13},
  keywords = {Software;Computer bugs;Data mining;Reliability;Control systems;Conferences;Software engineering},
  isbn = {978-1-5090-1851-2},
  annote = {internationalworkshop},
  tagnicolasa = {other analysis},
  month = {mar}}

@incollection{Papo10a,
  author = {Papoulias, Nick},
  title = {High-Level Debugging Facilities and Interfaces: Design and Developement of a Debug-Oriented I.D.E.},
  booktitle = {Open Source Software: New Horizons},
  volume = {319},
  pages = {373-379},
  publisher = {Springer Berlin Heidelberg},
  year = {2010},
  url = {http://dx.doi.org/10.1007/978-3-642-13244-5\_34},
  doi = {10.1007/978-3-642-13244-5_34},
  editor = {Agerfalk, Par and Boldyreff, Cornelia and Gonzalez-Barahona, JesusM. and Madey, GregoryR. and Noll, John},
  isbn = {978-3-642-13243-8},
  series = {IFIP Advances in Information and Communication Technology}}

@inproceedings{Papo11a,
  author = {Papoulias, Nikolaos and Bouraqadi, Noury and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Towards Structural Decomposition of Reflection with Mirrors},
  booktitle = {{Proceedings of International Workshop on Smalltalk Technologies (IWST'11)}},
  year = {2011},
  url = {http://hal.inria.fr/inria-00629175/en/},
  abstract = {Mirrors are meta-level entities introduced to decouple reflection from the base-level system. Current mirror-based systems focus on functional decomposition of reflection. In this paper we advocate that mirrors should also address structural decomposition. Mirrors should not only be the entry points of reflective behavior but also be the storage entities of meta-information. This decomposition can help resolve issues in terms of resource constraints (e.g. embedded systems and robotics) or security. Indeed, structural decomposition en- ables discarding meta-information.},
  address = {Edingburgh, United Kingdom},
  annote = {internationalworkshop},
  hal-id = {inria-00629175},
  keywords = {pharo-pub lse-pub raweb2011 pharo kzReflection},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo11a-StructuralDecomposition.pdf}}

@phdthesis{Papo13a,
  author = {Papoulias, Nikolaos},
  title = {{Le D{\'e}bogage {\`a} Distance et la R{\'e}flexion dans les Dispositifs {\`a} Ressources Limit{\'e}es}},
  year = {2013},
  school = {Universit{\'e} des Sciences et Technologie de Lille - Lille I},
  url = {http://tel.archives-ouvertes.fr/tel-00932796},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2013-Papoulias.pdf},
  abstract = {{La construction de logiciels pour des appareils qui ne peuvent pas accueillir localement des outils de d{\'e}veloppement peut {\^e}tre difficile. Ces appareils soit ont une puissance de calcul trop limit{\'e}e pour ex{\'e}cuter un IDE (par exemple, smartphones), ou manquent d' interfaces d'entr{\'e}e / sortie appropri{\'e}es ({\'e}cran, clavier , souris) pour la programmation (par exemple, les robots mobiles) ou sont tout simplement inaccessibles pour des d{\'e}veloppements locaux (par exemple cloud - serveurs). Dans ces situations, les d{\'e}veloppeurs ont besoin d'une infrastructure appropri{\'e}e pour d{\'e}velopper et d{\'e}boguer des applications distantes. Des solutions de d{\'e}bogage {\`a} distance sont parfois d{\'e}licates {\`a} utiliser en raison de leur nature distribu{\'e}e. Les {\'e}tudes empiriques nous montrent que, en moyenne 10,5 minutes par heure de codage (plus de cinq semaines de travail de 40 heures par an) sont pass{\'e}es pour le re-d{\'e}ploiement d'applications pour corriger les bugs ou am{\'e}liorer leur fonctionnalit{\'e} [ZeroTurnAround 2011]. En plus, les solutions courantes manquent des am{\'e}nagements qui seraient autrement disponibles dans un contexte local, car c'est difficile de les reproduire {\`a} distance (par exemple d{\'e}bogage objet-centr{\'e} [Ressia 2012b]). Cet {\'e}tat influe sur la quantit{\'e} d' exp{\'e}rimentation au cours d'une session de d{\'e}bogage {\`a} distance - par rapport {\`a} un contexte local. Dans cette th{\`e}se, afin de surmonter ces probl{\`e}mes, nous identifions d'abord quatre propri{\'e}t{\'e}s d{\'e}sirables qu'une solution id{\'e}ale pour le d{\'e}bogage {\`a} distance doit pr{\'e}senter : l'interactivit{\'e}, l'instrumentation, la distribution et la s{\'e}curit{\'e}. L'interactivit{\'e} est la capacit{\'e} d'une solution de d{\'e}bogage {\`a} distance de mise {\`a} jour incr{\'e}mentale de toutes les parties d'une application sans perdre le contexte de d'ex{\'e}cution (sans arr{\^e}ter l'application). L'instrumentation est l'aptitude d'une solution de modifier la s{\'e}mantique d'un processus en cours en vue d'aider le d{\'e}bogage. La distribution est la capacit{\'e} d'une solution de d{\'e}bogage {\`a} adapter son cadre alors que le d{\'e}bogage d'une cible {\`a} distance. Enfin la s{\'e}curit{\'e} fait r{\'e}f{\'e}rence {\`a} la disponibilit{\'e} de conditions pr{\'e}alables pour l'authentification et la restriction d'acc{\`e}s. Compte tenu de ces propri{\'e}t{\'e}s, nous proposons Mercury, un mod{\`e}le de d{\'e}bogage {\`a} distance et une architecture pour des langues r{\'e}flexifs {\`a} objets. Mercury ouvre (1) l'interactivit{\'e} gr{\^a}ce {\`a} un m{\'e}ta-niveau {\`a} distance miroir bas{\'e} sur un lien de causalit{\'e} avec sa cible, (2) l'instrumentation {\`a} travers une intercession r{\'e}flective bas{\'e}e sur la r{\'e}ification de l'environnement d'ex{\'e}cution sous-jacent, (3) la distribution gr{\^a}ce {\`a} un middleware adaptable et (4) la s{\'e}curit{\'e} par la d{\'e}composition et l'authentification de l'acc{\`e}s aux aspects r{\'e}flexifs. Nous validons notre proposition {\`a} travers un prototype dans le langage de programmation Pharo {\`a} l'aide d'un cadre exp{\'e}rimental diversifi{\'e} de multiples dispositifs contraints. Nous illustrons des techniques de d{\'e}bogage {\`a} distance support{\'e}es par les propri{\'e}t{\'e}s de Mercury, tels que le d{\'e}bogage agile distant et l'instrumentation objet {\`a} distance et montrons comment ils peuvent r{\'e}soudre dans la pratique, les probl{\`e}mes que nous avons identifi{\'e}s.}},
  affiliation = {RMOD - INRIA Lille - Nord Europe , Unit{\'e} de Recherche Informatique et Automatique - URIA},
  hal-id = {tel-00932796},
  keywords = {D{\'e}bogage {\`a} distance; Reflexion; Miroirs; Interactivit{\'e}; Instrumentation; Distribution; S{\'e}curit{\'e}; D{\'e}veloppement Agile},
  language = {Anglais},
  month = dec,
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2013-Papoulias.pdf}}

@inproceedings{Papo15a,
  author = {Papoulias, Nick and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Reifying the Reflectogram},
  booktitle = {{30th ACM/SIGAPP Symposium On Applied Computing}},
  year = {2015},
  doi = {10.1145/2695664.2695883},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo15a-ACM-SAC-Reflectogram.pdf},
  address = {Salamanca, Spain},
  hal-id = {hal-01098596},
  annote = {internationalconference},
  keywords = {Reflectogram ; Explicit Control ; Reflection ; Intercession kzReflection StefPub},
  month = {apr},
  abstract = {Reflective facilities in OO languages are used both for implementing language extensions (such as AOP frameworks) and for support- ing new programming tools and methodologies (such as object- centric debugging and message-based profiling). Yet controlling the run-time behavior of these reflective facilities introduces several challenges, such as computational overhead, the possibility of meta- recursion and an unclean separation of concerns between base and meta-level. In this paper we present five dimensions of meta-level control from related literature that try to remedy these problems. These dimensions are namely: temporal and spatial control, place- ment control, level control and identity control. We argue that the reification of the descriptive notion of the reflectogram, can unify the control of meta-level execution in all these five dimensions. We present a model for the reification of the reflectogram and validate our approach through a prototype implementation in the Pharo pro- gramming environment. Finally we detail a case-study on run-time tracing illustrating our approach.}}

@article{Papo15b,
  author = {Papoulias, Nick and Bouraqadi, N. and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Mercury: Properties and Design of a Remote Debugging Solution using Reflection},
  journal = {Journal of Object Technology},
  year = {2015},
  url = {https://hal.inria.fr/hal-01185730},
  hal-id = {hal-01185730},
  annote = {internationaljournal},
  abstract = {Remote debugging facilities are a technical necessity for devices that lack appropriate input/output interfaces (display, keyboard, mouse) for program- ming (e.g., smartphones, mobile robots) or are simply unreachable for local development (e.g., cloud-servers). Yet remote debugging solutions can prove awkward to use due to re-deployments. Empirical studies show us that on aver- age 10.5 minutes per coding hour (over five 40-hour work weeks per year) are spent for re-deploying applications (including re-deployments during debugging). Moreover current solutions lack facilities that would otherwise be available in a local setting because it is difficult to reproduce them remotely. Our work identifies three desirable properties that a remote debugging solution should exhibit, namely: run-time evolution, semantic instrumentation and adaptable distribution. Given these properties we propose and validate Mercury, a remote debugging model based on reflection. Mercury supports run-time evolution through a causally connected remote meta-level, semantic instrumentation through the reification of the underlying execution environment and adaptable distribution through a modular architecture of the debugging middleware.},
  keywords = {kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo15b-Mercury-JOT.pdf}}

@article{Papo16a,
  author = {Nick Papoulias and Marcus Denker and	St\'ephane Ducasse and Luc Fabresse},
  title = {End-User Abstractions for Meta-Control: Reifying the Reflectogram},
  journal = {Science of Computer Programming},
  volume = {140},
  pages = {2--16},
  year = {2017},
  url = {https://hal.inria.fr/hal-01424787},
  doi = {10.1016/j.scico.2016.12.002},
  hal-id = {hal-01424787},
  annote = {internationaljournal},
  abstract = {Reflective facilities in OO languages are used both for implementing language extensions (such as AOP frameworks) and for supporting new programming tools and methodologies (such as object-centric debugging and message-based profiling). Yet controlling the runtime behavior of these reflective facilities introduces several challenges, such as computational overhead, the possibility of meta-recursion and an unclean separation of concerns between base and meta-level. In this paper we present five dimensions of meta-level control from related literature that try to remedy these problems. These dimensions are namely: temporal and spatial control, placement control, level control and identity control. We then discuss how these dimensions interact with language semantics in class-based OO languages in terms of: scoping, inheritance and first-class entities. We argue that the reification of the descriptive notion of reflectogram can unify the control of meta-level execution in all these five dimensions while expressing properly the underlying language semantics. We present an extended model for the reification of the reflectogram based on our additional analysis and validate our approach through a new prototype implementation that relies on byte-code instrumentation. Finally, we illustrate our approach through a case study on runtime tracing.},
  keywords = {stefpub lse-pub marcusdenker reflection},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Papo16a-reflectogram-scp.pdf}}

@inproceedings{Pass14a,
  author = {Passerini, Nicol\'{a}s and Tesone, Pablo and Ducasse, St\'ephane},
  title = {An extensible constraint-based type inference algorithm for object-oriented dynamic languages supporting blocks and generic types},
  booktitle = {International Workshop on Smalltalk Technologies (IWST 14)},
  year = {2014},
  month = aug,
  annote = {internationalworkshop},
  keywords = {kzLanguageDesign kzPharo}}

@inproceedings{Patel13a,
  author = {Patel, Pankesh and Pathak, Animesh and Cassou, Damien and Issarny, Val{\'e}rie},
  title = {Enabling High-Level Application Development in the {Internet of Things}},
  booktitle = {{4th International Conference on Sensor Systems and Software}},
  year = {2013},
  url = {http://hal.inria.fr/hal-00809438},
  abstract = {{The sensor networking field is evolving into the
 Internet of Things\~(IoT), owing in large part to
 the increased availability of consumer sensing
 devices, including modern smart phones. However,
 application development in the IoT still remains
 challenging, since it involves dealing with several
 related issues, such as lack of proper
 identification of roles of various stakeholders, as
 well as lack of suitable (high-level) abstractions
 to address the large scale and heterogeneity in IoT
 systems. Although the software engineering community
 has proposed several approaches to address the above
 in the general case, existing approaches for IoT
 application development only cover limited subsets
 of above mentioned challenges. In this paper, we
 propose a multi-stage model-driven approach for IoT
 application development based on a precise
 definition of the role to be played by each
 stakeholder involved in the process -- domain
 expert, application designer, application developer,
 device developer, and network manager. The
 abstractions provided to each stakeholder are
 further customized using the inputs provided in the
 earlier stages by other stakeholders. We have also
 implemented code-generation and task-mapping
 techniques to support our approach. Our initial
 evaluation based on two realistic scenarios shows
 that the use of our techniques/framework succeeds in
 improving productivity in the IoT application
 development process.}},
  address = {Lucca, Italie},
  affiliation = {ARLES - INRIA Rocquencourt , RMOD - INRIA Lille - Nord Europe},
  audience = {internationale},
  annote = {internationalconference},
  hal-id = {hal-00809438},
  keywords = {Internet of Things, Sensor networks, High-level programming, Application development},
  language = {Anglais},
  month = apr,
  pdf = {http://hal.inria.fr/hal-00809438/PDF/main.pdf}}

@mastersthesis{Peirs08a,
  author = {Romain Peirs},
  title = {Enhanced Dependency Structure Matrix},
  year = {2008},
  school = {Enseita},
  abstract = {Dependency Structure Matrix (DSM) is an approach taken from
 process optimization and it exists a variety of algorithms
 to help organizing the matrix in a form that reflects the
 architecture and highlights patterns and problematic
 dependencies. However, the existing DSM implementations have
 a lack of information in their visualization. That is why, we
 enhanced DSM by adding written and colored information in the
 visualization to improve the architecture understanding of a
 software system and the support of its remodularization. This
 visualization has been implemented on top of Moose which is a
 collaborative research platform for Software Analysis and
 Information Visualization. This report presents my
 internship done at the research centre INRIA Lille - Nord
 Europe with the RMoD Team led by S. Ducasse.},
  annote = {master cook}}

@incollection{Pena13a,
  author = {Vanessa Pe{\~n}a Araya and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {Agile Visualization with {Roassal}},
  booktitle = {Deep Into Pharo},
  pages = {209--239},
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@incollection{Pena13b,
  author = {Vanessa Pe\~na Araya and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {Scripting Visualizations with Mondrian},
  booktitle = {Deep Into Pharo},
  pages = 20,
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@inproceedings{Pers12a,
  author = {Perscheid, Michael and Cassou, Damien and Hirschfeld, Robert},
  title = {Test Quality Feedback: Improving Effectivity and Efficiency of Unit Testing},
  booktitle = {C5'12: Proceedings of the 10th International Conference on Creating, Connecting and Collaborating through Computing},
  publisher = {IEEE},
  year = {2012},
  abstract = {Writing unit tests for a software system enhances
 the confidence that a system works as expected.
 Since time pressure often prevents a complete
 testing of all application details developers need
 to know which new tests the system requires.
 Developers also need to know which existing tests
 take the most time and slow down the whole
 development process. Missing feedback about less
 tested functionality and reasons for long running
 test cases make it, however, harder to create a test
 suite that covers all important parts of a software
 system in a minimum of time. As a result a software
 system may be inadequately tested and developers may
 test less frequently. provides test quality feedback
 to guide developers in identifying missing tests and
 correcting low-quality tests. developers with a tool
 that analyzes test suites with respect to their
 effectivity (e.g., missing tests) and efficiency
 (e.g., time and memory consumption). implement our
 approach, named PathMap, as an extended test runner
 within the Squeak Smalltalk IDE and demonstrate its
 benefits by improving the test quality of
 representative software systems.},
  address = {Playa Vista, CA, USA},
  annote = {internationalconference},
  month = jan}

@incollection{Plan13a,
  author = {Alain Plantec and Alexandre Bergel and Damien Cassou and St\'ephane Ducasse and Jannik Laval},
  title = {The Settings Framework},
  booktitle = {Deep Into Pharo},
  pages = 26,
  publisher = {Square Bracket Associates},
  year = {2013},
  isbn = {978-3-9523341-6-4},
  keywords = {Smalltalk, Pharo, Object-Oriented Programming, Live Programming},
  month = sep}

@inproceedings{Poli13a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury},
  title = {Virtual Smalltalk Images: Model and Applications},
  booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 21th International Smalltalk Conference - 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli13a-IWST13-ObjectSpacesVirtualization.pdf},
  abstract = {Reflective architectures are a powerful solution for code browsing, debugging or in-language process handling. However, these reflective architectures show some limitations in edge cases of self-modification and self-monitoring. Modifying the modifier process or monitoring the monitor process in a reflective system alters the system itself, leading to the impossibility to perform some of those tasks properly. In this paper we analyze the problems of reflective architectures in the context of image based object-oriented languages and solve them by providing a first-class representation of an image: a virtualized image.
We present Oz, our virtual image solution. In Oz, a virtual image is represented by an object space. Through an object space, an image can manipulate the internal structure and control the execution of other images. An Oz object space allows one to introspect and modify execution information such as processes, contexts, existing classes and objects. We show how Oz solves the edge cases of reflective architectures by adding a third participant, and thus, removing the self modification and self-observation constraints.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-00924932},
  keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection StefPub}}

@techreport{Poli14a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Bouraqadi, Noury and Fabresse, Luc},
  title = {{Extended results of Tornado: A Run-Fail-Grow approach for Dynamic Application Tayloring}},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Poli14-TechReport-Tornado-INRIA.pdf},
  abstract = {Producing a small deployment version of an application is a challenge because static abstractions such as packages cannot anticipate the use of their parts. As such, an application often occupies more memory than actually needed. To solve this problem we propose Tornado, a technique to dynamically tailor applications to only embed code (classes and methods) they use. Tornado uses a run-fail-grow approach to prepare an application for deployment. It launches minimal version of an application and installs a minimal set of statements that will start the user's application. This application is run and these statements are executed. When the application fails because there are classes or methods missing, the necessary code is installed. The application is executed until it reaches a stable point, allowing possibly human interaction for applications with UIs. Thus, Tornado creates minimal memory footprint versions of applications by tailoring the whole application's code, including run-time and third party libraries. We used Tornado to tailor two different applications. We succeeded to tailor a hello world application to occupy 1% of its original size. We also experimented with a Seaside web application tailoring in one case only the application's and framework's code and the whole application's code in the other case. In this latter example, we reached memory savings of about 97%. In this report we present an overview on Tornado, and we give details of the results we obtained.},
  annote = {technicalreport},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {kzReflection kzRemodularisation},
  x-pays = {FR}}

@inproceedings{Poli14b,
  author = {Polito, Guillermo and Bouraqadi, Noury and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Understanding Pharo\'s global state to move programs through time and space},
  booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 22th International Smalltalk Conference - 2014},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli14b-IWST-GlobalStateClassification.pdf},
  abstract = {Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application\'s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around code resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo\'s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found categories.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-01070964},
  keywords = {lse-pub globalstate stefpub kzEvolution kzPharo}}

@article{Poli14c,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury and van Ryseghem, Benjamin},
  title = {Bootstrapping Reflective Systems: The Case of Pharo},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli14c-BootstrappingASmalltalk-ScienceOfComputerProgramming.pdf},
  abstract = {Bootstrapping is a technique commonly known by its usage in language definition by the introduction of a compiler written in the same language it compiles.
	This process is important to understand and modify the definition of a given language using the same language, taking benefit of the abstractions and expression power it provides. A bootstrap, then, supports the evolution of a language. However, the infrastructure of reflective systems like Smalltalk includes, in addition to a compiler, an environment with several self-references. A reflective system bootstrap should consider all its infrastructural components.
	In this paper, we propose a definition of bootstrap for object-oriented reflective systems, we describe the architecture and components it should contain and we analyze the challenges it has to overcome. Finally, we present a reference bootstrap process for a reflective system and Hazelnut, its implementation for bootstrapping the Pharo Smalltalk-inspired system.},
  annote = {internationaljournal},
  hal-id = {hal-00903724},
  keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection stefpub}}

@inproceedings{Poli15a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury},
  title = {A Bootstrapping Infrastructure to Build and Extend Pharo-Like Languages},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15a-Onward-Bootstrapping.pdf},
  abstract = {Bootstrapping is well known in the context of compilers, where a bootstrapped compiler can compile its own source code. Bootstrapping is a beneficial engineering practice because it raises the level of abstraction of a program making it easier to understand, optimize, evolve, etc. Bootstrapping a reflective object-oriented language is however more challenging, as we need also to initialize the runtime of the language with its initial objects and classes besides writing its compiler.
In this paper, we present a novel bootstrapping infrastructure for Pharo-like languages that allows us to easily extend and modify such languages. Our bootstrapping process relies on a first-class runtime. A first-class runtime is a meta-object that represents a program's runtime and provides a MOP to easily load code into it and manipulate its objects. It decouples the virtual machine (VM) and language concerns by introducing a clear VM-language interface. Using this process, we show how we succeeded to bootstrap a Smalltalk-based language named Candle and then extend it with traits in less than 250 lines of high-level Smalltalk code. We also show how we can bootstrap with minimal effort two other languages (Pharo and MetaTalk) with similar execution semantics but different object models.},
  annote = {internationalconference},
  hal-id = {hal-01185812},
  keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15a-Onward-Bootstrapping.pdf}}

@inproceedings{Poli15b,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury and Mattone, Max},
  title = {Virtualization Support for Dynamic Core Library Update},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf},
  abstract = {Dynamically updating language runtime and core libraries such as collections and threading is challenging since the update mechanism uses such libraries at the same time that it modifies them. To tackle this challenge, we present Dy- namic Core Library Update (DCU) as an extension of Dy- namic Software Update (DSU) and our approach based on a virtualization architecture. Our solution supports the up- date of core libraries as any other normal library, avoiding the circular dependencies between the updater and the core libraries. Our benchmarks show that there is no evident per- formance overhead in comparison with a default execution. Finally, we show that our approach can be applied to real life scenario by introducing a critical update inside a web application with 20 simulated concurrent users.},
  annote = {internationalconference},
  hal-id = {hal-01185819},
  keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf}}

@phdthesis{Poli15d,
  author = {Guillermo Polito},
  title = {Virtualization Support for Application Runtime Specialization and Extension},
  year = {2015},
  school = {University Lille 1 - Sciences et Technologies - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2015-Polito.pdf},
  hal-id = {tel-01251173v1},
  abstract = {An application runtime is the set of software elements that represent an application during its execution. Application runtimes should be adaptable to different contexts. Advances in computing technology both in hardware and software indeed demand it. For example, on one hand we can think about extending a programming language to enhance the developers' productivity. On the other hand we can also think about transparently reducing the memory footprint of applications to make them fit in constrained resource scenarios e.g., low networks or limited memory availability. We propose Espell, a virtualization infrastructure for object-oriented high-level language runtimes. Espell provides a general purpose infrastructure to control and manipulate object-oriented runtimes in different situations. A first-class representation of an object-oriented runtime provides a high-level API for the manipulation of such runtime. A hypervisor uses this first-class object and manipulates it either directly or by executing arbitrary expressions into it. We show with our prototype that this infrastructure supports language bootstrapping and application runtime tailoring. Using bootstrapping we describe an object-oriented high-level language initialization in terms of itself. A bootstrapped language takes advantage of its own abstractions and is easier to extend. With application runtime tailoring we generate specialized applications by extracting the elements of a program that are used during execution. A tailored application encompasses only the classes and methods it needs and avoids the code bloat that appears from the usage of third-party libraries and frameworks.},
  month = {apr}}

@techreport{Poli17a,
  author = {St\'ephane Ducasse and Luc Fabresse and Guillermo Polito and Camille Teruel},
  title = {An Experiment with lexically-bound extension methods for a dynamic language},
  year = {2017},
  url = {https://hal.inria.fr/hal-01483756},
  annote = {techreport},
  abstract = {An extension method is a method declared in a package other than the package of its host class. Thanks to extension methods, developers can adapt classes they do not own to their needs: adding methods to core classes is a typical use case. This is particularly useful for adapting software and therefore increasing reusability. In most dynamically-typed languages, extension methods are globally visible. Because any developer can define extension methods for any class, naming conflicts occur: if two developers define an extension method with the same signature in the same class, only one extension method is visible and overwrites the other. Similarly, if two developers each define an extension method with the same name in a class hierarchy, one overrides the other. Existing solutions typically rely on a dedicated and slow method lookup algorithm to resolve conflicts at runtime. In this article, we present a model of scoped extension methods that minimizes accidental overrides and we present an implementation in Pharo that incurs little performance overhead. This implementation is based on lexical scope and hierarchy-first strategy for extension scoping.},
  month = mar,
  keywords = {modularity ; extension methods ; Pharo ; lse-pub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Poli17a-TR-ExtensionMethods.pdf},
  institution = {Inria Lille-Nord Europe},
  hal-id = {tel-01352817}}

@inproceedings{Poli17b,
  author = {Guillermo Polito and St\'ephane Ducasse and Luc Fabresse},
  title = {First-Class Undefined Classes for Pharo},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {9:1--9:8},
  publisher = {ACM},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01585305},
  doi = {10.1145/3139903.3139914},
  annote = {internationalworkshop},
  abstract = {Loading code inside a Pharo image is a daily concern for a Pharo developer. Nevertheless, several problems may arise at loading time that can prevent the code to load or even worse let the system in an inconsistent state. In this paper, we focus on the problem of loading code that references a class that does not exist in the system. We discuss the different flavors of this problem, the limitations of the existing Undeclared mechanism and the heterogeneity of Pharo tools to solve it. Then, we propose an unified solution for Pharo that reifies Undefined Classes. Our model of Undefined Classes is the result of an objective selection among different alternatives. We then validate our solution through two cases studies: migrating old code and loading code with circular dependencies. This paper also presents the integration of this solution into Pharo regarding the needed Meta-Object Protocol for Undefined Classes and the required modifications of existing tools.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {9},
  numpages = {8},
  address = {New York, NY, USA},
  inria = {RMOD},
  keywords = {Software engineering ; Programming languages ; Pharo ; Reflection ; Dynamic Languages ; Partial Code Loading; lse-pub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17b-IWST-UndefinedClasses.pdf},
  hal-id = {hal-01585305}}

@article{Poli17c,
  author = {Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Run-Fail-Grow: Creating Tailored Object-Oriented Runtimes},
  journal = {The Journal of Object Technology},
  volume = {16},
  publisher = {Chair of Software Engineering},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01609295},
  doi = {10.5381/jot.2017.16.3.a2},
  annote = {internationaljournal},
  abstract = {Producing a small deployment version of an application is a challenge because static abstractions such as packages cannot anticipate the use of their parts at runtime. Thus, an application often occupies more memory than actually needed. Tailoring is one of the main solutions to this problem i.e., extracting used code units such as classes and methods of an application. However, existing tailoring techniques are mostly based on static type annotations. These techniques cannot efficiently tailor applications in all their extent (e.g., runtime object graphs and metadata) nor be used in the context of dynamically-typed languages. We propose a run-fail-grow technique to tailor applications using their runtime execution. Run-fail-grow launches (a) a reference application containing the original application to tailor and (b) a nurtured application containing only a seed with a minimal set of code units the user wants to ensure in the final application. The nurtured application is executed, failing when it founds missing objects, classes or methods. On failure, the necessary elements are installed into the nurtured application from the reference one, and the execution resumes. The nurtured application is executed until it finishes, or until the developer explicitly finishes it, for example in the case of a web application. resulting in an object memory (i.e., a heap) with only objects, classes and methods required to execute the application. To validate our approach we implemented a tool based on Virtual Machine modifications, namely Tornado. Tornado succeeds to create very small memory footprint versions of applications e.g., a simple object-oriented heap of 11kb. We show how tailoring works on application code, base and third-party libraries even supporting human interaction with user G. interfaces. These experiments show memory savings ranging from 95\% to 99\%.},
  number = {3},
  keywords = {lse-pub kzLanguageDesign kzInfrastructure},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17c-JOT-Tornado.pdf},
  pdf-second = {http://www.jot.fm/issues/issue_2017_03/article2.pdf},
  hal-id = {hal-01609295}}

@article{Poli17d,
  author = {Guillermo Polito and St\'ephane Ducasse and Luc Fabresse and Camille Teruel},
  title = {Scoped Extension Methods in Dynamically-Typed Languages},
  journal = {The Art, Science, and Engineering of Programming},
  volume = {2},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01609310},
  doi = {10.22152/programming-journal.org/2018/2/1},
  annote = {internationaljournal},
  number = {1},
  month = aug,
  keywords = {lse-pub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17d-Programming-ScopedExtensions.pdf},
  hal-id = {hal-01609310}}

@inproceedings{Poli19a,
  author = {Polito, Guillermo and Tesone, Pablo and Miranda, Eliot and Simmons, David},
  title = {{GildaVM: a Non-Blocking I/O Architecture for the Cog VM}},
  booktitle = {{International Workshop on Smalltalk Technologies}},
  year = {2019},
  url = {https://hal.archives-ouvertes.fr/hal-02379275},
  address = {Cologne, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {lse-pub virtual machines ; multhreading ; non-blocking I/O ; foreign function calls},
  pdf = {https://hal.archives-ouvertes.fr/hal-02379275/file/main.pdf},
  hal-id = {hal-02379275}}

@misc{Poll02a,
  author = {Pollet, Damien and Vojtisek, Didier and J\'ez\'equel, Jean-Marc},
  title = {OCL as a Core UML Transformation Language},
  year = {2002},
  url = {http://ctp.di.fct.unl.pt/~ja/wituml02.htm},
  address = {Malaga},
  annote = {internationalworkshop},
  howpublished = {Workshop on Integration and Transformation of UML models (WITUML~2002)},
  month = jun}

@phdthesis{Poll05a,
  author = {Pollet, Damien},
  title = {Une architecture pour les transformations de mod\`eles et la restructuration de mod\`eles UML},
  year = {2005},
  school = {Universit\'e de Rennes 1},
  url = {http://www.irisa.fr/bibli/publi/theses/2005/pollet/pollet.html},
  annote = {phdthesis},
  month = jun}

@inproceedings{Poll07a,
  author = {Pollet, Damien and Ducasse, St\'ephane and Poyet, Lo\"{\i}c and Alloui, Ilham and C\^impan, Sorana and Verjus, Herv\'e},
  title = {Towards A Process-Oriented Software Architecture Reconstruction Taxonomy},
  booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR'07)},
  publisher = {IEEE Computer Society},
  year = {2007},
  misc = {Acceptance rate: 38/132=29\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poll07a-CSMRSARTaxonomy.pdf},
  abstract = {To maintain and understand large applications, it is
 crucial to know their architecture. The first
 problem is that unlike classes and packages,
 architecture is not explicitly represented in the
 code. The second problem is that successful
 applications evolve over time, so their architecture
 inevitably drifts. Reconstructing the architecture
 and checking whether it is still valid is therefore
 an important aid. While there is a plethora of
 approaches and techniques supporting architecture
 reconstruction, there is no comprehensive state of
 the art and it is often difficult to compare the
 approaches. This article presents a state of the art
 on software architecture reconstruction approaches.},
  acceptnum = {38},
  accepttotal = {132},
  annote = {internationalconference},
  editor = {Krikhaar, Ren\'e and Verhoef, Chris and Di Lucca, Giuseppe},
  hal-id = {hal-00849009},
  keywords = {recast kzArchi},
  location = {Amsterdam, the Netherlands},
  month = mar,
  note = {Best Paper Award},
  rate = {29\%}}

@inproceedings{Poll15a,
  author = {Damien Pollet and St\'ephane Ducasse},
  title = {A First Analysis of String APIs: the Case of Pharo},
  booktitle = {International Workshop on Smalltalk Technologies 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poll15a-IWST2015-StringsAPI.pdf},
  abstract = {Most programming languages natively provide an abstraction of character strings. However, it is difficult to assess the design or the API of a string library.
There is no comprehensive analysis of the needed operations and their different variations. There are no real guidelines about the different forces in presence and how they structure the design space of string manipulation. In this article, we harvest and structure a set of criteria to describe a string API. We propose an analysis of the Pharo~4 String library as a first experience on the topic.},
  annote = {internationalworkshop},
  keywords = {pharo lse-pub kzLanguageDesign},
  note = {Best Paper Award},
  hal-id = {hal-01244486}}

@article{Poll17a,
  author = {Damien Pollet and St\'ephane Ducasse},
  title = {A critical analysis of string APIs: the case of Pharo},
  journal = {Science of Computer Programming},
  year = {2017},
  doi = {10.1016/j.scico.2017.11.005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poll17a-SCICO-StringAPI.pdf},
  month = nov,
  issn = {0167-6423},
  hal-id = {hal-01651250},
  abstract = {Most programming languages, besides C, provide a native
 abstraction for character strings, but string APIs vary widely
 in size, expressiveness, and subjective convenience across
 languages. In Pharo, while at first glance the API of the
 String class seems rich, it often feels cumbersome in
 practice; to improve its usability, we faced the challenge of
 assessing its design. However, we found hardly any guideline
 about design forces and how they structure the design space,
 and no comprehensive analysis of the expected string
 operations and their different variations. In this article, we
 first analyse the Pharo 4 String library, then contrast it
 with its Haskell, Java, Python, Ruby, and Rust counterparts.
 We harvest criteria to describe a string API, and reflect on
 features and design tensions. This analysis should help
 language designers in understanding the design space of
 strings, and will serve as a basis for a future redesign of
 the string library in Pharo.},
  annote = {internationaljournal},
  keywords = {lse-pub kzPharo}}

@misc{PowerfullIdeas,
  author = {St\'ephane Ducasse and Alexandre Bergel and Fran\c{c}ois Schnell and Noury Bouraqadi and Serge Stinckwich},
  title = {Des idees puissantes dans la classe --- Utilisation de Squeak pour l'amelioration de l'apprentissage des mathematiques et des sciences (traduction de Powerful Ideas in the Classroom)},
  annote = {notrefereed},
  keywords = {squeak etoy book stefPub kzTeaching},
  note = {French translation of Powerful Ideas in the Classroom by B.J. Allen-Conn and Kim Rose}}

@incollection{Prad09a,
  author = {do Prado, H{\'e}rcules Antonio and Ferneda, Edilson and Anquetil, Nicolas and Teixeira, Elizabeth d'Arrochella},
  title = {Counselor, a Data Mining Based Time Estimation for Software Maintenance},
  booktitle = {Knowledge-Based and Intelligent Information and Engineering Systems},
  pages = {364--371},
  publisher = {Springer Berlin Heidelberg},
  year = {2009},
  annote = {internationalworkshop},
  tagnicolasa = {metric}}

@inproceedings{Raff17a,
  author = {Thibault Raffaillac and St\'ephane Huo and St\'ephane Ducasse},
  title = {Turning Function Calls Into Animations},
  booktitle = {Proceedings of the 9th ACM SIGCHI Symposium on Engineering Interactive Computing Systems},
  year = {2017},
  url = {https://hal.inria.fr/hal-01564116},
  annote = {internationalworkshop},
  abstract = {Animated transitions are an integral part of modern interaction frameworks. With the increasing number of animation scenarios, they have grown in range of animatable features. Yet not all transitions can be smoothed: programming systems limit the flexibility of frameworks for animating new things, and force them to expose low-level details to programmers. We present an ongoing work to provide system-wide animation of objects, by introducing a delay operator. This operator turns setter function calls into animations. It offers a coherent way to express animations across frameworks, and facilitates the animation of new properties.},
  address = {Lisbon, Portugal},
  month = jun,
  inria = {RMOD},
  keywords = {lse-pub kzOther},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Raff17a-SIGCHI-Animations.pdf},
  hal-id = {hal-01564116}}

@inproceedings{Rama02a,
  author = {M. Fenoll Ramal and Ricardo de Moura Meneses and Nicolas Anquetil},
  title = {A Disturbing Result on the Knowledge Used during Software Maintenance},
  booktitle = {9th Working Conference on Reverse Engineering (WCRE 2002)},
  pages = {277-},
  publisher = {IEEE Computer Society},
  year = {2002},
  doi = {10.1109/WCRE.2002.1173085},
  abstract = {As part of a long term project aiming at empowering software maintainers with knowledge based tools, we conducted an empirical study on the knowledge they use when doing maintenance. The study was intended as a preliminary work to get initial data on the type on knowledge used and the importance of each type of knowledge. For example, it is commonly assumed that application domain knowledge is important when doing maintenance. However nobody can tell exactly how much more important it is than Computer Science knowledge. We monitored six software engineers in two different organizations and analyzed the knowledge they used in their maintenance activity. In this paper we present and discuss some results and propose research directions from these. Our results include: the fact that software engineers rarely "search for" some new knowledge and rather work from what they already know; or the acknowledgment of a variation of the knowledge used depending on the organization one is working in. The most disturbing result is that, contrary to what is commonly assumed, the software engineers we studied seemed to make little use of application domain knowledge.},
  annote = {internationalconference},
  isbn = {0-7695-1799-4},
  tagnicolasa = {knowledge}}

@inproceedings{Ramo04a,
  author = {Cristiane S. Ramos and K{\'a}thia Mar\c{c}al de Oliveira and Nicolas Anquetil},
  title = {Legacy Software Evaluation Model for Outsourced Maintainer},
  booktitle = {8th European Conference on Software Maintenance and Reengineering (CSMR 2004)},
  pages = {48-57},
  publisher = {IEEE Computer Society},
  year = {2004},
  doi = {10.1109/CSMR.2004.1281405},
  abstract = {Outsourcing has become common practice in the software industry. Organizations routinely subcontract the maintenance of their software assets to specialized companies. A great challenge for these companies, is to rapidly evaluate the quality of the systems they will have to maintain so as to accurately estimate the amount of work they will require. To answer these concerns, we developed a framework of metrics to evaluate the complexity of a legacy software system and help an outsourcing maintainer define its contracts. This framework was defined using a well known approach in software quality, called "goal-question-metric". We present the goal-question-metric approach, its results, and the initial experimentation of the metrics on five real life systems in Cobol.},
  annote = {internationalconference},
  isbn = {0-7695-2107-X},
  tagnicolasa = {metric}}

@misc{Rapi98a,
  author = {Pascal Rapicault and Mireille Blay-Fornarino and St\'ephane Ducasse and Anne-Marie Dery},
  title = {Dynamic Type Inference to Support Object-Oriented Reengineering in Smalltalk},
  pages = {76--77},
  year = {1998},
  pdf = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf},
  abstract = {Type information is a crucial information to support
 object-oriented reengineering. In a dynamically
 typed language like Smalltalk standard static type
 inference is a complex and heavily computational
 task. In this paper, we report how we use message
 passing control and compiler extension to support
 dynamic inference type in Smalltalk.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi famoosstefPub kzEvolution},
  note = {Proceedings of the ECOOP '98 International Workshop Experiences in Object-Oriented Reengineering, abstract in Object-Oriented Technology (ECOOP '98 Workshop Reader forthcoming LNCS)}}

@inproceedings{Rati04a,
  author = {Daniel Ra{\c t}iu and St\'ephane Ducasse and Tudor G{\^\i}rba and Radu Marinescu},
  title = {Using History Information to Improve Design Flaws Detection},
  booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
  pages = {223--232},
  publisher = {IEEE Computer Society},
  year = {2004},
  misc = {acceptance rate: 33/62 = 52\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rati04aHistoryImproveFlawsDetection.pdf},
  abstract = {As systems evolve and their structure decays,
 maintainers need accurate and automatic
 identification of the design problems. Current
 approaches for automatic detection of design
 problems are not accurate enough because they
 analyze only a single version of a system and
 consequently they miss essential information as
 design problems appear and evolve over time. Our
 approach is to use the historical information of the
 suspected flawed structure to increase the accuracy
 of the automatic problem detection. Our means is to
 define measurements which summarize how persistent
 the problem was and how much maintenance effort was
 spent on the suspected structure. We apply our
 approach on a large scale case study and show how it
 improves the accuracy of the detection of God
 Classes and Data Classes, and additionally how it
 adds valuable semantical information about the
 evolution of flawed design structures.},
  acceptnum = {33},
  accepttotal = {62},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {recast04 scg-pub skip-doi stefPub jb04 moose girba ratiu evolution kzChecking kzMetric}}

@inproceedings{Raza09a,
  author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
  title = {Multiple Viewpoints Architecture Extraction},
  booktitle = {Proceedings of the 2009 Joint Working IEEE/IFIP Conference on Software Architecture \& European Conference on Software Architectures},
  pages = {329--332},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Raza09a-WASECSA-MultipleViewPoints.pdf},
  annote = {internationalconference},
  keywords = {moose lse-pub kzArchi}}

@inproceedings{Raza09b,
  author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
  title = {Software System Understanding via Architectural Views Extraction According to Multiple Viewpoints},
  booktitle = {8th International Workshop on System/Software Architectures},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Raza09b-iwssa-.pdf},
  annote = {internationalworkshop},
  keywords = {moose lse-pub kzArchi}}

@inproceedings{Reic07a,
  author = {Stefan Reichhart and Tudor G\^irba and St\'ephane Ducasse},
  title = {Rule-based Assessment of Test Quality},
  booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
  volume = {6/9},
  pages = {231--251},
  year = {2007},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reic07aTestQualityAssessment.pdf},
  abstract = {With the success of agile methodologies more and
 more projects develop large test suites to ensure
 that the system is behaving as expected. Not only do
 tests ensure correctness, but they also offer a live
 documentation for the code. However, as the system
 evolves, the tests need to evolve as well to keep up
 with the system, and as the test suite grows larger,
 the effort invested into maintaining tests is a
 significant activity. In this context, the quality
 of tests becomes an important issue, as developers
 need to assess and understand the tests they have to
 maintain. In this paper we present TestLint, an
 approach together with an experimental tool for
 qualifying tests. We define a set of criteria to
 determine test quality, and we evaluate our approach
 on a large sample of unit tests found in open-source
 projects.},
  annote = {internationalconference},
  issn = {1660-1769},
  keywords = {scg07 scg-pub jb08 snf07 skip-doi testlint test smell refactoring girba kzChecking kzTools},
  medium = {2},
  month = oct,
  note = {Special Issue. Proceedings of TOOLS Europe 2007}}

@inproceedings{Reng07a,
  author = {Lukas Renggli and St\'ephane Ducasse and Adrian Kuhn},
  title = {Magritte --- A Meta-Driven Approach to Empower Developers and End Users},
  booktitle = {Model Driven Engineering Languages and Systems},
  volume = {4735},
  pages = {106--120},
  publisher = {Springer},
  year = {2007},
  doi = {10.1007/978-3-540-75209-7\_8},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng07aMagritte.pdf},
  abstract = {Model-driven engineering is a powerful approach to
 build large-scale applications. However, an
 application's metamodel often remains static after
 the development phase and cannot be changed unless a
 new development effort occurs. Yet, end users often
 need to rapidly adapt their applications to new
 business needs. In many cases, the end users would
 know how to make the required adaptations, if only,
 the application would let them do so. In this paper
 we present how we built a runtime-dynamic
 meta-environment by integrating Magritte, a
 self-described metamodel, into Smalltalk's
 reflective language model. Our solution offers the
 best of both worlds: developers can develop their
 applications using the same tools they were used to,
 but at the same time they gain the power of
 meta-programming. We show in particular that our
 approach is adapted to support end user
 customization of applications: the adaptive model of
 Magritte enables to not only describe existing
 classes, but also lets end users build their own
 metamodels on the fly.},
  annote = {internationalconference},
  isbn = {978-3-540-75208-0},
  keywords = {kzMeta},
  medium = {2},
  month = sep,
  rate = {32\%},
  series = {LNCS}}

@inproceedings{Reng09c,
  author = {Lukas Renggli and Marcus Denker and Oscar Nierstrasz},
  title = {Language Boxes: Bending the Host Language with Modular Language Changes},
  booktitle = {Proceedings of the International Conference on Software Language Engineering (SLE'09)},
  volume = {5969},
  pages = {274--293},
  publisher = {Springer},
  year = {2009},
  doi = {10.1007/978-3-642-12107-4\_20},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng09c-SLE09-LanguageBoxes.pdf},
  abstract = {As domain-specific modeling begins to attract
 widespread acceptance, pressure is increasing for
 the development of new domain-specific languages.
 Unfortunately these DSLs typically conflict with the
 grammar of the host language, making it difficult to
 compose hybrid code except at the level of strings;
 few mechanisms (if any) exist to control the scope
 of usage of multiple DSLs; and, most seriously,
 existing host language tools are typically unaware
 of the DSL extensions, thus hampering the
 development process. Language boxes address these
 issues by offering a simple, modular mechanism to
 encapsulate (i) compositional changes to the host
 language, (ii) transformations to address various
 concerns such as compilation and highlighting, and
 (iii) scoping rules to control visibility of
 language extensions. We describe the design and
 implementation of language boxes, and show with the
 help of several examples how modular extensions can
 be introduced to a host language and environment.},
  annote = {internationalconference},
  inriareport = {2010},
  isbn = {978-3-642-12106-7},
  keywords = {scg09 scg-pub snf10 jb10 helvetia fromscgbib marcusdenker remoose lse-pub pharo pharo-pub},
  medium = {2},
  ratex = {29\%},
  series = {LNCS}}

@inproceedings{Reng10b,
  author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {Domain-Specific Program Checking},
  booktitle = {Proceedings of the 48th International Conference on Objects, Models, Components and Patterns (TOOLS'10)},
  volume = {6141},
  pages = {213--232},
  publisher = {Springer-Verlag},
  year = {2010},
  doi = {10.1007/978-3-642-13953-6\_12},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng10b-DomainSpecificProgramChecking.pdf},
  abstract = {Lint-like program checkers are popular tools that
 ensure code quality by verifying compliance with
 best practices for a particular programming
 language. The proliferation of internal
 domain-specific languages and models, however, poses
 new challenges for such tools. Traditional program
 checkers produce many false positives and fail to
 accurately check constraints, best practices, common
 errors, possible optimizations and portability
 issues particular to domain-specific languages. We
 advocate the use of dedicated rules to check
 domain-specific practices. We demonstrate the
 implementation of domain-specific rules, the
 automatic fixing of violations, and their
 application to two case-studies: (1) Seaside defines
 several internal DSLs through a creative use of the
 syntax of the host language; and (2) Magritte adds
 meta-descriptions to existing code by means of
 special methods. Our empirical validation
 demonstrates that domain-specific program checking
 significantly improves code quality when compared
 with general purpose program checking.},
  annote = {internationalconference},
  editor = {Jan Vitek},
  hal-id = {inria-00531509},
  inriareport = {2010},
  isnb = {978-3-642-13952-9},
  keywords = {scg-pub helvetia girba snf10 jb10 remoose lse-pub pharo pharo-pub kzTools kzChecking},
  ratex = {29\%},
  series = {LNCS}}

@inproceedings{Reng10c,
  author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
  title = {Practical Dynamic Grammars for Dynamic Languages},
  booktitle = {4th Workshop on Dynamic Languages and Applications (DYLA 2010)},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Reng10cDynamicGrammars.pdf},
  abstract = {Grammars for programming languages are traditionally
 specified statically. They are hard to compose and
 reuse due to ambiguities that inevitably arise.
 PetitParser combines ideas from scannerless parsing,
 parser combinators, parsing expression grammars and
 packrat parsers to model grammars and parsers as
 objects that can be reconfigured dynamically.
 Through examples and benchmarks we demonstrate that
 dynamic grammars are not only flexible but highly
 practical.},
  address = {Malaga, Spain},
  annote = {internationalworkshop},
  hal-id = {hal-00746253},
  inriareport = {2010},
  keywords = {scg-pub moose lse-pub pharo pharo-pub kzLanguageDesign},
  month = jun}

@inproceedings{Rich02a,
  author = {Tamar Richner and St\'ephane Ducasse},
  title = {Using Dynamic Information for the Iterative Recovery of Collaborations and Roles},
  booktitle = {Proceedings of 18th IEEE International Conference on Software Maintenance (ICSM'02)},
  pages = {34},
  publisher = {IEEE Computer Society},
  year = {2002},
  misc = {acceptance rate: 61/127 = 48\%},
  doi = {10.1109/ICSM.2002.1167745},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rich02aRolesExtractionICSM2002.pdf},
  abstract = {Modeling object-oriented applications using
 collaborations and roles is now well accepted.
 Collaboration-based or role-based designs decompose
 an application into tasks performed by a subset of
 the applications' classes. Collaborations prov ide a
 larger unit of understanding and reuse than classes,
 and are an important aid in the maintenance and
 evolution of the software. This kind of design
 information is lost, however, at the implementation
 level, making it hard to maintain and evolve an e
 xisting software application. The extraction of
 collaborations from code is therefore an important
 issue in design recovery. In this paper we propose
 an iterative approach which uses dynamic information
 to support the recovery and understanding of collabo
 rations. We describe a tool we have developed to
 support our approach and demonstrate its use on a
 case study.},
  acceptnum = {61},
  accepttotal = {127},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  keywords = {scg-pub stefPub kzDynamicInformation},
  month = oct}

@inproceedings{Rich98b,
  author = {Tamar Richner and St\'ephane Ducasse and Roel Wuyts},
  title = {Understanding Object-Oriented Programs with Declarative Event Analysis},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
  volume = {1543},
  publisher = {Springer-Verlag},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rich98bEvents.pdf},
  abstract = {Understanding how components in an application
 interact to ensure a certain functionality is an
 essential aspect of understanding a software
 application. To obtain this kind of information an
 analysis of the dynamic behavior of an application
 is more appropriate than a static analysis of the
 code. Understanding dynamic behavior through event
 analysis is a challenge because of the large amount
 of data gathered through program executions. In this
 paper, we show how we define declarative queries
 that allow us to filter the event data collected and
 to define new abstractions which aid in program
 understanding.},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {scg-pub skip-doi stefPub kzDynamicInformation},
  month = jul,
  series = {LNCS}}

@inproceedings{Rich99a,
  author = {Tamar Richner and St\'ephane Ducasse},
  title = {Recovering High-Level Views of Object-Oriented Applications from Static and Dynamic Information},
  booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
  pages = {13--22},
  publisher = {IEEE Computer Society Press},
  year = {1999},
  misc = {acceptance rate: 49/100 = 49\%},
  doi = {10.1109/ICSM.1999.792487},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rich99aRecoveringViews.pdf},
  abstract = {Recovering architectural documentation from code is
 crucial to maintaining and reengineering software
 systems. Reverse engineering and program
 understanding approaches are often limited by the
 fact that (1) they propose a fixed set of predefined
 views and (2) they consider either purely static or
 purely dynamic views of the application. In this
 paper we present an environment supporting the
 generation of tailorable views of object-oriented
 systems from both static and dynamic information.
 Our approach is based on the combination of
 user-defined queries which allow an engineer to
 create high-level abstractions and to produce views
 using these abstractions.},
  acceptnum = {49},
  accepttotal = {100},
  address = {Los Alamitos CA},
  annote = {internationalconference},
  editor = {Hongji Yang and Lee White},
  keywords = {scg-pub oorp stefPub kzDynamicInformation kzArchi},
  month = sep}

@inproceedings{Rieg04b,
  author = {Matthias Rieger and St\'ephane Ducasse and Michele Lanza},
  title = {Insights into System-Wide Code Duplication},
  booktitle = {Proceedings of 11th Working Conference on Reverse Engineering (WCRE'04)},
  pages = {100--109},
  publisher = {IEEE Computer Society Press},
  year = {2004},
  misc = {acceptance rate: 28/78 = 36\%},
  doi = {10.1109/WCRE.2004.25},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg04bWCRE2004ClonesVisualization.pdf},
  abstract = {Duplication of code is a common phenomenon in the
 development and maintenance of large software
 systems. The detection and removal of duplicated
 code has become a standard activity during the
 refactoring phases of a software life-cycle.
 However, code duplication identification ends to
 produce large amounts of data making the
 understanding of the duplication situation as a
 whole difficult. Reengineers can easily lose sight
 of the forest for the trees. There is a need to
 support a qualitative analysis of the duplicated
 code. In this paper we propose a number of
 visualzations of duplicated source elements that
 support reengineers in answering questions, e.g.,
 which parts of the sysem are connected by copied
 code or which parts of the sysem are copied the
 most.},
  acceptnum = {28},
  accepttotal = {78},
  annote = {internationalconference},
  cvs = {DuplocVizPaper},
  keywords = {scg-pub stefPub clones kzDuplication},
  location = {Delft, The Netherlands},
  month = nov}

@inproceedings{Rieg98a,
  author = {Matthias Rieger and St\'ephane Ducasse},
  title = {Visual Detection of Duplicated Code},
  booktitle = {Proceedings ECOOP Workshop on Experiences in Object-Oriented Re-Engineering},
  publisher = {Forschungszentrum Informatik Karlsruhe},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg98aEcoopWorkshop.pdf},
  abstract = {Code duplication is considered as bad practice that
 complicates the maintenance and evolution of
 software. Detecting duplicated code is a difficult
 task because of the large amount of data to be
 checked and the fact that a priori it is unknown
 which code part has been duplicated. In this paper,
 we present a tool called DUPLOC that supports code
 duplication detection in a visual and exploratory or
 an automatic way.},
  annote = {internationalworkshop},
  editor = {St\'ephane Ducasse and Joachim Weisbrod},
  keywords = {scg-pub skip-doi kzDuplication},
  number = {6/7/98},
  series = {FZI Report}}

@inproceedings{Rieg98b,
  author = {Matthias Rieger and St\'ephane Ducasse},
  title = {Visual Detection of Duplicated Code},
  booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
  volume = {1543},
  pages = {75--76},
  publisher = {Springer-Verlag},
  year = {1998},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg98aEcoopWorkshop.pdf},
  abstract = {Code duplication is considered as bad practice that
 complicates the maintenance and evolution of
 software. Detecting duplicated code is a difficult
 task because of the large amount of data to be
 checked and the fact that a priori it is unknown
 which code part has been duplicated. In this paper,
 we present a tool called DUPLOC that supports code
 duplication detection in a visual and exploratory or
 an automatic way.},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Jan Bosch},
  keywords = {scg-pub skip-doi stefPub kzVisualization kzDuplication},
  month = jul,
  series = {LNCS}}

@inproceedings{Rieg99a,
  author = {Matthias Rieger and St\'ephane Ducasse and Georges Golomingi},
  title = {Tool Support for Refactoring Duplicated OO Code},
  booktitle = {Object-Oriented Technology (ECOOP '99 Workshop Reader)},
  publisher = {Springer-Verlag},
  year = {1999},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rieg99aToolSuppRefacOOCode.pdf},
  abstract = {Code duplication is an important problem in
 application maintenance. Tools exist that support
 code duplication detection. However, few of them
 propose a solution for the problem, i.e.
 refactorings. We propose an approach that uses the
 information given by code duplication detection to
 guide the refactorings of OO applications.},
  annote = {internationalworkshop},
  keywords = {olit scg-pub skip-doi jb-none kzVisualization kzDuplication},
  number = {1743},
  series = {LNCS}}

@inproceedings{Rizu15a,
  author = {Rizun, Markiyan and Bach, Jean-Christophe and Ducasse, St\'ephane},
  title = {Code Transformation by Direct Transformation of ASTs},
  booktitle = {International Workshop on Smalltalk Technologies},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rizu15a-CodeTransformation.pdf},
  annote = {internationalworkshop},
  keywords = {kzInfrastructure kzTools kzEvolution},
  hal = {http://hal.inria.fr/inria-01319677},
  hal-id = {hal-01319677}}

@inproceedings{Rizu16a,
  author = {Markiyan Rizun and Gustavo Santos and St\'ephane Ducasse and Camille Teruel},
  title = {{Phorms: Pattern Combinator Library for Pharo}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  doi = {10.1145/2991041.2991057},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rizu16a-IWST16-Matcher.pdf},
  abstract = {Pattern matching is a common mechanism to provide analysis and transformation of data structures. Such an approach basically checks whether the containing elements of a data structure are constituents of a pattern, described by the developer. This paper is a step towards having seamless object-oriented pattern matching, which would be applicable to any object in Pharo. We present a pattern matching library, called \phorms, which enables users to compose patterns using the syntax of the Pharo programming language. In this library, patterns are objects and therefore can be inspected and debugged using existing Pharo tools. Our solution is extensible unlike \emph{The Rewrite Engine} -- Pharo's current pattern matching facilities. Moreover, by treating patterns as first class objects, our library provides more flexibility in the pattern matching process.},
  address = {Prague, Czech Republic},
  hal-id = {hal-01353883},
  keywords = {lse-pub kzInfrastructure kzPharo kzLanguageDesign},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Robb05b,
  author = {Romain Robbes and St\'ephane Ducasse and Michele Lanza},
  title = {Microprints: A Pixel-based Semantically Rich Visualization of Methods},
  booktitle = {Proceedings of 13th International Smalltalk Conference},
  pages = {131--157},
  year = {2005},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Robb05b-microprintsESUG.pdf},
  abstract = {Understanding classes and methods is a key activity
 in object-oriented programming, since classes
 represent the primary abstractions from which
 applications are built, while methods contain the
 actual program logic. The main problem of this task
 is to quickly grasp the purpose and inner structure
 of a class. To achieve this goal, one must be able
 to overview multiple methods at once. In this paper,
 we present microprints, pixel-based representations
 of methods enriched with semantical information. We
 present three specialized microprints each dealing
 with a specific aspect we want to understand of
 methods: (1) state access, (2) control flow, and (3)
 invocation relationship. We present the microprints
 in conjunction with the class blueprints of the CODE
 CRAWLER visualization tool [12] and also integrated
 into the default code browser of the Smalltalk
 VisualWorks development environment.},
  annote = {internationalconference},
  keywords = {scg-pub skip-doi stefPub kzVisualization},
  series = {ISC'05}}

@inproceedings{Robb10a,
  author = {Robbes, Romain and Pollet, Damien and Lanza, Michele},
  title = {Replaying IDE Interactions to Evaluate and Improve Change Prediction Approaches},
  booktitle = {Proceedings of the 7th IEEE Working Conference on Mining Software Repositories (MSR)},
  pages = {161--170},
  publisher = {IEEE Computer Society},
  year = {2010},
  misc = {Acceptance rate: 16/51 = 31\%},
  doi = {10.1109/MSR.2010.5463278},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Robb10a-MSR10-ChangePrediction.pdf},
  abstract = {Change prediction helps developers by recommending program entities that will have to be changed alongside the entities currently
		being changed. To evaluate their accuracy, current change prediction approaches use data from versioning systems such as CVS or SVN.
		These data sources provide a coarse-grained view of the development history that flattens the sequence of changes in a single commit.
		They are thus not a valid basis for evaluation in the case of development style prediction, where the order of the predictions has to
		match the order of the changes a developer makes.
		We propose a benchmark for the evaluation of change prediction approaches based on fine-grained change data recorded from IDE usage.
		Moreover, the change prediction approaches themselves can use the more accurate data to fine-tune their prediction. We present an
		evaluation procedure and use it on several change prediction approaches, both novel and from the literature, and report on the
		results.},
  aeres = {aeres12},
  aeresstatus = {ACT},
  annote = {internationalconference},
  editor = {Whitehead, Jim and Zimmermann, Thomas},
  hal = {inria-00531788},
  inriareport = {2010},
  isbn = {978-1-4244-6803-4},
  keywords = {lse-pub pharo pharo-pub},
  month = may,
  rate = {31\%}}

@inproceedings{Roch17a,
  author = {Henrique Rocha and St\'ephane Ducasse and Marcus Denker and Jason Lecerf},
  title = {Solidity Parsing Using SmaCC: Challenges and Irregularities},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {2:1--2:9},
  publisher = {ACM},
  year = {2017},
  doi = {10.1145/3139903.3139906},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roch17a-IWST-SolidityParser.pdf},
  annote = {internationalworkshop},
  abstract = {Solidity is a language used to implement smart contracts on a blockchain platform. Since its initial conception in 2014, Solidity has evolved into one of the major languages for the Ethereum platform as well as other blockchain technologies. Due to its popularity, there are many tools specifically designed to handle smart contracts written in Solidity. However , there is a lack of tools for Pharo to handle Solidity contracts. Therefore, we implemented a parser using SmaCC to serve as a base for further developing Solidity support in Pharo. In this paper we describe the parser creation, the irregularities we found in the Solidity grammar specification, and common practices on how to adapt the grammar to an LR type parser. Our experiences with parsing the Solidity language using SmaCC may help other developers trying to convert similar grammars.},
  hal-url = {https://hal.inria.fr/hal-01651858},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {2},
  numpages = {9},
  address = {New York, NY, USA},
  keywords = {Solidity Parser SmaCC Blockchain Ethereum lse-pub kzBlockchain},
  hal-id = {hal-01651858}}

@techreport{Roch17b,
  author = {Santiago Bragagnolo and Henrique Rocha and Marcus Denker and St\'ephane Ducasse},
  title = {SmartInspect: Smart Contract Inspection Technical Report},
  year = {2017},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Roch17b-TR-SmartInspect.pdf},
  annote = {techreport},
  abstract = {Smart contracts are embedded procedures stored with the data they act upon. Debugging deployed Smart Contracts is a difficult task since once deployed, the code cannot be reexecuted and inspecting a simple attribute is not easily possible because data is encoded. In this technical report, we present SmartInspect to address the lack of inspectability of a deployed contract. Our solution analyses the contract state by using decompilation techniques and a mirror-based architecture to represent the object responsible for interpreting the contract state. SmartInspect allows developers and also end-users of a contract to better visualize and understand the contract stored state without needing to redeploy, nor develop any ad-hoc code.},
  month = dec,
  keywords = {blockchain ; ethereum ; Pharo ; lse-pub ; solidity kzBlockchain},
  type = {Technical Report},
  institution = {Inria Lille-Nord Europe},
  hal-id = {tel-01671196}}

@inproceedings{Rocha18a,
  author = {Henrique Rocha and St\'ephane Ducasse},
  title = {Preliminary Steps Towards Modeling Blockchain Oriented Software},
  booktitle = {1st International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB)},
  pages = {1-6},
  year = {2018},
  doi = {10.1145/3194113.3194123},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Rocha18a-WETSEB-Modeling.pdf},
  annote = {internationalworkshop},
  abstract = {Even though blockchain is mostly popular for its cryptocurrency,
smart contracts have become a very prominent blockchain application.
Smart contracts are like classes that can be called by client
applications outside the blockchain. Therefore it is possible to develop
blockchain-oriented software (BOS) that implements part of
the business logic in the blockchain by using smart contracts. Currently,
there is no design standard to model BOS. Since modeling is
an important part of designing a software, developers may struggle
to plan their BOS. In this paper, we show three complementary
modeling approaches based on well-known software engineering
models and apply them to a BOS example. Our goal is to start the
discussion on specialized blockchain modeling notations.},
  hal-id = {inria-01831046},
  keywords = {Blockchain;Modeling;Smart Contracts;UML;BPMN;ER Model; lse-pub kzBlockchain},
  month = {may}}

@inproceedings{Roet07b,
  author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
  title = {Unanticipated Partial Behavioral Reflection},
  booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
  volume = {4406},
  pages = {47--65},
  publisher = {Springer},
  year = {2007},
  doi = {10.1007/978-3-540-71836-9\_3},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet07b-ISC06-UPBReflection.pdf},
  abstract = {Dynamic, unanticipated adaptation of running systems
 is of interest in a variety of situations, ranging
 from functional upgrades to on-the-fly debugging or
 monitoring of critical applications. In this paper
 we study a particular form of computational
 reflection, called unanticipated partial behavioral
 reflection, which is particularly well-suited for
 unanticipated adaptation of real-world systems. Our
 proposal combines the dynamicity of unanticipated
 reflection, i.e., reflection that does not require
 preparation of the code of any sort, and the
 selectivity and efficiency of partial behavioral
 reflection. First, we propose unanticipated partial
 behavioral reflection which enables the developer to
 precisely select the required reifications, to
 flexibly engineer the metalevel and to introduce the
 meta behavior dynamically. Second, we present a
 system supporting unanticipated partial behavioral
 reflection in Squeak Smalltalk, called Geppetto, and
 illustrate its use with a concrete example of a
 Seaside web application. Benchmarks validate the
 applicability of our proposal as an extension to the
 standard reflective abilities of Smalltalk.},
  annote = {internationalconference},
  isbn = {978-3-540-71835-2},
  issn = {0302-9743},
  keywords = {scg07 scg-pub jb07 snf06 roethlisberger reflectivity marcusdenker fromscgbib},
  medium = {2},
  series = {LNCS}}

@article{Roet08a,
  author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
  title = {Unanticipated Partial Behavioral Reflection: Adapting Applications at Runtime},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {34},
  pages = {46--65},
  publisher = {Elsevier},
  year = {2008},
  impactfactor = {Impact factor (2008) 0.421},
  doi = {10.1016/j.cl.2007.05.001},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet08a-COMLAN-UPBReflectionJournal.pdf},
  abstract = {Dynamic, unanticipated adaptation of running systems
 is of interest in a variety of situations, ranging
 from functional upgrades to on-the-fly debugging or
 monitoring of critical applications. In this paper
 we study a particular form of computational
 reflection, called unanticipated partial behavioral
 reflection, which is particularly well-suited for
 unanticipated adaptation of real-world systems. Our
 proposal combines the dynamicity of unanticipated
 reflection, i.e. reflection that does not require
 preparation of the code of any sort, and the
 selectivity and efficiency of partial behavioral
 reflection. First, we propose unanticipated partial
 behavioral reflection which enables the developer to
 precisely select the required reifications, to
 flexibly engineer the metalevel and to introduce the
 meta behavior dynamically. Second, we present a
 system supporting unanticipated partial behavioral
 reflection in Squeak Smalltalk, called Geppetto, and
 illustrate its use with a concrete example of a web
 application. Benchmarks validate the applicability
 of our proposal as an extension to the standard
 reflective abilities of Smalltalk.},
  annote = {internationaljournal},
  keywords = {scg08 scg08 scg-pub jb08 snf08 roethlisberger reflectivity marcusdenker fromscgbib},
  medium = {2},
  month = jul,
  number = {2-3}}

@inproceedings{Roet09a,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
  title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
  booktitle = {Proceedings of the 17th International Conference on Program Comprehension (ICPC'09)},
  pages = {253--257},
  publisher = {IEEE Computer Society},
  year = {2009},
  doi = {10.1109/ICPC.2008.32},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet09a-ICPC2009-HeatMaps.pdf},
  abstract = {Mainstream IDEs generally rely on the static structure of a
 software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
  address = {Los Alamitos, CA, USA},
  annote = {internationalconference},
  hal-id = {inria-00498454},
  isbn = {978-0-7695-3176-2},
  keywords = {scg-pub roethlisberger kzIDE}}

@techreport{Roet09d,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
  title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
  year = {2009},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Roet09d-TechReport-HeatMaps.pdf},
  abstract = {Mainstream IDEs generally rely on the static structure of a
 software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
  address = {Universit\"at Bern, Switzerland},
  annote = {technicalreport},
  classification = {D.2.2 Tools and Techniques; D.2.3 Coding; D.2.6 Programming Environments; D.2.9 Management},
  institution = {Institut f\"ur Informatik},
  keywords = {scg-pub snf09 jb09 roethlisberger pharo pharo-pub kzIDE},
  month = jul,
  number = {IAM-09-005},
  type = {Technical Report}}

@inproceedings{Roet09e,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Alexandre Bergel},
  title = {Tackling Software Navigation Issues of the Smalltalk IDE},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST'09)},
  publisher = {ACM Digital Library},
  year = {2009},
  doi = {10.1145/1735935.1735945},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet09e-IWST2009-obEnhancements.pdf},
  abstract = {The IDE used in most Smalltalk dialects such as Pharo, Squeak or Cincom Smalltalk did not evolve
significantly over the last years, if not to say decades. For other languages, for instance Java, the
available IDEs made tremendous progress as Eclipse or NetBeans illustrate. While the Smalltalk
IDE served as an exemplar for many years, other IDEs caught up or even overtook the erstwhile
leader in terms of feature-richness, usability, or code navigation facilities.
In this paper we first analyze the difficulty of software navigation in the Smalltalk IDE and second
illustrate with concrete examples the features we added to the Smalltalk IDE to fill the gap to
modern IDEs and to provide novel, improved means to navigate source space. We show that
thanks to the agility and dynamics of Smalltalk, we are able to extend and enhance with reasonable
effort the Smalltalk IDE to better support software navigation, program comprehension, and software
maintenance in general. One such support is the integration of dynamic information into the static
source views we are familiar with. Other means include easing the access to static information
(for instance by better arranging important packages) or helping developers re-locating artifacts
of interest (for example with a categorization system such as smart groups).},
  annote = {internationalworkshop},
  hal-id = {hal-00746247},
  isbn = {9781605588995},
  keywords = {scg-sub jb10 roethlisberger remoose2-pub pharo pharo-pub kzIDE},
  location = {Brest, France}}

@inproceedings{Roet09f,
  author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
  title = {Autumn Leaves: Curing the Window Plague in IDEs},
  booktitle = {Proceedings of the 16th Working Conference on Reverse Engineering (WCRE 2009)},
  publisher = {IEEE Computer Society},
  year = {2009},
  misc = {Acceptance rate: 20/79 = 25\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet09f-WCRE2009-AutumnLeaves-ieee.pdf},
  abstract = {Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer's workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.},
  address = {Los Alamitos, CA, USA},
  annote = {internationalconference},
  hal-id = {hal-00746246},
  keywords = {remoose2-pub pharo pharo-pub kzIDE},
  location = {Lille, France},
  rate = {25\%}}

@inproceedings{Rogl19a,
  author = {Rogliano, Th{\'e}o and Polito, Guillermo and Tesone, Pablo},
  title = {{Towards easy program migration using language virtualization}},
  booktitle = {{International Workshop of Smalltalk Technology 2019}},
  year = {2019},
  url = {https://hal.archives-ouvertes.fr/hal-02297756},
  address = {K{\"o}ln, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {Migration ; modularity ; virtualization; lse-pub},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02297756/file/TowardsEasyVirtualization.pdf},
  hal-id = {hal-02297756}}

@inproceedings{Roth11a,
  author = {David Rothlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
  title = {SmartGroups: Focusing on Task-Relevant Source Artifacts in IDEs},
  booktitle = {Proceedings of the 19th IEEE International Conference on Program Comprehension (ICPC'11)},
  publisher = {IEEE Computer Society Press},
  year = {2011},
  misc = {Acceptance rate: 18/76 = 23\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Roet11a-ICPC2011-smartGroups.pdf},
  abstract = {Navigating large software systems, even when using a modern IDE is difficult, since conceptually related software artifacts are distributed in a huge software space.
For most software maintenance tasks, only a small fraction of the entire software space is actually relevant. The IDE, however, does not reveal the task relevancy of source artifacts, thus developers cannot easily focus on the artifacts required to accomplish their tasks.
Smart Groups help developers to perform software maintenance tasks by representing groups of source artifacts that are relevant for the current task. Relevancy is determined by analyzing historical navigation and modification activities, evolutionary information, and runtime information.
The prediction quality of Smart Groups is validated with a benchmark evaluation using recorded development activities and evolutionary information from versioning systems.},
  annote = {internationalconference},
  hal-id = {inria-00614779},
  keywords = {lse-pub raweb2011 pharo pharo-pub kzIDE},
  rate = {23\%},
  x-pays = {FR,CH}}

@misc{Ryse11a,
  author = {van Ryseghem, Benjamin},
  title = {Hazelnut: dynamically creating a kernel in a reflective language},
  year = {2011},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Ryse11a-Hazelnuts.pdf}}

@techreport{Ryse12a,
  author = {van Ryseghem, Benjamin},
  title = {Spec - Technical Report},
  year = {2012},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Ryse12a-SpecTechReport.pdf},
  abstract = {A first tech report about Spec, a new UI framework for widgets generation and reuse},
  annote = {technicalReport},
  hal-id = {inria-00708067},
  institution = {INRIA Lille Nord Europe},
  keywords = {lse-pub}}

@inproceedings{Ryse12b,
  author = {van Ryseghem, Benjamin and St\'ephane Ducasse and Johan Fabry},
  title = {Spec, a framework for the specification and reuse of UIs and their models},
  booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2012)},
  pages = {2:1--2:14},
  publisher = {ACM},
  year = {2012},
  doi = {10.1145/2448963.2448965},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Ryse12b-Spec-IWST12-Final.pdf},
  abstract = {Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic.},
  address = {Gent, Belgium},
  annote = {internationalworkshop},
  hal-id = {hal-00759030},
  isbn = {978-1-4503-1897-6},
  keywords = {lse-pub stefPub kzIDE},
  location = {Ghent, Belgium},
  series = {IWST '12},
  x-country = {CL},
  x-pays = {FR,CL}}

@article{Ryse14a,
  author = {van Ryseghem, Benjamin and St\'ephane Ducasse and Johan Fabry},
  title = {Seamless Composition and Reuse of Customizable User Interfaces with Spec},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Ryse14a-SCICO-Spec.pdf},
  abstract = {Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic.},
  annote = {internationaljournal},
  hal-id = {hal-00915350},
  keywords = {lse-pub stefPub kzIDE}}

@article{Sade02a,
  author = {Benny Sadeh and St\'ephane Ducasse},
  title = {Adding Dynamic Interfaces to {Smalltalk}},
  journal = {Journal of Object Technology},
  volume = {1},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sade02aDynamicInterfaces.pdf},
  abstract = {The concept of interfaces is central to
 object-oriented methodologies and is one of the most
 attractive features of {Java} and COM. Although
 Smalltalk always had interfaces implicitly, in
 Smalltalk interfaces are not first-class objects: t
 hey cannot be conversed with, referred to, or
 reflected upon. Consequently, Smalltalkers have been
 deprived of such an important and useful tool. Since
 a fundamental feature of Smalltalk is that just
 about everything in the language is an
 implementation feature, explicit, static interfaces
 can be added to Smalltalk using Smalltalk itself
 with ease. However, such an addition would
 short-change the powerful dynamic aspects of
 Smalltalk. In this article we present
 SmallInterfaces; a new ontology of dynamic i
 nterfaces which makes a powerful use of the dynamic
 nature of Smalltalk. SmallInterfaces adds interfaces
 as honorary members to Smalltalk's extensive
 reflection mechanism, in a manner portable across
 the many Smalltalk variants},
  annote = {internationaljournal},
  keywords = {scg-pub skip-doi stefPub kzLanguageDesign},
  number = {1}}

@inproceedings{Salg16a,
  author = {Salgado, Ronie and Ducasse, St\'ephane},
  title = {{Lowcode: Extending Pharo with C Types to Improve Performance}},
  booktitle = {International Workshop on Smalltalk Technologies {IWST'16}},
  year = {2016},
  doi = {10.1145/2991041.2991064},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Salg16a-IWST16-Lowcode.pdf},
  address = {Prague, Czech Republic},
  hal-id = {hal-01353884},
  keywords = {lse-pub stefPub kzLanguageDesign kzVM},
  month = aug,
  annote = {internationalworkshop}}

@inproceedings{Sand13a,
  author = {Sandoval Alcocer, Juan Pablo and Alexandre Bergel and St\'ephane Ducasse and Marcus Denker},
  title = {Performance Evolution Blueprint: Understanding the Impact of Software Evolution on Performance},
  booktitle = {Vissoft 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sand13a-Vissoft-PreformanceBlueprint.pdf},
  abstract = {Understanding the root of a performance drop or improvement requires analyzing different program executions at a fine grain level. Such an analysis involves dedicated profiling and representation techniques. JProfiler and YourKit, two recognized code profilers fail, on both providing adequate metrics and visual representations, conveying a false sense of the performance variation root.
	We propose performance evolution blueprint, a visual support to precisely compare multiple software executions. Our blueprint is offered by Rizel, a code profiler to efficiently explore performance of a set of benchmarks against multiple software revisions.},
  annote = {internationalconference},
  hal-id = {hal-00849004},
  keywords = {pharo stefPub lse-pub kzVisualization}}

@inproceedings{Sand16a,
  author = {Juan Pablo Sandoval Alcocer and Marcus Denker and Alexandre Bergel and Yasett Acurana},
  title = {Dynamically Composing Collection Operations through Collection Promises},
  booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2016)},
  pages = {8:1--8:5},
  publisher = {ACM},
  year = {2016},
  doi = {10.1145/2991041.2991049},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sand16aIWSTCollectionPrimises.pdf},
  abstract = {Filtering, mapping, and iterating collections are frequent operations. It is known that composing a number of these operations may create intermediate collections causing an additional and unnecessary over- head. To reduce the number of intermediate collections it is often necessary to rewrite the source code and combine the operations. However, for some cases such reduction becomes aplicable only after a source code refactoring (i.e., when the collection operations are in different methods) which could introduce code duplication.
In this paper we propose Collection Promises to dynamically compose collection operations in order to reduce the number of unnecessary intermediate collections. Collection Promises delay a number of collection operations and then merge them using com- positions rules. By using Collection Promises developers can auto- matically reduce the intermediate collections even if the collection operations are in different methods.},
  annote = {internationalworkshop},
  series = {IWST'16},
  inriareport = {2016},
  keywords = {lse-pub marcusdenker},
  hal-id = {hal-01358347},
  isbn = {978-1-4503-4524-8},
  location = {Prague, Czech Republic},
  articleno = {8},
  numpages = {5},
  acmid = {2991049},
  address = {New York, NY, USA},
  x-pays = {CZ}}

@inproceedings{Sant14a,
  author = {Gustavo Santos and Marco T\'ulio Valente and Nicolas Anquetil},
  title = {Remodularization Analysis Using Semantic Clustering},
  booktitle = {Software Maintenance, Reengineering and Reverse Engineering (CSMR-WCRE), 2014 Software Evolution Week-IEEE Conference on},
  pages = {224--33},
  year = {2014},
  misc = {acceptance rate: 27/86 = 31\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant14-CSMRWCRE-SemanticClustering.pdf},
  abstract = {In this paper, we report an experience on using and adapting Semantic Clustering to evaluate software remodularizations. Semantic Clustering is an approach that relies on information retrieval and clustering techniques to extract sets of similar classes in a system, according to their vocabularies. We adapted Semantic Clustering to support remodularization analysis. We evaluate our adaptation using six real-world remodularizations of four software systems. We report that Semantic Clustering and conceptual metrics can be used to express and explain the intention of the architects when performing common modularization operators, such as module decomposition.},
  hal-id = {hal-00904409},
  keywords = {moose lse-pub cutter kzChecking kzRemodularisation kzEvolution},
  annote = {internationalconference},
  tagnicolasa = {architecture}}

@inproceedings{Sant15a,
  author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {System Specific, Source Code Transformations},
  booktitle = {31st IEEE International Conference on Software Maintenance and Evolution},
  pages = {221--230},
  year = {2015},
  misc = {acceptance rate: 32/148 = 22\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15a-ICSME-TransformationPatterns.pdf},
  hal-id = {hal-01185637},
  keywords = {moose lse-pub kzEvolution},
  abstract = {During its lifetime, a software system might undergo a major transformation effort in its structure, for example to mi- grate to a new architecture or bring some drastic improvements to the system. Particularly in this context, we found evidences that some sequences of code changes are made in a systematic way. These sequences are composed of small code transformations (e.g., create a class, move a method) which are repeatedly applied to groups of related entities (e.g., a class and some of its methods). A typical example consists in the systematic introduction of a Factory design pattern on the classes of a package. We define these sequences as transformation patterns. In this paper, we identify examples of transformation patterns in real world software systems and study their properties: (i) they are specific to a system; (ii) they were applied manually; (iii) they were not always applied to all the software entities which could have been transformed; (iv) they were sometimes complex; and (v) they were not always applied in one shot but over several releases. These results suggest that transformation patterns could benefit from automated support in their application. From this study, we propose as future work to develop a macro recorder, a tool with which a developer records a sequence of code transformations and then automatically applies them in other parts of the system as a customizable, large-scale transformation operator.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15a-ICSME-TransformationPatterns.pdf},
  annote = {topconference},
  tagnicolasa = {other analysis}}

@inproceedings{Sant15b,
  author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {Recording and Replaying System Specific, Source Code Transformations},
  booktitle = {15th IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM'15)},
  pages = {221--230},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15b-SCAM-MacroRecorder.pdf},
  hal-id = {hal-01185639},
  keywords = {moose lse-pub kzEvolution},
  abstract = {During its lifetime, a software system is under continuous maintenance to remain useful. Maintenance can be achieved in activities such as adding new features, fixing bugs, improving the system's structure, or adapting to new APIs. In such cases, developers sometimes perform sequences of code changes in a systematic way. These sequences consist of small code changes (e.g., create a class, then extract a method to this class), which are applied to groups of related code entities (e.g., some of the methods of a class). This paper presents the design and proof-of-concept implementation of a tool called MACRORECORDER. This tool records a sequence of code changes, then it allows the developer to generalize this sequence in order to apply it in other code locations. In this paper, we discuss MACRORECORDERs approach that is independent of both development and transformation tools. The evaluation is based on previous work on repetitive code changes related to rearchitecting. MACRORECORDER was able to replay 92\% of the examples, which consisted in up to seven code entities modified up to 66 times. The generation of a customizable, large-scale transformation operator has the potential to efficiently assist code maintenance},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15b-SCAM-MacroRecorder.pdf},
  annote = {internationalconference},
  tagnicolasa = {other largescale}}

@inproceedings{Sant15c,
  author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
  title = {OrionPlanning: Improving Modularization and Checking Consistency on Software Architecture},
  booktitle = {3rd IEEE Working Conference on Software Visualization (VISSOFT 2015) -- Tool track},
  pages = {190--194},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15c-VISSOFT-OrionPlanning.pdf},
  hal-id = {hal-01185635},
  keywords = {moose lse-pub kzEvolution},
  abstract = {Many techniques have been proposed in the literature to support architecture definition, conformance, and analysis. However, there is a lack of adoption of such techniques by the industry. Previous work have analyzed this poor support. Specifically, former approaches lack proper analysis techniques (e.g., detection of architectural inconsistencies), and they do not provide extension and addition of new features. In this paper, we present ORIONPLANNING, a prototype tool to assist refactorings at large scale. The tool provides support for model- based refactoring operations. These operations are performed in an interactive visualization. The contributions of the tool consist in: (i) providing iterative modifications in the architecture, and (ii) providing an environment for architecture inspection and definition of dependency rules. We evaluate ORIONPLANNING against practitioners' requirements on architecture definition listed in a previous survey. We also evaluate the tool in a concrete example of software remodularization.},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant15c-VISSOFT-OrionPlanning.pdf},
  selectif = {yes},
  annote = {internationalconference},
  tagnicolasa = {largescale architecture}}

@inproceedings{Sant17a,
  author = {Gustavo Santos and Kl\'erisson Paixao and Nicolas Anquetil and Anne Etien and Marcelo Maia and St\'ephane Ducasse},
  title = {Recommending Source Code Locations for System Specific Transformations},
  booktitle = {24th IEEE International Conference on Software Analysis, Evolution, and Reengineering},
  pages = {1--10},
  year = {2017},
  misc = {acceptance rate: 34/140 = 24\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant17a-saner-2017.pdf},
  hal-id = {hal-01441790},
  keywords = {lse-pub kzAnalysis kzEvolution},
  abstract = {From time to time, developers perform sequences of code transformations in a systematic and repetitive way. This may happen, for example, when introducing a design pattern in a legacy system: similar classes have to be introduced, containing similar methods that are called in a similar way. Automation of these sequences of transformations has been proposed in the literature to avoid errors due to their repetitive nature. However, developers still need support to identify all the relevant code locations that are candidate for transformation. Past research showed that these kinds of transformation can lag for years with forgotten instances popping out from time to time as other evolutions bring them into light. In this paper, we evaluate three distinct code search approaches (structural, based on Information Retrieval, and AST based algorithm) to find code locations that would require similar transformations. We validate the resulting candidate locations from these approaches on real cases identified previously in literature. The results show that looking for code with similar roles, e.g., classes in the same hierarchy, provides interesting results with an average recall of 87\% and in some cases the precision up to 70%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sant17a-saner-2017.pdf},
  annote = {topconference},
  keywords = {lse-pub kzAnalysis kzEvolution},
  tagnicolasa = {other largescale}}

@phdthesis{Sant17b,
  author = {Gustavo Jansen de Souza Santos},
  title = {Assessing and Improving Code Transformations to Support Software Evolution},
  year = {2017},
  school = {University Lille 1 - Sciences et Technologies - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2017-Santos.pdf},
  abstract = {In software development, change is the only constant. Software systems sometimes evolve in a substantial way and, during this process, sequences of code transformations (e.g., create a class, then override a method) are systematically performed in the system (e.g., to some classes in the same hierarchy). Due to the repetitive nature of these transformations, some automated support is needed to ensure that these sequences of transformations are consistently applied to the entire system. In this thesis we propose to improve source code transformations to better support developers performing more complex and systematic code transformations. We cover two aspects: (i) The automated support to compose and apply sequences of code transformations. We undergo an investigation on the existence of these sequences in real-world software systems. We propose a tool to automatically apply these sequences in the systems we analyzed. (ii) The detection of design violations during a transformation effort. We undergo an investigation on cases of systematic application of refactoring transformations. We proposed a tool that recommends additional transformations to fix design violations that are detected after performing refactoring transformations. We evaluated the proposed approaches quantitatively and qualitatively in real-world case studies and, in some cases, with the help of experts on the systems under analysis. The results we obtained demonstrate the usefulness of our approaches.},
  hal-id = {tel-01545596},
  month = {feb},
  keywords = {lse-pub}}

@inproceedings{Scha02a,
  author = {Nathanael Sch{\"a}rli and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {Classes = Traits + States + Glue (Beyond mixins and multiple inheritance)},
  booktitle = {Proceedings of the International Workshop on Inheritance},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha02aTraitsPlusGlue2002.pdf},
  abstract = {We present a simple, component-based model of
 mixins, called traits, and argue that this simple
 model sidesteps many of the practical problems with
 other approaches to mixins and multiple inheritance.
 With our model, classes are built from a set of
 traits by specifying glue code that connects them
 together and accesses the necessary state. We
 briefly discuss practical experience with an
 implementation of traits for Squeak, and we list a
 number of open questions for discussion.},
  annote = {internationalworkshop},
  keywords = {scg-pub stefPub kzTrait}}

@techreport{Scha02b,
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
  title = {Traits: Composable Units of Behavior},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha02bTraits.pdf},
  abstract = {Inheritance is the fundamental reuse mechanism in
 object-oriented programming languages; its most
 prominent variants are single inheritance, multiple
 inheritance, and mixin inheritance. In the first
 part of this paper, we identify and illustrate the
 conceptual and practical reusability problems that
 arise with these forms of inheritance. We then
 present a simple compositional model for structuring
 object-oriented programs, which we call traits.
 Traits are essentially groups of methods that serve
 as building blocks for classes and are primitive
 units of code reuse. In this model, classes are
 composed from a set of traits by specifying glue
 code that connects the traits together and accesses
 the necessary state. We demonstrate how traits
 overcome the problems arising with the different
 variants of inheritance, we discuss how traits can
 be implemented effectively, and we summarize our
 experience applying traits to refactor an existing
 class hierarchy.},
  address = {Universit\"at Bern, Switzerland},
  annote = {report notrefereed},
  institution = {Institut f\"ur Informatik},
  keywords = {snf-redundant scg-pub skip-doi jb02 scg-traits stefPub kzTrait},
  month = nov,
  note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
  number = {IAM-02-005},
  type = {Technical Report}}

@techreport{Scha02c,
  author = {Nathanael Sch\"arli and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Andrew Black},
  title = {Traits: The Formal Model},
  year = {2002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha02cTraitsModel.pdf},
  abstract = {Single-inheritance in object-oriented languages can
 lead to duplicated code in rich class libraries
 where feature-sharing cannot be linearized.
 Multiple-inheritance and mixins alleviate this
 problem, but lead to other difficulties in the face
 of evolution. Changes to classes or mixins can break
 code lower in the hierarchy in unexpected ways.
 Traits solve both problems by factoring out shared
 behaviour as sets of methods that do not depend on
 state. Traits have the important property that
 composition is symmetric, so changes do not lead to
 unexpected side effects. We present a formal model
 of traits, and define some basic properties of
 traits and classes.},
  address = {Universit\"at Bern, Switzerland},
  annote = {notrefereed},
  classification = {D.3.1 Formal Definitions and Theory; D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
  institution = {Institut f\"ur Informatik},
  keywords = {snf03 scg-pub skip-doi jb02 scg-traits schaerli kzTrait},
  month = nov,
  note = {Also available as Technical Report CSE-02-013, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
  number = {IAM-02-006},
  type = {Technical Report}}

@inproceedings{Scha03a,
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
  title = {Traits: Composable Units of Behavior},
  booktitle = {Proceedings of European Conference on Object-Oriented Programming},
  volume = {2743},
  pages = {248--274},
  publisher = {Springer Verlag},
  year = {2003},
  misc = {acceptance rate: 18/88 = 20\%},
  doi = {10.1007/b11832},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha03a-ECOOP-Traits.pdf},
  abstract = {Despite the undisputed prominence of inheritance as
 the fundamental reuse mechanism in object-oriented
 programming languages, the main variants --- single
 inheritance, multiple inheritance, and mixin
 inheritance --- all suffer from conceptual and
 practical problems. In the first part of this paper,
 we identify and illustrate these problems. We then
 present traits, a simple compositional model for
 structuring object-oriented programs. A trait is
 essentially a group of pure methods that serves as a
 building block for classes and is a primitive unit
 of code reuse. In this model, classes are composed
 from a set of traits by specifying glue code that
 connects the traits together and accesses the
 necessary state. We demonstrate how traits overcome
 the problems arising from the different variants of
 inheritance, we discuss how traits can be
 implemented effectively, and we summarize our
 experience applying traits to refactor an existing
 class hierarchy.},
  acceptnum = {18},
  accepttotal = {88},
  annote = {internationalconference topconference},
  cvs = {TraitsECOOP2003},
  isbn = {978-3-540-40531-3},
  keywords = {scg-pub traits stefPub kzTrait},
  month = jul,
  series = {LNCS}}

@inproceedings{Scha04a,
  author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
  title = {Composable Encapsulation Policies},
  booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'04)},
  volume = {3086},
  pages = {26--50},
  publisher = {Springer Verlag},
  year = {2004},
  misc = {acceptance rate: 25/132 = 19\%},
  doi = {10.1007/b98195},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha04a-ECOOP-EncapsulationPolicies.pdf},
  abstract = {Given the importance of encapsulation to
 object-oriented programming, it is surprising to
 note that mainstream object-oriented languages offer
 only limited and fixed ways of encapsulating
 methods. Typically one may only address two
 categories of clients, users and heirs, and one must
 bind visibility and access rights at an early stage.
 This can lead to inflexible and fragile code as well
 as clumsy workarounds. We propose a simple and
 general solution to this problem in which
 encapsulation policies can be specified separately
 from implementations. As such they become
 first-class composable entities that can be reused
 by different classes. We present a detailed analysis
 of the problem with encapsulation and visibility
 mechanisms in mainstream OO languages, we introduce
 our approach in terms of a simple model, and we
 evaluate how our approach compares with existing
 approaches. We also assess the impact of
 incorporating encapsulation policies into Smalltalk
 and discuss some implementation issues.},
  acceptnum = {25},
  accepttotal = {132},
  annote = {internationalconference topconference},
  isbn = {978-3-540-22159-3},
  keywords = {scg-pub stefPub kzLanguageDesign},
  month = jun,
  series = {LNCS}}

@inproceedings{Scha04b,
  author = {Nathanael Sch\"arli and Andrew P. Black and St\'ephane Ducasse},
  title = {Object-oriented Encapsulation for Dynamically Typed Languages},
  booktitle = {Proceedings of 18th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'04)},
  pages = {130--149},
  year = {2004},
  misc = {acceptance rate: 27/174 = 16\%},
  doi = {10.1145/1028976.1028988},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Scha04b-OOPSLA-OOEncapsulation.pdf},
  abstract = {Encapsulation in object-oriented languages has
 traditionally been based on static type systems. As
 a consequence, dynamically-typed languages have only
 limited support for encapsulation. This is
 surprising, considering that encapsulation is one of
 the most fundamental and important concepts behind
 object-oriented programming and that it is essential
 for writing programs that are maintainable and
 reliable, and that remain robust as they evolve. In
 this paper we describe the problems that are caused
 by insufficient encapsulation mechanisms and then
 present object-oriented encapsulation, a simple and
 uniform approach that solves these problems by
 bringing state of the art encapsulation features to
 dynamically typed languages. We provide a detailed
 discussion of our design rationales and compare them
 and their consequences to the encapsulation
 approaches used for statically typed languages. We
 also describe an implementation of object-oriented
 encapsulation in Smalltalk. Benchmarks show that
 extensive use of object-oriented encapsulation
 results in a slowdown of less than 15 per cent.},
  acceptnum = {27},
  accepttotal = {174},
  annote = {internationalconference topconference},
  cvs = {OOEncapsulationOOPSLA2004},
  keywords = {scg-pub stefPub kzLanguageDesign},
  month = oct}

@inproceedings{Seeb06b,
  author = {Mauricio Seeberger and Adrian Kuhn and Tudor G\^irba and St\'ephane Ducasse},
  title = {{Chronia}: Visualizing How Developers Change Software Systems},
  booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
  pages = {345--346},
  year = {2006},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Seeb06bChronia.pdf},
  abstract = {To understand a certain issue of the system we want
 to ask the knowledgeable developers. Yet, in large
 systems, not every developer is knowledgeable in all
 the details of the system. Thus, we would want to
 know which developer is knowledgeable in the issue
 at hand. In this paper we present the Chronia tool
 that implements the Ownership Map visu- alization to
 understand when and how different developers
 interacted in which way and in which part of the
 system. circle reflects the size of the change, and
 the color of the line denotes the author who owns
 most of the lines of code of the file in that
 period. File A commit by the green author followed
 by the ownership file removed by the blue author
 file present from the first import},
  annote = {tooldemo},
  cvs = {ChroniaDemoCSMR2006},
  keywords = {scg-misc moose stefPub kzVisualization girba chronia},
  month = mar,
  note = {Tool demo}}

@inproceedings{Silv15a,
  author = {Leonardo Humberto Silva and Miguel Ramos and Marco T\'ulio Valente and Alexandre Bergel and Nicolas Anquetil},
  title = {Does Javascript Software Embrace Classes?},
  booktitle = {Proceedings of the 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER'15)},
  year = {2015},
  misc = {acceptance rate: 46/144 = 32\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/silv15a-Saner-Javascript-classes.pdf},
  acceptnum = {46},
  accepttotal = {144},
  address = {Montreal, Canada},
  aeresstatus = {aeres15},
  annote = {internationalconference},
  hal-id = {hal-01185854},
  keywords = {moose lse-pub raweb2015 pharo},
  tagnicolasa = {other analysis}}

@inproceedings{Silv15b,
  author = {Luciana L. Silva and Marco T\'ulio Valente and Marcelo Maia and Nicolas Anquetil},
  title = {Developers' Perception of Co-Change Patterns: An Empirical Study},
  booktitle = {Proceedings of the 31st IEEE International Conference on Software Maintenance},
  year = {2015},
  misc = {acceptance rate: 32/148 = 22\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/silv15bICSM-cochange-patterns.pdf},
  hal-id = {hal-01185865},
  keywords = {moose lse-pub},
  annote = {topconference internationalconference},
  tagnicolasa = {architecture}}

@inproceedings{Silv15c,
  author = {Humberto Silva, Leonardo and Hovadick, Daniel and Tulio Valente, Marco and Bergel, Alexandre and Anquetil, Nicolas and Etien, Anne},
  title = {{JSClassFinder: A Tool to Detect Class-like Structures in JavaScript}},
  booktitle = {{CBSOFT'15 - Brazilian Conference on Software: Theory and Practice}},
  year = {2015},
  pdf = {https://hal.inria.fr/hal-01369705},
  address = {Belo Horizonte, Brazil},
  month = sep,
  tagnicolasa = {other analysis},
  annote = {internationalworkshop},
  pdf = {https://hal.inria.fr/hal-01369705},
  hal-id = {hal-01369705}}

@article{Silv17a,
  author = {Leonardo Humberto Silva and Marco T\'ulio Valente and Alexandre Bergel and Nicolas Anquetil and Anne Etien},
  title = {Identifying Classes in Legacy JavaScript Code},
  journal = {Journal of Software: Evolution and Process},
  year = {2017},
  url = {https://hal.inria.fr/hal-01471905},
  doi = {10.1002/smr.1864},
  abstract = {JavaScript is the most popular programming language for the Web. Although the language is prototype-based, developers can emulate class-based abstractions in JavaScript to master the increasing complexity of their applications. Identifying classes in legacy JavaScript code can support these developers at least in the following activities: (i) program comprehension; (ii) migration to the new JavaScript syntax that supports classes; and (iii) implementation of supporting tools, including IDEs with class-based views and reverse engineering tools. In this paper, we propose a strategy to detect class-based abstractions in the source code of legacy JavaScript systems. We report on a large and in-depth study to understand how class emulation is employed, using a dataset of 918 JavaScript applications available on GitHub. We found that almost 70\% of the JavaScript systems we study make some usage of classes. We also performed a field study with the main developers of 60 popular JavaScript systems in order to validate our findings. The overall results range from 97\% to 100\% for precision, from 70\% to 89\% for recall, and from 82\% to 94\% for F-score.},
  issn = {2047-7481},
  hal-id = {hal-01471905},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Silv17a-ClassesJavaScript.pdf},
  keywords = {moose lse-pub},
  tagnicolasa = {other analysis}}

@inproceedings{Sing10a,
  author = {Singer, Janice and Lethbridge, Timothy and Vinson, Norman and Anquetil, Nicolas},
  title = {An Examination of Software Engineering Work Practices},
  booktitle = {CASCON First Decade High Impact Papers},
  pages = {174--188},
  publisher = {IBM Corp.},
  year = {2010},
  url = {http://dx.doi.org/10.1145/1925805.1925815},
  doi = {10.1145/1925805.1925815},
  acmid = {1925815},
  address = {Riverton, NJ, USA},
  annote = {invited},
  location = {Toronto, Ontario, Canada},
  numpages = {15},
  series = {CASCON '10},
  tagnicolasa = {other analysis}}

@inproceedings{Sing97a,
  author = {Singer, Janice and Lethbridge, Timothy and Vinson, Norman and Anquetil, Nicolas},
  title = {An examination of software engineering work practices},
  booktitle = {Proceedings of the 1997 conference of the Centre for Advanced Studies on Collaborative research},
  pages = {21--},
  publisher = {IBM Press},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Sing97a-SoftwareEngineeringWorkPractices.pdf},
  abstract = {This paper presents work practice data of the daily activities of software engineers. Four separate studies are presented; one looking longitudinally at an individual SE; two looking at a software engineering group; and one looking at company-wide tool usage statistics. We also discuss the advantages in considering work practices in designing tools for software engineers, and include some requirements for a tool we have developed as a result of our studies.},
  annote = {internationalconference},
  location = {Toronto, Ontario, Canada},
  series = {CASCON '97},
  tagnicolasa = {other analysis}}

@inproceedings{Sous04a,
  author = {Kleiber D. de Sousa and Nicolas Anquetil and K{\'a}thia Mar\c{c}al de Oliveira},
  title = {Learning Software Maintenance Organizations},
  booktitle = {Advances in Learning Software Organizations, 6th International Workshop, LSO 2004},
  volume = {3096},
  pages = {67-77},
  publisher = {Springer},
  year = {2004},
  abstract = {Developing and maintaining software systems is a knowledge intensive task. One needs knowledge of the application domain of the software, the problem the system solves, the requirements for this problem, the architecture of the system and how the different parts fit together, how the system interacts with its environment, etc. More often than not, this knowledge is not documented and lives only in the head of the software engineers. It is, therefore, volatile and an organization may repeatedly pay professionals to rediscover a knowledge it previously acquired and lost. In recognition of this fact, knowledge management techniques such as Postmortem Analysis are being used to help salvage this knowledge. Traditionally, Postmortem Analysis has been applied at the end of software development projects with a focus on organizational aspects such as how to improve the execution of a process. In this paper, we present the application of Postmortem Analysis in a new context: for software maintenance projects. We also apply it, not only for process improvement, but to discover knowledge on the software maintained itself.},
  annote = {internationalworkshop},
  isbn = {3-540-22192-1},
  series = {Lecture Notes in Computer Science},
  tagnicolasa = {knowledge}}

@inproceedings{Sous08b,
  author = {Andr\'e Sousa and Uir\'a Kulesza and Andreas Rummler and Nicolas Anquetil, Ralf Mitschke and Ana Moreira and Vasco Amaral and Jo\~{a}o Ara\'ujo},
  title = {A Model-Driven Traceability Framework to Software Product Line Development},
  booktitle = {ECMDA Traceability Workshop Proceedings},
  publisher = {SINTEF ICT},
  year = {2008},
  abstract = {In this paper, we present a model-driven traceability framework to software product line (SPL) development. Model-driven techniques are adopted with the aim to support the flexible specification of trace links between different kinds of SPL artefacts. A traceability metamodel is defined to support the flexible creation and storage of the SPL trace links. The framework is organized as a set of extensible plug-ins that can be instantiated to create customized trace queries and views. It is implemented based on the Eclipse platform and EMF technology. We illustrate a concrete instantiation of the framework to support the tracing between feature and use cases models.},
  address = {Norway},
  annote = {internationalworkshop},
  month = {jun},
  tagnicolasa = {other traceability SPL}}

@inproceedings{Souz05a,
  author = {de Souza, Sergio Cozzetti B. and Anquetil, Nicolas and de Oliveira, K\'{a}thia M.},
  title = {A study of the documentation essential to software maintenance},
  booktitle = {Proceedings of the 23rd annual international conference on Design of communication: documenting \& designing for pervasive information},
  pages = {68--75},
  publisher = {ACM},
  year = {2005},
  doi = {10.1145/1085313.1085331},
  abstract = {Software engineering has been striving for years to improve the practice of software development and maintenance. Documentation has long been prominent on the list of recommended practices to improve development and help maintenance. Recently however, agile methods started to shake this view, arguing that the goal of the game is to produce software and that documentation is only useful as long as it helps to reach this goal.On the other hand, in the re-engineering field, people wish they could re-document useful legacy software so that they may continue maintain them or migrate them to new platform.In these two case, a crucial question arises: "How much documentation is enough?" In this article, we present the results of a survey of software maintainers to try to establish what documentation artifacts are the most useful to them.},
  address = {New York, NY, USA},
  annote = {internationalconference},
  isbn = {1-59593-175-9},
  keywords = {empirical study, program understanding, software maintenance, software system documentation},
  location = {Coventry, United Kingdom},
  series = {SIGDOC '05},
  tagnicolasa = {knowledge}}

@article{Souz06a,
  author = {Souza, Sergio Cozzetti B. de and Anquetil, Nicolas and Oliveira, K\'{a}thia M. de},
  title = {Which documentation for software maintenance?},
  journal = {Journal of the Brazilian Computer Society},
  pages = {31--44},
  year = {2006},
  doi = {10.1007/BF03194494},
  pdf = {http://www.scielo.br/pdf/jbcos/v12n3/04.pdf},
  abstract = {Software engineering has been striving for years to improve the practice of software development and maintenance. Documentation has long been prominent on the list of recommended practices to improve development and help maintenance. Recently however, agile methods started to shake this view, arguing that the goal of the game is to produce software and that documentation is only useful as long as it helps to reach this goal. On the other hand, in the re-engineering field, people wish they could re-document useful legacy software so that they may continue maintain them or migrate them to new platform. In these two case, a crucial question arises: "How much documentation is enough?" In this article, we present the results of a survey of software maintainers to try to establish what documentation artifacts are the most useful to
them.},
  aeres = {ACLN},
  annote = {nationaljournal},
  issn = {0104-6500},
  tagnicolasa = {knowledge}}

@incollection{Stein12a,
  author = {Steinert, Bastian and Taeumel, Marcel and Cassou, Damien and Hirschfeld, Robert},
  title = {Adopting Design Practices for Programming},
  booktitle = {Design Thinking Research},
  publisher = {Springer},
  year = {2012},
  doi = {10.1007/978-3-642-31991-4\_14},
  abstract = {Developers continuously design their programs. For
 example, developers strive for simplicity and
 consistency in their constructions like
 practitioners in most design fields. A simple
 program design supports working on current and
 future development tasks. While many problems
 addressed by developers have characteristics similar
 to design problems, developers typically do not use
 principles and practices dedicated to such problems.
 In this chapter we report on the adoption of design
 practices for programming. First, we propose a new
 concept for integrated programming environments that
 encourages developers to work with concrete
 representations of abstract thoughts within a
 flexible canvas. Second, we present continuous
 versioning as our approach to support the need for
 withdrawing changes during program design
 activities.}}

@misc{Stin05a,
  author = {Serge Stinckwich and St\'ephane Ducasse},
  title = {La syntaxe Smalltalk},
  journal = {Linux Pratique},
  volume = 1,
  pages = {18--23},
  year = {2005},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = nov,
  number = 32}

@misc{Stin06a,
  author = {Serge Stinckwich and St\'ephane Ducasse},
  title = {Les structures de contr\^ole en Smalltalk},
  journal = {Linux Pratique},
  volume = 1,
  pages = {18--23},
  year = {2006},
  annote = {vulgarisation},
  keywords = {stefPub kzVulgarisation},
  month = jan,
  number = 33}

@misc{Stin06b,
  author = {Serge Stinckwich and Hilaire Fernandes},
  title = {Nos premi\`eres classes en Smalltalk},
  journal = {Linux Magazine},
  volume = 1,
  pages = {18--23},
  year = {2006},
  annote = {vulgarisation},
  month = jun,
  number = 84}

@inproceedings{Suen07a,
  author = {Mathieu Suen and St\'ephane Ducasse and Damien Pollet and Hani Abdeen and Ilham Alloui},
  title = {Package Surface Blueprint: A Software Map},
  booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
  year = {2007},
  annote = {internationalworkshop stefPub},
  keywords = {moose kzVisualization}}

@inproceedings{Suny01a,
  author = {Suny\'e, Gerson and Pollet, Damien and Le~Traon, Yves and J\'ez\'equel, Jean-Marc},
  title = {Refactoring UML Models},
  booktitle = {UML~2001 --- The Unified Modeling Language --- Modeling Languages, Concepts, and Tools},
  volume = {2185},
  pages = {134--148},
  publisher = {Springer Verlag},
  year = {2001},
  pdf = {http://www.irisa.fr/triskell/publis/2001/Sunye01b.pdf},
  address = {Toronto, Canada},
  annote = {internationalconference},
  editor = {Gogolla, Martin and Kobryn, Cris},
  isbn = {3-540-42667-1},
  month = oct,
  note = {Ten-Year Most Influential Paper Award at Models 2011},
  series = {LNCS}}

@book{Surya14a,
  author = {Suryanarayana, Girish and Samarthyam, Ganesh and Sharma, Tushar},
  title = {Refactoring for Software Design Smells: Managing Technical Debt},
  publisher = {Morgan Kaufmann Publishers Inc.},
  year = {2014},
  annote = {foreword},
  isbn = {0128013974, 9780128013977},
  address = {San Francisco, CA, USA}}

@techreport{Tant05a,
  author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
  title = {Context-aware aspects},
  year = {2005},
  institution = {University of Chile},
  keywords = {fromscgbib marcusdenker},
  note = {published to Software Composition (SC'06)},
  number = {TR/DCC-2005-12}}

@inproceedings{Tant06a,
  author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
  title = {Context-Aware Aspects},
  booktitle = {Proceedings of the 5th International Symposium on Software Composition (SC 2006)},
  volume = {4089},
  pages = {227--242},
  year = {2006},
  doi = {10.1007/11821946\_15},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tant06a-SC06-ContextAspects.pdf},
  abstract = {Context-aware applications behave differently
 depending on the context in which they are running.
 Since context-specific behavior tends to crosscut
 base programs, it can advantageously be implemented
 as aspects. This leads to the notion of
 context-aware aspects, e.g., aspects whose behavior
 depends on context. This paper analyzes the issue of
 appropriate support from the aspect language to both
 restrict the scope of aspects according to the
 context and allow aspect definitions to access
 information associated to the context. We propose an
 open framework for context-aware aspects that allows
 for the definition of first-class contexts and
 supports the definition of context awareness
 constructs for aspects, including the ability to
 refer to past contexts, and to provide domain- and
 application-specific constructs.},
  address = {Vienna, Austria},
  annote = {internationalconference},
  isbn = {978-3-540-37657-6},
  keywords = {scg-pub jb06 fb06 snf06 fromscgbib marcusdenker},
  medium = {2},
  month = mar,
  series = {LNCS}}

@inproceedings{Terr16a,
  author = {Ricardo Terra and Marco Tulio Valente and Nicolas Anquetil},
  title = {A Lightweight Remodularization Process Based on Structural Similarity},
  booktitle = {2016 X Brazilian Symposium on Software Components, Architectures and Reuse (SBCARS)},
  pages = {111-120},
  year = {2016},
  doi = {10.1109/SBCARS.2016.24},
  keywords = {software architecture;software maintenance;lightweight remodularization process;structural similarity;erosion process;weakly-cohesive components;strongly-coupled components;architectural design;tool supported remodularization process;software system;move class refactoring;move refactoring method;extract refactoring method;open-source software;Software;Visualization;Computer architecture;Electronic mail;Java;Concrete;remodularization;structural similarity;refactoring},
  annote = {internationalworkshop},
  tagnicolasa = {other},
  month = {sep}}

@inproceedings{Teru13a,
  author = {Teruel, Camille and Cassou, Damien and Ducasse, St\'ephane},
  title = {{Object Graph Isolation with Proxies}},
  booktitle = {{DYLA - 7th Workshop on Dynamic Languages and Applications, Collocated with 26th European Conference on Object-Oriented Programming - 2013}},
  year = {2013},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru13a-Dyla-ObjectGraph.pdf},
  abstract = {More and more software systems are now made of multiple collaborating third-party components. Enabling fine-grained control over the communication between components becomes a major requirement. While software isolation has been studied for a long time in operating systems (OS), most programming languages lack support for isolation. In this context we explore the notion of proxy. A proxy is a surrogate for another object that controls access to this object. We are particularly interested in generic proxy implementations based on language-level reflection. We present an analysis that shows how these reflective proxies can propagate a security policy thanks to the transitive wrapping mechanism. We present a prototype implementation that support transitive wrapping and allows a fine-grained control over an isolated object graph.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-00834320},
  keywords = {lse-pub stefPub kzLanguageDesign},
  pdf = {http://hal.inria.fr/hal-00834320/PDF/main.pdf}}

@article{Teru15a,
  author = {Teruel, Camille and Wernli, Erwann and Ducasse, St\'ephane and Nierstrasz, Oscar},
  title = {Propagation of Behavioral Variations with Delegation Proxies},
  journal = {Transactions on Aspect-Oriented Software Development (TAOSD)},
  pages = {63--95},
  publisher = {Springer},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru15a-Propagation-of-Behavioral-Variations-with-Delegation-Proxies.pdf},
  hal-id = {hal-01135706},
  keywords = {lse-pub stefPub kzLanguageDesign},
  abstract = {Scoping behavioral variations to dynamic extents is useful to support non-functional concerns that otherwise result in cross-cutting code. Unfortunately, such forms of scoping are difficult to obtain with traditional reflection or aspects. We propose delegation proxies, a dynamic proxy model that supports behavioral intercession through the interception of various interpretation operations. Delegation proxies permit different behavioral variations to be easily composed together. We show how delegation proxies enable behavioral variations that can propagate to dynamic extents. We demonstrate our approach with examples of behavioral variations scoped to dynamic extents that help simplify code related to safety, reliability, and monitoring.},
  annote = {internationaljournal},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru15a-Propagation-of-Behavioral-Variations-with-Delegation-Proxies.pdf}}

@inproceedings{Teru15b,
  author = {Teruel, Camille and Ducasse, St\'ephane and Cassou, Damien and Marcus Denker},
  title = {Access Control to Reflection with Object Ownership},
  booktitle = {Dynamic Languages Symposium (DLS'2015)},
  year = {2015},
  url = {https://hal.inria.fr/hal-01217041},
  doi = {10.1145/2816707.2816721},
  abstract = {Reflection is a powerful programming language
 feature that enables language extensions, generic
 code, dynamic analyses, development tools, etc.
 However, uncontrolled reflection breaks object
 encapsulation and considerably increases the attack
 surface of programs e.g., malicious libraries can
 use reflection to attack their client applications.
 To bring reflection and object encapsulation back
 together, we use dynamic object ownership to design
 an access control policy to reflective operations.
 This policy grants objects full reflective power
 over the objects they own but limited reflective
 power over other objects. Code is still able to use
 advanced reflective operations but reflection cannot
 be used as an attack vector anymore.},
  annote = {internationalconference},
  audience = {international},
  hal-id = {hal-01217041},
  inria = {RMOD},
  keywords = {lse-pub stefPub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teru15b-DLS15-AccessControlWithOwnership.pdf},
  acceptnum = {14},
  accepttotal = {40}}

@phdthesis{Teru16a,
  author = {Camille Teruel},
  title = {Adaptability and Encapsulation in Dynamically-Typed Languages: Taming Reflection and Extension Methods},
  year = {2016},
  school = {Universit\'{e} Lille 1 - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2016-Teruel.pdf},
  abstract = {Users expect modern software to be both continually available and updated on the fly. Introduction of new features and integration of bug fixes should not trouble the smooth running of an application. Developers also benefit from dynamic modifications of software, e.g. they can adapt code to new unanticipated situations or they can run dynamic analyses to get feedback about the behavior of running applications for monitoring, debugging and optimization purposes. Programming languages and their runtimes should thus provides developers with mechanisms that improve software adaptability. At the same time, the increasing size and complexity of software call for applications made up of many interacting components developed by different parties. In this context, either all components are trusted or each component needs to be properly protected from other ones. For example, a plugin should not be able to manipulate the internal structures or leaks private data of its host application unrestrictedly. Likewise, a malicious library should not be able to corrupt its clients or interfere with their operations. Programming languages should thus provide developers with mechanisms that improve software isolation, such as encapsulation and custom access control policies. The need for dynamic adaptations that can change nearly every aspect of an application on the one hand and the need for properly confined components on the other hand pulls programming language design in two opposite directions: ei- ther more flexibility or more control. This dissertation studies this tension in the context of dynamically-typed object-oriented languages with two language mechanisms that promote software adaptability: reflection and extension methods. For both mechanisms, we demonstrate their usefulness, their harmful effect on encap- sulation and propose solutions to retain their power while maintaining encapsulation.},
  hal-id = {tel-01290364},
  month = jan,
  keywords = {lse-pub}}

@inproceedings{Teso16a,
  author = {Tesone, Pablo and Polito, Guillermo and Fabresse, Luc and Bouraqadi, Noury and Ducasse, St\'ephane},
  title = {Instance Migration in Dynamic Software Update},
  booktitle = {Meta'16},
  year = {2016},
  url = {https://hal.inria.fr/hal-01611600},
  annote = {internalworkshop},
  address = {Amsterdam, Netherlands},
  month = oct,
  keywords = {Object-oriented Languages ; Dynamic Software Update ;	State Migration ; Object Oriented Programming ; DSU ;	OOP ;	Pharo ;	Meta-programming; lse-pub kzLanguageDesign kzInfrastructure kzPharo},
  hal-pdf = {https://hal.inria.fr/hal-01611600/file/main.pdf},
  hal-id = {hal-01611600}}

@article{Teso17b,
  author = {Pablo Tesone and Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Dynamic Software Update from Development to Production},
  journal = {Journal of Object Technology},
  publisher = {AITO - Association Internationale pour les Technologies Objets},
  year = {2018},
  doi = {10.5381/jot.2018.17.1.a2},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso17b-JOT-DynamicUpdate.pdf},
  annote = {internationaljournal},
  abstract = {Dynamic Software Update (DSU) solutions update applications while they are executing. These solutions are typically used in production to minimize application downtime, or in integrated development environments to provide live programming support. Each of these scenarios presents different challenges, forcing existing solutions to be designed with only one of these use cases in mind. For example, DSUs for live programming typically do not implement safe point detection or instance migration, while production DSUs require manual generation of patches and lack IDE integration. Also, these solutions have limited ability to update themselves or the language core libraries, and some of them present execution penalties outside the update window. We propose a DSU (gDSU) that works for both live programming and production environments. Our solution implements safe update point detection using call stack manipulation and a reusable instance migration mechanism to minimize manual intervention in patch generation. Moreover, it also offers updates of core language libraries and the update mechanism itself. This is achieved by the incremental copy of the modified objects and an atomic commit operation. We show that our solution does not affect the global performance of the application and it presents only a run-time penalty during the update window. Our solution is able to apply an update impacting 100,000 instances in 1 second. In this 1 second, only during 250 milliseconds the application is not responsive. The rest of the time the application runs normally while gDSU is looking for the safe update point. The update only requires to copy the elements that are modified.},
  keywords = {pharo lse-pub},
  hal-id = {hal-01920362}}

@inproceedings{Teso18a,
  author = {Tesone, Pablo and Polito, Guillermo and Fabresse, Luc and Bouraqadi, Noury and Ducasse, St\'ephane},
  title = {Implementing Modular Class-based Reuse Mechanisms on Top of a Single Inheritance VM},
  booktitle = {Symposium on Applied Computing (SAC'18)},
  year = {2018},
  url = {https://hal.archives-ouvertes.fr/hal-01812612},
  doi = {10.1145/3167132.3167244},
  annote = {internationalconference},
  abstract = {Code reuse is a good strategy to avoid code duplication and speed up software development. Existing object-oriented programming languages propose different ways of combining existing and new code such as e.g., single inheritance, multiple inheritance, Traits or Mixins. All these mechanisms present advantages and disadvantages and there are situations that require the use of one over the other. To avoid the complexity of implementing a virtual machine (VM), many of these mechanisms are often implemented on top of an existing high-performance VM, originally meant to run a single inheritance object-oriented language. These implementations require thus a mapping between the programming model they propose and the execution model provided by the VM. Moreover, reuse mechanisms are not usually composable, nor it is easy to implement new ones for a given language. In this paper, we propose a modular meta-level runtime architecture to implement and combine different code reuse mechanisms. This architecture supports dynamic combination of several mechanisms without affecting runtime performance in a single inheritance object-oriented VM. It includes moreover a reflective Meta-Object Protocol to query and modify classes using the programming logical model instead of the underlying low-level runtime model. Thanks to this architecture, we implemented Stateful Traits, Mixins, CLOS multiple inheritance, CLOS Standard Method Combinations and Beta prefixing in a modular and composable way.},
  address = {Pau, France},
  month = apr,
  keywords = {lse-pub pharo kzInfrastructure kzLanguage},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso18a-SAC-ExtensibleMetaclasses.pdf},
  hal-id = {hal-01812612}}

@phdthesis{Teso18b,
  author = {Pablo Tesone},
  title = {Dynamic Software Update for Production and Live Programming Environments},
  year = {2018},
  school = {Universit\'e de Lille - IMT Lille Douai},
  url = {https://hal.inria.fr/view/index/docid/2025442},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2018-Tesone.pdf},
  abstract = {Updating applications during their execution is used both in production to minimize application downtime and in integrated development environments to provide live programming support. Nevertheless, these two scenarios present different challenges making Dynamic Software Update (DSU) solutions to be specifically designed for only one of these use cases. For example, DSUs for live programming typically do not implement safe point detection or instance migration, while production DSUs require manual generation of patches and lack IDE integration. These solutions also have a limited ability to update themselves or the language core libraries and some of them present execution penalties outside the update window. In this PhD, we propose a unified DSU named gDSU for both live programming and production environments. gDSU provides safe update point detection using call stack manipulation and a reusable instance migration mechanism to minimize manual intervention in patch generation. It also supports updating the core language libraries as well as the update mechanism itself thanks to its incremental copy of the modified objects and its atomic commit operation. gDSU does not affect the global performance of the application and it presents only a run-time penalty during the update window. For example, gDSU is able to apply an update impacting 100,000 instances in 1 second making the application not responsive for only 250 milliseconds. The rest of the time the application runs normally while gDSU is looking for a safe update point during which modified elements will be copied. We also present extensions of gDSU to support transactional live programming and atomic automatic refactorings which increase the usability of live programming environments.},
  annote = {PhD},
  hal-id = {tel-02025442},
  institution = {INRIA - IMT Lille Douai},
  keywords = {dynamic software update, live programming, long running applications, transactional modifications, automatic refactorings}}

@inproceedings{Teso18c,
  author = {Tesone, Pablo and Bragagnolo, Santiago and Denker, Marcus and Ducasse, St\'ephane},
  title = {Transparent Memory Optimization using Slots},
  booktitle = {IWST'18},
  year = {2018},
  url = {https://hal.inria.fr/hal-02565748},
  annote = {internalworkshop},
  address = {Cagliari, Italy},
  month = sep,
  keywords = {Object-oriented Languages memory-consumption optimization lse-pub kzLanguageDesign kzPharo},
  hal-pdf = {https://hal.inria.fr/hal-02565748/file/main.pdf},
  hal-id = {hal-02565748}}

@article{Teso20a,
  author = {Pablo Tesone and Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Preserving Instance State during Refactorings in Live Environments},
  journal = {Future Generation Computer Systems},
  publisher = {Elsevier},
  year = {2020},
  annote = {internationaljournal},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02541754/file/main.pdf},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso20a-FutureGeneration-PreservingInstance.pdf},
  keywords = {pharo lse-pub kzLanguageDesign}}

@article{Teso20b,
  author = {Pablo Tesone and St\'ephane Ducasse and Guillermo Polito and Luc Fabresse and Noury Bouraqadi},
  title = {A new modular implementation for Stateful Traits},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2020},
  annote = {internationaljournal},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02541842/file/main.pdf},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso20b-SCP-StatefulTraits.pdf},
  keywords = {pharo lse-pub kzLanguageDesign}}

@inproceedings{Tich00b,
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
  title = {A Meta-model for Language-Independent Refactoring},
  booktitle = {Proceedings of International Symposium on Principles of Software Evolution},
  pages = {157--167},
  publisher = {IEEE Computer Society Press},
  year = {2000},
  misc = {acceptance rate: 22/51 = 43\%},
  doi = {10.1109/ISPSE.2000.913233},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich00bRefactoringMetamodel.pdf},
  abstract = {Refactoring --- transforming code while preserving
 behaviour --- is currently considered a key approach
 for improving object-oriented software systems.
 Unfortunately, all of the current refactoring tools
 depend on language-dependent refactoring engines,
 which prevents a smooth integration with mainstream
 development environments. In this paper we
 investigate the similarities between refactorings
 for Smalltalk and {Java}, derive a
 language-independent meta-model and show that it is
 feasible to build a language-independent refactoring
 engine on top of this meta-model. Our feasibility
 study is validated by means of a tool prototype
 which uses the same engine to refactor both
 Smalltalk and {Java} code. Using our approach we
 minimize the language-dependent part of refactoring
 tools, providing a standard way for programmers and
 tools to perform refactorings no matter what
 language they work in.},
  acceptnum = {22},
  accepttotal = {51},
  annote = {internationalconference},
  keywords = {reengineering refactoring FAMIX repositories scg-pub stefPub moose kzMeta},
  series = {ISPSE'00}}

@inproceedings{Tich00m,
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
  title = {{FAMIX}: Exchange Experiences with {CDIF} and {XMI}},
  booktitle = {Proceedings of the ICSE 2000 Workshop on Standard Exchange Format (WoSEF 2000)},
  year = {2000},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich00mFamixCdifXmi.pdf},
  abstract = {In the FAMOOS project we have developed a set of
 tools for reengineering object-oriented legacy
 systems. These tools are based on the FAMIX meta
 model and exchange information using CDIF, an
 industry standard exchange format. For several
 reasons XMI, an emerging standard for information
 exchange, has appealed to us to be used as our
 interchange format. In this paper we discuss why XMI
 is interesting for us and what, to our current
 experience, are the advantages and disadvantages of
 XMI over CDIF.},
  annote = {internationalworkshop},
  keywords = {scg-pub stefPub moose kzTools},
  month = jun}

@inproceedings{Tich00n,
  author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
  title = {{FAMIX} and {XMI}},
  booktitle = {Proceedings WCRE 2000 Workshop on Exchange Formats},
  pages = {296--296},
  publisher = {IEEE Computer Society Press},
  year = {2000},
  doi = {10.1109/WCRE.2000.891485},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich00nFamixWCRE2000.pdf},
  abstract = {Recently exchange formats have gained lots of
 attention. Multiple tools need to interact and/or
 work on the same software system. Especially there
 is a need to reuse parser technology. Within the
 FAMOOS project we have developed a model for
 representing object-oriented software systems at the
 program entity level. The model has been designed
 for language independence, extensibility and
 information exchange. For the actual exchange of
 data we are currently moving to use XMI, a standard
 for model-based information exchange.},
  address = {Los Alamitos CA},
  annote = {internationalworkshop},
  keywords = {scg-pub stefPub moose kzMeta kzTools},
  month = nov}

@techreport{Tich01y,
  author = {Sander Tichelaar and St\'ephane Ducasse},
  title = {Pull Up/Push Down Method: an Analysis},
  year = {2001},
  annote = {report notrefereed},
  institution = {Institute of Computer Science and Applied Mathematics},
  keywords = {kzPattern},
  note = {University of Bern, IAM-TR-09-01}}

@inproceedings{Tich97b,
  author = {Sander Tichelaar and St\'ephane Ducasse and Theo-Dirk Meijler},
  title = {Architectural Extraction In Reverse Engineering by Prototyping: An experiment},
  booktitle = {Proceedings of the ESEC/FSE Workshop on Object-Oriented Re-engineering},
  publisher = {Technical University of Vienna, Information Systems Institute, Distributed Systems Group},
  year = {1997},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Tich97bArchExtraction.pdf},
  abstract = {In this workshop proposal we present a prototype
 approach to help the extraction of architectural
 information in the re-engineering process. Commonly,
 the re-engineering life-cycle has been defined as a
 succession of the following tasks: analysis of
 requirements, model capture (understanding the
 system), problem detection, problem analysis,
 reorganization and change propagation. We have
 evaluated the benefit of a prototyping approach with
 a focus on model capture. Although prototyping is a
 known approach to evaluate the application
 feasibility, costs, comparison and validation of
 choices, we focus in this paper on the aspects of
 prototyping that are helpful for re-engineering.},
  annote = {internationalworkshop},
  editor = {Serge Demeyer and Harald Gall},
  keywords = {stefPub scg-pub kzArchitecture},
  month = sep,
  note = {Technical Report TUV-1841-97-10}}

@inproceedings{Uqui09b,
  author = {Uquillas G\'{o}mez, Ver\'{o}nica and Kellens, Andy and Brichau, Johan and D'Hondt, Theo},
  title = {Time warp, an approach for reasoning over system histories},
  booktitle = {Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops},
  pages = {79--88},
  publisher = {ACM},
  year = {2009},
  doi = {10.1145/1595808.1595825},
  address = {New York, NY, USA},
  isbn = {978-1-60558-678-6},
  location = {Amsterdam, The Netherlands},
  series = {IWPSE-Evol'09}}

@inproceedings{Uqui10a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Visually Supporting Source Code Changes Integration: the {T}orch Dashboard},
  booktitle = {Proceedings of the 17th Working Conference on Reverse Engineering (WCRE'10)},
  pages = {55-64},
  year = {2010},
  misc = {Acceptance rate = 22/68 = 32\%},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui10a-Torch-WCRE10.pdf},
  abstract = {Automatic and advanced merging algorithms help programmers to merge their modifications in main development repositories. However, there is little support to help release masters (integrators) to take decisions about the integration of published merged changes into the system release. Most of the time, the release master has to read all the changed code, check the diffs to build an idea of a change, and read unchanged code to understand the context of some changes. Such a task can be overwhelming. In this paper we present a dashboard to support integrators getting an overview of proposed changes in the context of object-oriented programming. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. We describe our experiment applying it to Pharo, a large open-source system, and report on the evaluation of our approach by release masters of several open-source projects.},
  annote = {internationalconference},
  hal-id = {inria-00531508},
  keywords = {lse-pub pharo pharo-pub kzMerging kzVisualisation},
  month = oct}

@inproceedings{Uqui10b,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Meta-models and Infrastructure for Smalltalk Omnipresent History},
  booktitle = {Smalltalks'2010},
  year = {2010},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui10b-Smalltalk2010-Metamodels.pdf},
  abstract = {Source code management systems record different versions of code. Tool support can then com- pute deltas between versions. However there is little support to be able to perform history-wide queries and analysis: for example building slices of changes and identifying their differences since the beginning of the project. We believe that this is due to the lack of a powerful code meta- model as well as an infrastructure. For example, in Smalltalk often several source code meta- models coexist: the Smalltalk reflective API coexists with the one of the Refactoring engine or distributed versioning system. While having specific meta-models is an engineered solution, it hampers meta-models manipulation as it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly navigation tool reuse. As a first step to solve this problem, this article presents several source code models that could be used to support several activities and proposes an unified and layered approach to be the foundation for building an infrastructure for omnipresent version browsing.},
  annote = {internationalworkshop},
  hal-id = {inria-00531613},
  keywords = {stefPub lse-pub pharo pharo-pub kzMeta kzMerging}}

@article{Uqui11a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Ring: a Unifying Meta-Model and Infrastructure for {S}malltalk Source Code Analysis Tools},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {38},
  pages = {44-60},
  year = {2012},
  impactfactor = {Impact factor (2010) 0.541},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui11a-RingJournalPaper-CSSJournal.pdf},
  abstract = {Source code management systems record different versions of code. Tool support can then compute deltas between versions. To ease version history analysis we need adequate models to represent source code entities. Now naturally the questions of their definition, the abstractions they use, and the APIs of such models are raised, especially in the context of a reflective system which already offers a model of its own structure.
	We believe that this problem is due to the lack of a powerful code meta-model as well as an infrastructure. In Smalltalk, often several source code meta-models coexist: the Smalltalk reflective API coexists with the one of the Refactoring Engine or distributed versioning system such as Monticello or Store. While having specific meta-models is an adequate engineered solution, it multiplies	meta-models and it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly hinders navigation tool reuse when meta-models do not offer polymorphic APIs.
	As a first step to provide an infrastructure to support history analysis, this article presents Ring, a unifying source code meta-model that can be used to support several activities and proposes a unified and layered approach to be the foundation for building an infrastructure for version and stream of change analyses. We re-implemented three tools based on Ring to show that it can be used as the underlying meta-model for remote and off-image browsing, scoping refactoring, and visualizing and analyzing changes. As a future work and based on Ring we will build a new generation of history analysis tools.},
  annote = {internationaljournal},
  hal-id = {inria-00629677},
  keywords = {stefPub lse-pub raweb2011 pharo pharo-pub kzMeta kzMerging},
  month = apr,
  number = 1}

@mastersthesis{Uqui12b,
  author = {Uquillas G\'{o}mez, Ver\'{o}nica},
  title = {Supporting Integration Activities in Object-Oriented Applications},
  year = {2012},
  school = {Vrije Universiteit Brussel - Belgium \& Universit\'{e} Lille 1 - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2012-Uquillas-Gomez.pdf},
  abstract = {Modern software is built by teams of developers that work in a collaborative environment. The goal of this kind of development is that multiple developers can work in parallel. They can alter a set of shared artifacts and inspect and integrate the source code changes of other developers. For example, bug fixes, enhancements, new features or adaptations due to changing environment might be integrated into the system release. At a technical level, a collaborative development process is supported by version control systems. Since these version control systems allow developers to work in their own branch, merging and integration have become an integral part of the development process.	These systems use automatic and advanced merging techniques to help developers to merge their modifications in the development repositories. However, these techniques do not guarantee to have a functional system. While the use of branching in the development process offers numerous advantages, the activity of merging and integrating changes is hampered by the lack of comprehensive support to assist developers in these activities.For example, the integration of changes can have an unexpected impact on the design or behavior of the system, leading to the introduction of subtle bugs. Furthermore, developers are not supported when integrating changes across branches (cherry picking), when dealing with branches that have diverged, when finding the dependencies between changes, or when assessing the potential impact of changes. In this dissertation we present an approach that aims at alleviating these problems by providing developers and, more precisely, integrators with semi-automated support for assisted integration within a branch and across branches. We focus on helping integrators with their information needs when understanding and integrating changes by means of characterizations of changes and streams of changes (i.e., sequence of successive changes within a branch) together with their dependencies.These characterizations rely on the first-class representation of systems' histories and changes based on program entities and their relationships rather than on files and text. For this, we provide a family of meta-models (Ring, RingH, RingS and RingC) that offer us the representation of program entities, systems' histories, changes and their dependencies, along with analyses for version comparison, and change and dependency identification. Instances of these meta-models are then used by our proposed tool support to enable integrators to analyze the characterizations and changes. Torch, a visual tool, and JET, a set of tools, actually provide the information needs to assist integration within a branch and across branches by means of the characterization of changes and streams of changes respectively.},
  hal-id = {tel-00835097},
  month = oct}

@article{Uqui13a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
  title = {Visually charactering source code changes},
  journal = {Journal of Science of Computer Programming},
  year = {2012},
  impactfactor = {5-year impact factor (2012) 0.903},
  doi = {10.1016/j.scico.2013.08.002},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui13a-SCICO-Official-VisuallyCharacterizingChange.pdf},
  abstract = {Revision Control Systems (e.g. SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects.},
  annote = {internationaljournal},
  hal-id = {inria-00862049},
  keywords = {stefPub lse-pub raweb2013 pharo pharo-pub kzMeta kzMerging kzVisualization}}

@article{Uqui14a,
  author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Andy Kellens},
  title = {Supporting Streams of Changes during Branch Integration},
  journal = {Journal of Science of Computer Programming},
  year = {2014},
  impactfactor = {5-year impact factor (2012) 0.903},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Uqui14a-SCISCO-StreamsOfChanges.pdf},
  abstract = {Revision Control Systems (e.g. SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects.},
  annote = {internationaljournal},
  hal = {http://hal.inria.fr/hal-01060524},
  hal-id = {hal-01060534},
  keywords = {stefPub lse-pub raweb2014 pharo pharo-pub kzMeta kzMerging}}

@inproceedings{Verh17a,
  author = {Verhaeghe, Beno{\^\i}t and Nicolas Anquetil and St\'ephane Ducasse and Vincent Blondeau},
  title = {Usage of Tests in an Open-Source Community},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {4:1--4:9},
  publisher = {ACM},
  year = {2017},
  doi = {10.1145/3139903.3139909},
  annote = {internationalworkshop},
  abstract = {During the development, it is known that tests ensure the good behavior of applications and improve their quality. We studied developers testing behavior inside the Pharo community in the purpose to improve it. In this paper, we take inspiration from a paper of the literature to enhance our comprehension of test habits in our open source community. We report results of a field study on how often the developers use tests in their daily practice, whether they make use of tests selection and why they do. Results are strengthened by interviews with developers involved in the study. The main findings are that developers run tests every modifications of their code they did; most of the time they practice test selection (instead of launching an entire test suite); however they are not accurate in their selection; they change their selection depending on the duration of the tests and; contrary to expectation, test selection is not influenced by the size of the test suite.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {4},
  numpages = {9},
  address = {New York, NY, USA},
  keywords = {lse-pub ; Regression Test Selection ; Case study ; Inter- views ; Pharo Community kzChecking},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Verh17a-IWST-TestUsage.pdf},
  tagnicolasa = {other test},
  hal-id = {hal-01579106}}

@inproceedings{Verh19a,
  author = {Verhaeghe, Beno{\^\i}t and Etien, Anne and Anquetil, Nicolas and Seriai, Abderrahmane and Deruelle, Laurent and Ducasse, St\'ephane and Derras, Mustapha},
  title = {{GUI} Migration using {MDE} from {GWT} to {Angular} 6: An Industrial Case},
  booktitle = {2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02019015},
  annote = {internationalconference},
  hal-id = {hal-02019015},
  abstract = {During the evolution of an application, it happens that developers must change the programming language. In the context of a collaboration with Berger-Levrault, a major IT company, we are working on the migration of a GWT application to Angular. We focus on the GUI aspect of this migration which, even if both frameworks are web Graphical User Interface (GUI) frameworks, is made difficult because they use different programming languages and different organization schema. Such migration is complicated by the fact that the new application must be able to mimic closely the visual aspect of the old one so that the users of the application are not disrupted. We propose an approach in four steps that uses a meta-model to represent the GUI at a high abstraction level. We evaluated this approach on an application comprising 470 Java (GWT) classes representing 56 pages. We are able to model all the web pages of the application and 93% of the widgets they contain, and we successfully migrated 26 out of 39 pages (66%). We give examples of the migrated pages, both successful and not.},
  tagnicolasa = {other migration gui},
  address = {Hangzhou, China}}

@inproceedings{Verh19b,
  author = {Dutriez, Clement and Verhaeghe, Beno{\^i}t and Derras, Mustapha},
  title = {Switching of {GUI} framework: the case from {Spec} to {Spec} 2},
  booktitle = {Proceedings of the 14th Edition of the International Workshop on Smalltalk Technologies},
  year = {2019},
  url = {https://hal.archives-ouvertes.fr/hal-02297858},
  address = {Cologne, Germany},
  month = aug,
  keywords = {lse-pub ; GUI ; Modernization ; Spec ; Spec 2},
  pdf = {https://hal.archives-ouvertes.fr/hal-02297858/file/iwst19.pdf},
  hal-id = {hal-02297858}}

@inproceedings{Verh19c,
  author = {Verhaeghe, Beno{\^i}t and Etien, Anne and Ducasse, St{\'e}phane and Seriai, Abderrahmane and Deruelle, Laurent and Derras, Mustapha},
  title = {Migration de {GWT} vers {Angular} 6 en utilisant l'{IDM}},
  booktitle = {Conf{\'e}rence en Ing{\'e}nierie du Logiciel},
  year = {2019},
  url = {https://hal.inria.fr/hal-02304296},
  address = {Toulouse, France},
  month = jun,
  pdf = {https://hal.inria.fr/hal-02304296/file/ciel2019.pdf},
  hal-id = {hal-02304296}}

@inproceedings{Verh19d,
  author = {Verhaeghe, Beno{\^i}t and Anquetil, Nicolas and Ducasse, St{\'e}phane and Seriai, Abderrahmane and Deruelle, Laurent and Derras, Mustapha},
  title = {Migrating {GWT} to {Angular} 6 using {MDE}},
  booktitle = {12th Seminar on Advanced Techniques \& Tools for Software Evolution},
  year = {2019},
  url = {https://hal.inria.fr/hal-02304301},
  address = {Bolzano, Italy},
  month = jul,
  tagnicolasa = {other migration gui},
  pdf = {https://hal.inria.fr/hal-02304301/file/sattose2019.pdf},
  hal-id = {hal-02304301}}

@inproceedings{Verh19e,
  author = {Verhaeghe, Beno{\^i}t and Fuhrman, Christopher and Guerrouj, Latifa and Anquetil, Nicolas and Ducasse, St{\'e}phane},
  title = {Empirical Study of Programming to an Interface},
  booktitle = {Proceedings of 34th Conference on Automated Software Engineering (ASE'19)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02353681},
  address = {San Diego, United States},
  month = nov,
  tagnicolasa = {other quality},
  annote = {internationalworkshop},
  url = {https://hal.inria.fr/hal-02353681},
  hal-id = {hal-02304301}}

@inproceedings{Verw11a,
  author = {Toon Verwaest and Camillo Bruni and Mircea Lungu and Oscar Nierstrasz},
  title = {Flexible object layouts: enabling lightweight language extensions by intercepting slot access},
  booktitle = {Proceedings of 26th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA '11)},
  pages = {959--972},
  publisher = {ACM},
  year = {2011},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Verw11a-OOSPLA11-FlexibleObjectLayouts.pdf},
  doi = {10.1145/2048066.2048138},
  abstract = {Programming idioms, design patterns and application libraries often introduce
cumbersome and repetitive boilerplate code to a software system. Language
extensions and external DSLs (domain specific languages) are sometimes
introduced to reduce the need for boilerplate code, but they also complicate
the system by introducing the need for language dialects and inter-language
mediation.
To address this, we propose to extend the structural reflective model of the
language with object layouts, layout scopes and slots.
Based on the new reflective language model we can 1) provide behavioral hooks
to object layouts that are triggered when the fields of an object are accessed
and 2) simplify the implementation of state-related language extensions such as
stateful traits. By doing this we show how many idiomatic use cases that
normally require boilerplate code can be more effectively supported.
We present an implementation in Smalltalk, and illustrate its usage through a
series of extended examples.},
  address = {New York, NY, USA},
  annote = {topconference internationalconference},
  hal-id = {hal-00641716},
  isbn = {978-1-4503-0940-0},
  keywords = {raweb20011 scg lse-pub},
  location = {Portland, Oregon, USA},
  medium = {0}}

@inproceedings{Vigg18a,
  author = {Viggiato, Markos and Terra, Ricardo and Rocha, Henrique and Valente, Marco T\'ulio. and Figueiredo, Euardo},
  title = {Microservices in Practice: A Survey Study},
  booktitle = {6th Brazilian Workshop on Software Visualization, Evolution, and Maintenance},
  pages = {1--8},
  year = {2018},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Vigg18a-VEE-Microservices-in-Practice.pdf},
  abstract = {Microservices architectures have become largely popular in the last years. However, we still lack empirical evidence about the use of microservices and the practices followed by practitioners. Thereupon, in this paper, we report the results of a survey with 122 professionals who work with microservices. We report how the industry is using this architectural style and whether the percep- tion of practitioners regarding the advantages and challenges of microservices is according to the literature.},
  series = {VEM},
  keywords = {Microservices lse-pub},
  hal-id = {hal-01944464}}

@inproceedings{Vizc05a,
  author = {Aurora Vizca\'{\i}no and Nicolas Anquetil and Kathia Oliveira and Francisco Ruiz},
  title = {Merging Software Maintenance Ontologies: Our Experience},
  booktitle = {First Workshop on Ontology, Conceptualizations and Epistemology for Soft},
  publisher = {IEEE Computer Society},
  year = {2005},
  address = {Washington, DC, USA},
  annote = {internationalworkshop},
  tagnicolasa = {knowledge}}

@inproceedings{Webs05a,
  author = {Webster, Kenia P. Batista and de Oliveira, Kathia M. and Anquetil, Nicolas},
  title = {A Risk Taxonomy Proposal for Software Maintenance},
  booktitle = {Proceedings of the 21st IEEE International Conference on Software Maintenance},
  pages = {453--461},
  publisher = {IEEE Computer Society},
  year = {2005},
  doi = {10.1109/ICSM.2005.14},
  abstract = {There can be no doubt that risk management is an important activity in the software engineering area. One proof of this is the large body of work existing in this area. However, when one takes a closer look at it, one perceives that almost all this work is concerned with risk management for software development projects. The literature on risk management for software maintenance is much scarcer. On the other hand, software maintenance projects do present specificities that imply they offer different risks than development. This suggests that maintenance projects could greatly benefit from better risk management tools. One step in this direction would be to help identifying potential risk factors at the beginning of a maintenance project. For this, we propose a taxonomy of possible risks for software management projects. The ontology was created from: i) an extensive survey of risk management literature, to list known risk factors for software development; and, ii) an extensive survey of maintenance literature, to list known problems that may occur during maintenance.},
  address = {Washington, DC, USA},
  annote = {topconference internationalconference},
  isbn = {0-7695-2368-4},
  tagnicolasa = {other analysis}}

@inproceedings{Weih05a,
  author = {Marcel Weiher and St\'ephane Ducasse},
  title = {High-Order Messaging},
  booktitle = {Proceedings of International Symposium on Dynamic Languages (SDL'05)},
  pages = {23--34},
  publisher = {ACM Press},
  year = {2005},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Weih05aHigherOrderMessagingOOPSLA2005.pdf},
  abstract = {We introduce Higher Order Messaging, a higher order
 programming mechanism for dynamic object-oriented
 languages. Higher Order Messages allow user-defined
 message dispatch mechanism to be expressed using an
 optimally compact syntax that is a natural extension
 of plain messaging and also have a simple conceptual
 model. They can be implemented without extending the
 base language and operate through language bridges.},
  annote = {internationalconference},
  keywords = {stefPub jb06 listic kzLanguageDesign kzMessaging}}

@inproceedings{Wern14a,
  author = {Wernli, Erwann and Nierstrasz, Oscar and Teruel, Camille and Ducasse, St\'ephane},
  title = {Delegation Proxies: The Power of Propagation},
  booktitle = {Proceedings of the 13th International Conference on Modularity},
  year = {2014},
  url = {http://rmod.inria.fr/archive/papers/Wern13a-DelegatingProxy-AOSD.pdf},
  address = {Lugano, Suisse},
  annote = {internationalconference topconference},
  hal-id = {hal-00958573},
  keywords = {lse-pub stefPub kzLanguageDesign kzMessaging},
  month = {apr}}

@inproceedings{Wint02a,
  author = {Michael Winter and Thomas Gen{\ss}ler and Alexander Christoph and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Gabriela Ar{\'e}valo and Peter M\"uller and Christian Stich and Bastiaan Sch\"onhage},
  title = {Components for Embedded Software --- The PECOS Approach},
  booktitle = {Proc. Second International Workshop on Composition Languages},
  year = {2002},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wint02a.pdf},
  abstract = {This paper presents a domain specific composition language called CoCo. The CoCo language has been
developed in the context of the PECOS project which aims at enabling component-based technology for a		certain class of embedded systems called "field devices".},
  annote = {internationalworkshop},
  keywords = {pecos stefPub arevalo kzComponent kzLanguageDesign},
  note = {In conjunction with 16th European Conference on Object-Oriented Programming (ECOOP) Malaga, Spain, June 11, 2002}}

@inproceedings{Wuyt01a,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Symbiotic Reflection between an Object-Oriented and a Logic Programming Language},
  booktitle = {ECOOP 2001 International Workshop on MultiParadigm Programming with Object-Oriented Languages},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01a.pdf},
  abstract = {Meta-programming is the act of using one system or
 language to reason about another one. Reflection
 describes systems that have access to and change a
 causally connected representation of themselves,
 hence leading to self-extensible systems . Up to
 now, most of the reflective languages have been
 implemented in the same paradigm. In this paper, we
 propose \emph{symbiotic reflection} as a way to
 integrate a meta programming language with the
 object-oriented language it reasons about and is
 implemented in. New to this approach is that any
 element of the implementation language can be
 reasoned about and acted upon (not only the self
 representation), and that both languages are of
 different paradigms. Moreover, every language
 implementer that is faced with the problem of
 allowing the base language to access the underlying
 meta-language has to solve the problem of enabling
 entity transfer between both worlds. We propose a
 uniform schema, called upping/downing, to this
 problem that avoid explicit wrapping or
 typechecking. We illustrate this with SOUL (the
 Smalltalk Open Unification Language), a logic
 programming language in symbiotic reflection with
 the object-oriented language Smalltalk. We show how
 SOUL does logic reasoning directly on Smalltalk
 objects, and how to use this to implement type
 snooping},
  annote = {internationalworkshop},
  keywords = {stefPub kzReflection}}

@inproceedings{Wuyt01c,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Composition Languages for Black-Box Components},
  booktitle = {First OOPSLA Workshop on Language Mechanisms for Programming Software Components},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01c.pdf},
  abstract = {Supporting reuse of existing pieces of code is one
 of the main goals of software engineering. In the
 name of reuse, module-based programming languages
 came to be, only to be surpassed by object-oriented
 technology. With the same motivation component-based
 solutions are overtaking object-oriented solutions.
 However, the delegation-only focus of
 component-based programming risks of resulting in
 the same problems that modular-based approaches ran
 into. To counter this, we claim that one of th e
 important problems that should be addressed by
 component languages is the composition of
 components. More specifically, we see component
 languages where components are black-box
 abstractions, and with (one or more) composition
 languages to glue them tog ether. As an example we
 show a functional (Piccola) and a logic (QSoul)
 composition approach.},
  annote = {internationalworkshop},
  keywords = {component kzComponents kzLanguageDesign Pecos stefPub}}

@inproceedings{Wuyt01d,
  author = {Roel Wuyts and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
  title = {Applying Experiences with Declarative Codifications of Software Architectures on COD},
  booktitle = {Ecoop 6th International Workshop on Component-Oriented Programming},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01d.pdf},
  abstract = {This position paper presents some preliminary work
 we made for applying declarative component oriented
 design in the context of embedded devices. We
 quickly describes COMES the model we develop and
 present how logic rules can be used to describe
 architectures.},
  annote = {internationalworkshop},
  keywords = {component Pecos stefPub arevalo kzComponent kzArchi kzChecking}}

@inproceedings{Wuyt01e,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Non-Functional Requirements in a Component Model for Embedded Systems},
  booktitle = {International Workshop on Specification and Verification of Component-Based Systems},
  year = {2001},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt01e.pdf},
  abstract = {In this paper we describe an interesting context to
 study formal methods for component systems: embedded
 devices. The context of embedded devices is highly
 constrained by the physical requirements the devices
 have to adhere to. As a result, component models for
 embedded devices are not general purpose but geared
 towards these constrained contexts. In this paper we
 give the concrete setting of the Pecos project (a
 project with as goal component engineering for
 embedded devices). We describe the Pecos component
 model, and show possibilities where we think formal
 verification could be useful. We would like to use
 this as a very concrete example to discuss formal
 verification techniques.},
  annote = {internationalworkshop},
  keywords = {scg-pub skip-doi snf01 jb01 component Pecos stefPub kzComponent kzLanguageDesign}}

@article{Wuyt04a,
  author = {Roel Wuyts and St\'ephane Ducasse},
  title = {Unanticipated Integration of Development Tools using the Classification Model},
  journal = {Journal of Computer Languages, Systems and Structures},
  volume = {30},
  pages = {63--77},
  publisher = {Elsevier},
  year = {2004},
  impactfactor = {Impact factor (2010) 0.541},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt04aClassifications.pdf},
  doi = {10.1016/j.cl.2003.08.003},
  abstract = {The increasing complexity of software development
 spawns lots of specialised tools to edit code,
 employ UML schemes, integrate documentation, and so
 on. The problem is that the tool builders themselves
 are responsible for making their tools interoperable
 with other tools or development environments.
 Because they cannot anticipate all other tools they
 can integrate with, a lot of tools cannot
 co-operate. This paper introduces the classication
 model, a lightweight integration medium that enables
 unrelated tools that were not meant to be integrated
 to cooperate easily. Moreover, the tool integration
 is done by a tool integrator, and not by the tool
 builder. To validate this claim, we show how to
 integrate several third-party tools using the
 classication model, and how it forms the foundation
 for the StarBrowser, a Smalltalk browser integrating
 different tools.},
  annote = {internationaljournal},
  keywords = {stefPub kzIDE},
  number = {1-2}}

@inproceedings{Wuyt04x,
  author = {Roel Wuyts and Serge Demeyer and St\'ephane Ducasse and Kim Mens},
  title = {Report of the {ECOOP}'04 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology. ECOOP'04 Workshop Reader},
  volume = {3344},
  pages = {177--186},
  publisher = {Springer-Verlag},
  year = {2004},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt04x-OOR04Report.pdf},
  doi = {10.1007/b104146},
  abstract = {This paper reports on the results of the Fifth
 International Workshop on Object-Oriented
 Reengineering in Oslo on June 15, 2004. It
 enumerates the presentations made, classifies the
 contributions and lists the main results of the
 discussions held at the workshop. As such it
 provides the context for future workshops around
 this topic.},
  annote = {workshopproceedings},
  isbn = {978-3-540-23988-8},
  keywords = {scg-pub stefPub recast04 kzEditor},
  series = {LNCS}}

@article{Wuyt05a,
  author = {Roel Wuyts and St\'ephane Ducasse and Oscar Nierstrasz},
  title = {A Data-centric Approach to Composing Embedded, Real-time Software Components},
  journal = {Journal of Systems and Software --- Special Issue on Automated Component-Based Software Engineering},
  volume = {74},
  pages = {25--34},
  publisher = {Elsevier},
  year = {2005},
  misc = {SCI impact factor 0.744},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt05aPecosElsevier.pdf},
  doi = {10.1016/j.jss.2003.05.004},
  abstract = {Software for embedded systems must cope with a variety of stringent constraints, such as real-time requirements, small memory footprints, and low power consumption. It is usually implemented using low-level programming languages, and as a result has not benefitted from component-based software development techniques. This paper describes a \emph{data-centric component model} for embedded devices that (i) minimizes the number of concurrent tasks needed to implement the system, (ii) allows one to verify whether components meet their deadlines by applying Rate Monotonic Analysis (RMA), and (iii) can generate and verify schedules using Constraint Logic Programming (CLP). This model forms the foundation for a suite of tools for specifying, composing, verifying and deploying embedded software components developed in the context of the \pecos project.},
  annote = {internationaljournal},
  keywords = {scg-pub jb03 pecos stefPub kzComponent kzLanguageDesign},
  number = {1}}

@inproceedings{Wuyt07a,
  author = {Roel Wuyts and Serge Demeyer and Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Kim Mens and St\'ephane Ducasse},
  title = {Report of the 7th ECOOP'06 Workshop on Object-Oriented Reengineering},
  booktitle = {Object-Oriented Technology. ECOOP'06 Workshop Reader},
  pages = {69--71},
  publisher = {Springer-Verlag},
  year = {2007},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Wuyt07-WoorWorkshop.pdf},
  annote = {workshopproceedings},
  keywords = {stefPub kzEditor},
  series = {LNCS}}

@mastersthesis{Zait19a,
  author = {Oleksandr Zaitsev},
  title = {Aspects of software naturalness through the generation of identifier names},
  year = {2019},
  school = {Ukrainian Catholic University, Faculty of Applied Sciences, Department of Computer Sciences},
  url = {http://er.ucu.edu.ua/handle/1/1338},
  address = {Lviv, Ukraine},
  month = jan,
  note = {Under sup. of St\'ephane Ducasse and Alexandre Bergel}}

@techreport{Zait20a,
  author = {Zaitsev, Oleksandr and Ducasse, St\'ephane and Anquetil, Nicolas},
  title = {Characterizing Pharo Code: A Technical Report},
  year = {2020},
  url = {https://hal.inria.fr/hal-02440055},
  type = {Technical Report},
    keywords = {kzPharo},
  institution = {Inria Lille Nord Europe - Laboratoire CRIStAL - Universit\'e de Lille ; Arolla},
  tagnicolasa = {other},
  annote = {technicalreport},
  month = {jan},
  hal-id = {hal-02440055},
  hal-url = {https://hal.inria.fr/hal-02440055}}

@inproceedings{Zait20b,
  title={Suggesting Descriptive Method Names: An Exploratory Study of Two Machine Learning Approaches},
  author={Zaitsev, Oleksandr and Ducasse, Stephane and Bergel, Alexandre and Eveillard, Mathieu},
  booktitle={International Conference on the Quality of Information and Communications Technology},
  pages={93--106},
  keywords = {kzEvolution},
  annote = {internationalconference},
  year={2020},
  organization={Springer}
  }
